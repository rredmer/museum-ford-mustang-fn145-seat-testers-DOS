***
*** AUTO.SPX
***
*
 PRIVATE m.cuRrarea, m.taLkstat, m.coMpstat
 IF SET('TALK')='ON'
      SET TALK OFF
      m.taLkstat = 'ON'
 ELSE
      m.taLkstat = 'OFF'
 ENDIF
 m.coMpstat = SET('COMPATIBLE')
 SET COMPATIBLE FOXPLUS
 IF  .NOT. WEXIST('auto') .OR. UPPER(WTITLE('AUTO'))=='AUTO.PJX' .OR.  ;
     UPPER(WTITLE('AUTO'))=='AUTO.SCX' .OR. UPPER(WTITLE('AUTO'))== ;
     'AUTO.MNX' .OR. UPPER(WTITLE('AUTO'))=='AUTO.PRG' .OR.  ;
     UPPER(WTITLE('AUTO'))=='AUTO.FRX' .OR. UPPER(WTITLE('AUTO'))=='AUTO.QPR'
      DEFINE WINDOW auTo FROM 0, 0 TO 24, 79 NOFLOAT NOCLOSE SHADOW TITLE  ;
             ' FN-74/FN-116/FN-145/PN-102 Seat Tester - Auto Test '  ;
             NOMINIMIZE COLOR SCHEME 1
 ENDIF
 PUSH KEY CLEAR
 m.auTotest = .T.
 m.hvErsion = 0
 m.svErsion = 0
 m.hmOnth = 0
 m.hdAy = 0
 m.hyEar = 0
 m.smOnth = 0
 m.sdAy = 0
 m.syEar = 0
 IF WVISIBLE('auto')
      ACTIVATE WINDOW SAME auTo
 ELSE
      ACTIVATE WINDOW NOSHOW auTo
 ENDIF
 @ 3, 27 TO 20, 36
 @ 3, 4 TO 20, 45
 @ 22, 1 GET m.duMmy DEFAULT 0 SIZE 1, 1, 1 PICTURE '@*IVN '
 @ 5, 6 SAY 'Front Movement' SIZE 1, 14, 0 COLOR GR+/B 
 @ 6, 6 SAY 'Back Movement' SIZE 1, 13, 0 COLOR GR+/B 
 @ 7, 6 SAY 'Horizontal Movement' SIZE 1, 19, 0 COLOR GR+/B 
 @ 8, 6 SAY 'Recline Movement' SIZE 1, 16, 0 COLOR GR+/B 
 @ 9, 6 SAY 'Lumbar' SIZE 1, 6, 0 COLOR GR+/B 
 @ 13, 6 SAY 'Rate-of-Travel' SIZE 1, 14, 0 COLOR GR+/B 
 @ 3, 27 SAY 'Â' SIZE 1, 1, 0 COLOR W+/B 
 @ 3, 36 SAY 'Â' SIZE 1, 1, 0 COLOR W+/B 
 @ 20, 27 SAY 'Á' SIZE 1, 1, 0 COLOR W+/B 
 @ 10, 6 SAY 'Heat' SIZE 1, 4, 0 COLOR GR+/B 
 @ 11, 6 SAY 'Diagnostics' SIZE 1, 11, 0 COLOR GR+/B 
 @ 12, 69 SAY '/' SIZE 1, 1, 0
 @ 12, 72 SAY '/' SIZE 1, 1, 0
 @ 9, 69 SAY '/' SIZE 1, 1, 0
 @ 9, 72 SAY '/' SIZE 1, 1, 0
 @ 11, 67 SAY 'v' SIZE 1, 1, 0
 @ 8, 67 SAY 'v' SIZE 1, 1, 0
 @ 11, 48 SAY 'DSM Software Info:' SIZE 1, 18, 0 COLOR GR+/B 
 @ 8, 48 SAY 'DSM Hardware Info:' SIZE 1, 18, 0 COLOR GR+/B 
 @ 12, 6 SAY 'Mirrors' SIZE 1, 7, 0 COLOR GR+/B 
 @ 2, 3 SAY ALLTRIM(m.paRtdesc) SIZE 1, 73
 @ 8, 68 SAY m.hvErsion SIZE 1, 3 PICTURE '@B 999'
 @ 9, 67 SAY m.hmOnth SIZE 1, 2 PICTURE '@L'
 @ 9, 70 SAY m.hdAy SIZE 1, 2 PICTURE '@L'
 @ 9, 73 SAY m.hyEar SIZE 1, 2 PICTURE '@L'
 @ 11, 68 SAY m.svErsion SIZE 1, 3 PICTURE '@B 999'
 @ 12, 67 SAY m.smOnth SIZE 1, 2 PICTURE '@L'
 @ 12, 70 SAY m.sdAy SIZE 1, 2 PICTURE '@L'
 @ 12, 73 SAY m.syEar SIZE 1, 2 PICTURE '@L'
 @ 4, 29 SAY IIF(teSt_lvl(1), IIF(m.peNding, '', IIF(reSp_lvl(1,1),  ;
   'PASSED', '')), 'n/a') SIZE 1, 6 PICTURE '@!' COLOR G+/B 
 @ 4, 38 SAY IIF(teSt_lvl(1), IIF(m.peNding, '', IIF(reSp_lvl(1,1), '',  ;
   'FAILED')), '') SIZE 1, 6 PICTURE '@!' COLOR R+/B* 
 @ 5, 29 SAY IIF(teSt_lvl(2), IIF(m.peNding, '', IIF(reSp_lvl(2,1),  ;
   'PASSED', '')), 'n/a') SIZE 1, 6 PICTURE '@!' COLOR G+/B 
 @ 6, 29 SAY IIF(teSt_lvl(3), IIF(m.peNding, '', IIF(reSp_lvl(3,1),  ;
   'PASSED', '')), 'n/a') SIZE 1, 6 PICTURE '@!' COLOR G+/B 
 @ 7, 29 SAY IIF(teSt_lvl(4), IIF(m.peNding, '', IIF(reSp_lvl(4,1),  ;
   'PASSED', '')), 'n/a') SIZE 1, 6 PICTURE '@!' COLOR G+/B 
 @ 8, 29 SAY IIF(teSt_lvl(5), IIF(m.peNding, '', IIF(reSp_lvl(5,1),  ;
   'PASSED', '')), 'n/a') SIZE 1, 6 PICTURE '@!' COLOR G+/B 
 @ 9, 29 SAY IIF(teSt_lvl(6), IIF(m.peNding, '', IIF(reSp_lvl(6,1),  ;
   'PASSED', '')), 'n/a') SIZE 1, 6 PICTURE '@!' COLOR G+/B 
 @ 10, 29 SAY IIF(teSt_lvl(7), IIF(m.peNding, '', IIF(reSp_lvl(7,1),  ;
   'PASSED', '')), 'n/a') SIZE 1, 6 PICTURE '@!' COLOR G+/B 
 @ 11, 29 SAY IIF(teSt_lvl(8), IIF(m.peNding, '', IIF(reSp_lvl(8,1),  ;
   'PASSED', '')), 'n/a') SIZE 1, 6 PICTURE '@!' COLOR G+/B 
 @ 12, 29 SAY IIF(teSt_lvl(9), IIF(m.peNding, '', IIF(reSp_lvl(9,1),  ;
   'PASSED', '')), 'n/a') SIZE 1, 6 PICTURE '@!' COLOR G+/B 
 @ 13, 29 SAY IIF(teSt_lvl(10), IIF(m.peNding, '', IIF(reSp_lvl(10,1),  ;
   'PASSED', '')), 'n/a') SIZE 1, 6 PICTURE '@!' COLOR G+/B 
 @ 5, 38 SAY IIF(teSt_lvl(2), IIF(m.peNding, '', IIF(reSp_lvl(2,1), '',  ;
   'FAILED')), '') SIZE 1, 6 PICTURE '@!' COLOR R+/B* 
 @ 6, 38 SAY IIF(teSt_lvl(3), IIF(m.peNding, '', IIF(reSp_lvl(3,1), '',  ;
   'FAILED')), '') SIZE 1, 6 PICTURE '@!' COLOR R+/B* 
 @ 7, 38 SAY IIF(teSt_lvl(4), IIF(m.peNding, '', IIF(reSp_lvl(4,1), '',  ;
   'FAILED')), '') SIZE 1, 6 PICTURE '@!' COLOR R+/B* 
 @ 8, 38 SAY IIF(teSt_lvl(5), IIF(m.peNding, '', IIF(reSp_lvl(5,1), '',  ;
   'FAILED')), '') SIZE 1, 6 PICTURE '@!' COLOR R+/B* 
 @ 9, 38 SAY IIF(teSt_lvl(6), IIF(m.peNding, '', IIF(reSp_lvl(6,1), '',  ;
   'FAILED')), '') SIZE 1, 6 PICTURE '@!' COLOR R+/B* 
 @ 10, 38 SAY IIF(teSt_lvl(7), IIF(m.peNding, '', IIF(reSp_lvl(7,1), '',  ;
   'FAILED')), '') SIZE 1, 6 PICTURE '@!' COLOR R+/B* 
 @ 11, 38 SAY IIF(teSt_lvl(8), IIF(m.peNding, '', IIF(reSp_lvl(8,1), '',  ;
   'FAILED')), '') SIZE 1, 6 PICTURE '@!' COLOR R+/B* 
 @ 12, 38 SAY IIF(teSt_lvl(9), IIF(m.peNding, '', IIF(reSp_lvl(9,1), '',  ;
   'FAILED')), '') SIZE 1, 6 PICTURE '@!' COLOR R+/B* 
 @ 13, 38 SAY IIF(teSt_lvl(10), IIF(m.peNding, '', IIF(reSp_lvl(10,1), '',  ;
   'FAILED')), '') SIZE 1, 6 PICTURE '@!' COLOR R+/B* 
 @ 4, 6 SAY 'Module Version Check' SIZE 1, 20, 0 COLOR GR+/B 
 @ 6, 67 SAY IIF(m.cfGdvrside=1, m.moDuletype, 'N/A') SIZE 1, 10 PICTURE '@!'
 @ 6, 48 SAY 'DSM Type.........:' SIZE 1, 18, 0 COLOR GR+/B 
 @ 4, 2 SAY '1' SIZE 1, 1, 0 COLOR W/B 
 @ 5, 2 SAY '2' SIZE 1, 1, 0 COLOR W/B 
 @ 6, 2 SAY '3' SIZE 1, 1, 0 COLOR W/B 
 @ 7, 2 SAY '4' SIZE 1, 1, 0 COLOR W/B 
 @ 8, 2 SAY '5' SIZE 1, 1, 0 COLOR W/B 
 @ 9, 2 SAY '6' SIZE 1, 1, 0 COLOR W/B 
 @ 10, 2 SAY '7' SIZE 1, 1, 0 COLOR W/B 
 @ 11, 2 SAY '8' SIZE 1, 1, 0 COLOR W/B 
 @ 12, 2 SAY '9' SIZE 1, 1, 0 COLOR W/B 
 @ 13, 1 SAY '10' SIZE 1, 2, 0 COLOR W/B 
 @ 14, 1 SAY '11' SIZE 1, 2, 0 COLOR W/B 
 @ 15, 1 SAY '12' SIZE 1, 2, 0 COLOR W/B 
 @ 16, 1 SAY '13' SIZE 1, 2, 0 COLOR W/B 
 @ 14, 6 SAY 'Seat belt' SIZE 1, 9, 0 COLOR GR+/B 
 @ 15, 6 SAY 'Driver seat occupied' SIZE 1, 20, 0 COLOR GR+/B 
 @ 16, 6 SAY 'Phone' SIZE 1, 5, 0 COLOR GR+/B 
 @ 14, 29 SAY IIF(teSt_lvl(11), IIF(m.peNding, '', IIF(reSp_lvl(11,1),  ;
   'PASSED', '')), 'n/a') SIZE 1, 6 PICTURE '@!' COLOR G+/B 
 @ 15, 29 SAY IIF(teSt_lvl(12), IIF(m.peNding, '', IIF(reSp_lvl(12,1),  ;
   'PASSED', '')), 'n/a') SIZE 1, 6 PICTURE '@!' COLOR G+/B 
 @ 16, 29 SAY IIF(teSt_lvl(13), IIF(m.peNding, '', IIF(reSp_lvl(13,1),  ;
   'PASSED', '')), 'n/a') SIZE 1, 6 PICTURE '@!' COLOR G+/B 
 @ 14, 38 SAY IIF(teSt_lvl(11), IIF(m.peNding, '', IIF(reSp_lvl(11,1), '',  ;
   'FAILED')), '') SIZE 1, 6 PICTURE '@!' COLOR R+/B* 
 @ 15, 38 SAY IIF(teSt_lvl(12), IIF(m.peNding, '', IIF(reSp_lvl(12,1), '',  ;
   'FAILED')), '') SIZE 1, 6 PICTURE '@!' COLOR R+/B* 
 @ 16, 38 SAY IIF(teSt_lvl(13), IIF(m.peNding, '', IIF(reSp_lvl(13,1), '',  ;
   'FAILED')), '') SIZE 1, 6 PICTURE '@!' COLOR R+/B* 
 @ 20, 36 SAY 'Á' SIZE 1, 1, 0 COLOR W+/B 
 @ 1, 3 SAY IIF(m.cfGdvrside=1, 'DRIVER SIDE', 'PASSENGER SIDE') SIZE 1, 14
 @ 17, 1 SAY '14' SIZE 1, 2, 0 COLOR W/B 
 @ 17, 6 SAY 'Recline Switch' SIZE 1, 14, 0 COLOR GR+/B 
 @ 17, 29 SAY IIF(teSt_lvl(14), IIF(m.peNding, '', IIF(reSp_lvl(14,1),  ;
   'PASSED', '')), 'n/a') SIZE 1, 6 PICTURE '@!' COLOR G+/B 
 @ 17, 38 SAY IIF(teSt_lvl(14), IIF(m.peNding, '', IIF(reSp_lvl(14,1), '',  ;
   'FAILED')), '') SIZE 1, 6 PICTURE '@!' COLOR R+/B* 
 @ 18, 1 SAY '19' SIZE 1, 2, 0 COLOR W/B 
 @ 18, 29 SAY IIF(teSt_lvl(19), IIF(m.peNding, '', IIF(reSp_lvl(19,1),  ;
   'PASSED', '')), 'n/a') SIZE 1, 6 PICTURE '@!' COLOR G+/B 
 @ 18, 38 SAY IIF(teSt_lvl(19), IIF(m.peNding, '', IIF(reSp_lvl(19,1), '',  ;
   'FAILED')), '') SIZE 1, 6 PICTURE '@!' COLOR R+/B* 
 @ 18, 6 SAY 'UN93 Heat' SIZE 1, 9, 0 COLOR GR+/B 
 @ 19, 29 SAY IIF(teSt_lvl(20), IIF(m.peNding, '', IIF(reSp_lvl(20,1),  ;
   'PASSED', '')), 'n/a') SIZE 1, 6 PICTURE '@!' COLOR G+/B 
 @ 19, 38 SAY IIF(teSt_lvl(19), IIF(m.peNding, '', IIF(reSp_lvl(19,1), '',  ;
   'FAILED')), '') SIZE 1, 6 PICTURE '@!' COLOR R+/B* 
 @ 19, 6 SAY "'99 Schukra" SIZE 1, 11, 0 COLOR GR+/B 
 @ 19, 1 SAY '20' SIZE 1, 2, 0 COLOR W/B 
 IF  .NOT. WVISIBLE('auto')
      ACTIVATE WINDOW auTo
 ENDIF
 READ CYCLE SHOW _s9t1chetb() WHEN _s9t1cheta()
 RELEASE WINDOW auTo
 IF m.taLkstat='ON'
      SET TALK ON
 ENDIF
 IF m.coMpstat='ON'
      SET COMPATIBLE DB4
 ENDIF
 m.auTotest = .F.
 POP KEY
*
FUNCTION syNopsis
 PRIVATE fiNalrslt
 m.daTe = DATE()
 m.tiMe = TIME()
 m.fiNalrslt = .T.
 m.reSult = .T.
 FOR m.i = 1 TO 19
      IF reSp_lvl(m.i,1)=.F.
           m.fiNalrslt = .F.
           m.reSult = .F.
      ENDIF
 ENDFOR
 m.lvL1rslt = reSp_lvl(1,1)
 m.lvL2rslt = reSp_lvl(2,1)
 m.lvL3rslt = reSp_lvl(3,1)
 m.lvL4rslt = reSp_lvl(4,1)
 m.lvL5rslt = reSp_lvl(5,1)
 m.lvL6rslt = reSp_lvl(6,1)
 m.lvL7rslt = reSp_lvl(7,1)
 m.lvL8rslt = reSp_lvl(8,1)
 m.lvL9rslt = reSp_lvl(9,1)
 m.lvL10rslt = reSp_lvl(10,1)
 m.lvL11rslt = reSp_lvl(11,1)
 m.lvL12rslt = reSp_lvl(12,1)
 m.lvL13rslt = reSp_lvl(13,1)
 m.lvL14rslt = reSp_lvl(14,1)
 m.lvL15rslt = reSp_lvl(15,1)
 m.lvL16rslt = reSp_lvl(16,1)
 m.lvL17rslt = reSp_lvl(17,1)
 m.lvL18rslt = reSp_lvl(18,1)
 m.lvL19rslt = reSp_lvl(19,1)
 RETURN m.fiNalrslt
*
PROCEDURE _s9t1cheta
 IF auTocheck()
      = swDaltimer()
      = clEarpromp()
      IF syNopsis()
           = swRingbell()
           WAIT WINDOW NOWAIT 'SEAT PASSED !  Moving to shipping position...'
           IF m.cfGptr
                IF m.cfGtypeptr=1
                     = laBelit(1)
                ELSE
                     = prIntit(1)
                ENDIF
           ENDIF
           IF UPPER(ALLTRIM(m.moDuletype))<>'UN93NONE'
                = shIpit()
           ENDIF
      ELSE
           = swRingbell()
           WAIT WINDOW NOWAIT 'SEAT FAILED !'
           IF m.cfGptr
                IF m.cfGtypeptr=1
                     = laBelit(2)
                ELSE
                     = prIntit(2)
                ENDIF
           ENDIF
           IF teSt_lvl(5) .AND.  .NOT. teSt_lvl(15) .AND.  .NOT. m.baIlout
                IF m.viEwit
                     ACTIVATE WINDOW viEwwin
                     ? 'Moving Recline...'
                ENDIF
                IF (UPPER(ALLTRIM(m.moDuletype))='NONE' .AND. teSt_lvl(14))
                     = laRge_prom('MOVE RECLINE TO SHIPPING POSITION...',0)
                     = swWait(swSecond*m.op_reclshp)
                     = clEarpromp()
                ELSE
                     = moVeloop(5)
                     IF  .NOT. m.baIlout
                          IF m.cfGdvrside=1 .AND.  ;
                             UPPER(ALLTRIM(m.moDuletype))<>'FN-74'
                               = moVestep(6,m.r_Time)
                          ELSE
                               = moVetime(6,m.r_Time)
                          ENDIF
                     ENDIF
                ENDIF
           ENDIF
           SELECT erRorlist
           COUNT ALL TO m.mcOunt
           IF m.mcOunt>0
                DEFINE WINDOW erRwin FROM 20, 0 TO 24, 79 TITLE 'Error Codes'
                ACTIVATE WINDOW erRwin
                GOTO TOP
                SCAN REST
                     ?? ' '+erRorlist.erRcode
                ENDSCAN
                = swWait(0090)
                RELEASE WINDOW erRwin
           ENDIF
      ENDIF
 ENDIF
 = poWerdown()
 WAIT CLEAR
 m.inStance = m.inStance+1
 SAVE TO (ciNstance) ALL LIKE Instance
 INSERT INTO (cdAtalog) FROM MEMVAR
 USE IN daTalog
 CLEAR READ
*
PROCEDURE _s9t1chetb
 PRIVATE cuRrwind
 STORE WOUTPUT() TO cuRrwind
 IF SYS(2016)='AUTO' .OR. SYS(2016)='*'
      ACTIVATE WINDOW SAME auTo
      @ 2, 3 SAY ALLTRIM(m.paRtdesc) SIZE 1, 73, 0
      @ 8, 68 SAY m.hvErsion SIZE 1, 3, 0 PICTURE '@B 999'
      @ 9, 67 SAY m.hmOnth SIZE 1, 2, 0 PICTURE '@L'
      @ 9, 70 SAY m.hdAy SIZE 1, 2, 0 PICTURE '@L'
      @ 9, 73 SAY m.hyEar SIZE 1, 2, 0 PICTURE '@L'
      @ 11, 68 SAY m.svErsion SIZE 1, 3, 0 PICTURE '@B 999'
      @ 12, 67 SAY m.smOnth SIZE 1, 2, 0 PICTURE '@L'
      @ 12, 70 SAY m.sdAy SIZE 1, 2, 0 PICTURE '@L'
      @ 12, 73 SAY m.syEar SIZE 1, 2, 0 PICTURE '@L'
      @ 4, 29 SAY IIF(teSt_lvl(1), IIF(m.peNding, '', IIF(reSp_lvl(1,1),  ;
        'PASSED', '')), 'n/a') SIZE 1, 6, 0 PICTURE '@!' COLOR G+/B 
      @ 4, 38 SAY IIF(teSt_lvl(1), IIF(m.peNding, '', IIF(reSp_lvl(1,1),  ;
        '', 'FAILED')), '') SIZE 1, 6, 0 PICTURE '@!' COLOR R+/B* 
      @ 5, 29 SAY IIF(teSt_lvl(2), IIF(m.peNding, '', IIF(reSp_lvl(2,1),  ;
        'PASSED', '')), 'n/a') SIZE 1, 6, 0 PICTURE '@!' COLOR G+/B 
      @ 6, 29 SAY IIF(teSt_lvl(3), IIF(m.peNding, '', IIF(reSp_lvl(3,1),  ;
        'PASSED', '')), 'n/a') SIZE 1, 6, 0 PICTURE '@!' COLOR G+/B 
      @ 7, 29 SAY IIF(teSt_lvl(4), IIF(m.peNding, '', IIF(reSp_lvl(4,1),  ;
        'PASSED', '')), 'n/a') SIZE 1, 6, 0 PICTURE '@!' COLOR G+/B 
      @ 8, 29 SAY IIF(teSt_lvl(5), IIF(m.peNding, '', IIF(reSp_lvl(5,1),  ;
        'PASSED', '')), 'n/a') SIZE 1, 6, 0 PICTURE '@!' COLOR G+/B 
      @ 9, 29 SAY IIF(teSt_lvl(6), IIF(m.peNding, '', IIF(reSp_lvl(6,1),  ;
        'PASSED', '')), 'n/a') SIZE 1, 6, 0 PICTURE '@!' COLOR G+/B 
      @ 10, 29 SAY IIF(teSt_lvl(7), IIF(m.peNding, '', IIF(reSp_lvl(7,1),  ;
        'PASSED', '')), 'n/a') SIZE 1, 6, 0 PICTURE '@!' COLOR G+/B 
      @ 11, 29 SAY IIF(teSt_lvl(8), IIF(m.peNding, '', IIF(reSp_lvl(8,1),  ;
        'PASSED', '')), 'n/a') SIZE 1, 6, 0 PICTURE '@!' COLOR G+/B 
      @ 12, 29 SAY IIF(teSt_lvl(9), IIF(m.peNding, '', IIF(reSp_lvl(9,1),  ;
        'PASSED', '')), 'n/a') SIZE 1, 6, 0 PICTURE '@!' COLOR G+/B 
      @ 13, 29 SAY IIF(teSt_lvl(10), IIF(m.peNding, '', IIF(reSp_lvl(10, ;
        1), 'PASSED', '')), 'n/a') SIZE 1, 6, 0 PICTURE '@!' COLOR G+/B 
      @ 5, 38 SAY IIF(teSt_lvl(2), IIF(m.peNding, '', IIF(reSp_lvl(2,1),  ;
        '', 'FAILED')), '') SIZE 1, 6, 0 PICTURE '@!' COLOR R+/B* 
      @ 6, 38 SAY IIF(teSt_lvl(3), IIF(m.peNding, '', IIF(reSp_lvl(3,1),  ;
        '', 'FAILED')), '') SIZE 1, 6, 0 PICTURE '@!' COLOR R+/B* 
      @ 7, 38 SAY IIF(teSt_lvl(4), IIF(m.peNding, '', IIF(reSp_lvl(4,1),  ;
        '', 'FAILED')), '') SIZE 1, 6, 0 PICTURE '@!' COLOR R+/B* 
      @ 8, 38 SAY IIF(teSt_lvl(5), IIF(m.peNding, '', IIF(reSp_lvl(5,1),  ;
        '', 'FAILED')), '') SIZE 1, 6, 0 PICTURE '@!' COLOR R+/B* 
      @ 9, 38 SAY IIF(teSt_lvl(6), IIF(m.peNding, '', IIF(reSp_lvl(6,1),  ;
        '', 'FAILED')), '') SIZE 1, 6, 0 PICTURE '@!' COLOR R+/B* 
      @ 10, 38 SAY IIF(teSt_lvl(7), IIF(m.peNding, '', IIF(reSp_lvl(7,1),  ;
        '', 'FAILED')), '') SIZE 1, 6, 0 PICTURE '@!' COLOR R+/B* 
      @ 11, 38 SAY IIF(teSt_lvl(8), IIF(m.peNding, '', IIF(reSp_lvl(8,1),  ;
        '', 'FAILED')), '') SIZE 1, 6, 0 PICTURE '@!' COLOR R+/B* 
      @ 12, 38 SAY IIF(teSt_lvl(9), IIF(m.peNding, '', IIF(reSp_lvl(9,1),  ;
        '', 'FAILED')), '') SIZE 1, 6, 0 PICTURE '@!' COLOR R+/B* 
      @ 13, 38 SAY IIF(teSt_lvl(10), IIF(m.peNding, '', IIF(reSp_lvl(10, ;
        1), '', 'FAILED')), '') SIZE 1, 6, 0 PICTURE '@!' COLOR R+/B* 
      @ 6, 67 SAY IIF(m.cfGdvrside=1, m.moDuletype, 'N/A') SIZE 1, 10, 0  ;
        PICTURE '@!'
      @ 14, 29 SAY IIF(teSt_lvl(11), IIF(m.peNding, '', IIF(reSp_lvl(11, ;
        1), 'PASSED', '')), 'n/a') SIZE 1, 6, 0 PICTURE '@!' COLOR G+/B 
      @ 15, 29 SAY IIF(teSt_lvl(12), IIF(m.peNding, '', IIF(reSp_lvl(12, ;
        1), 'PASSED', '')), 'n/a') SIZE 1, 6, 0 PICTURE '@!' COLOR G+/B 
      @ 16, 29 SAY IIF(teSt_lvl(13), IIF(m.peNding, '', IIF(reSp_lvl(13, ;
        1), 'PASSED', '')), 'n/a') SIZE 1, 6, 0 PICTURE '@!' COLOR G+/B 
      @ 14, 38 SAY IIF(teSt_lvl(11), IIF(m.peNding, '', IIF(reSp_lvl(11, ;
        1), '', 'FAILED')), '') SIZE 1, 6, 0 PICTURE '@!' COLOR R+/B* 
      @ 15, 38 SAY IIF(teSt_lvl(12), IIF(m.peNding, '', IIF(reSp_lvl(12, ;
        1), '', 'FAILED')), '') SIZE 1, 6, 0 PICTURE '@!' COLOR R+/B* 
      @ 16, 38 SAY IIF(teSt_lvl(13), IIF(m.peNding, '', IIF(reSp_lvl(13, ;
        1), '', 'FAILED')), '') SIZE 1, 6, 0 PICTURE '@!' COLOR R+/B* 
      @ 1, 3 SAY IIF(m.cfGdvrside=1, 'DRIVER SIDE', 'PASSENGER SIDE')  ;
        SIZE 1, 14, 0
      @ 17, 29 SAY IIF(teSt_lvl(14), IIF(m.peNding, '', IIF(reSp_lvl(14, ;
        1), 'PASSED', '')), 'n/a') SIZE 1, 6, 0 PICTURE '@!' COLOR G+/B 
      @ 17, 38 SAY IIF(teSt_lvl(14), IIF(m.peNding, '', IIF(reSp_lvl(14, ;
        1), '', 'FAILED')), '') SIZE 1, 6, 0 PICTURE '@!' COLOR R+/B* 
      @ 18, 29 SAY IIF(teSt_lvl(19), IIF(m.peNding, '', IIF(reSp_lvl(19, ;
        1), 'PASSED', '')), 'n/a') SIZE 1, 6, 0 PICTURE '@!' COLOR G+/B 
      @ 18, 38 SAY IIF(teSt_lvl(19), IIF(m.peNding, '', IIF(reSp_lvl(19, ;
        1), '', 'FAILED')), '') SIZE 1, 6, 0 PICTURE '@!' COLOR R+/B* 
      @ 19, 29 SAY IIF(teSt_lvl(20), IIF(m.peNding, '', IIF(reSp_lvl(20, ;
        1), 'PASSED', '')), 'n/a') SIZE 1, 6, 0 PICTURE '@!' COLOR G+/B 
      @ 19, 38 SAY IIF(teSt_lvl(19), IIF(m.peNding, '', IIF(reSp_lvl(19, ;
        1), '', 'FAILED')), '') SIZE 1, 6, 0 PICTURE '@!' COLOR R+/B* 
 ENDIF
 IF  .NOT. EMPTY(cuRrwind)
      ACTIVATE WINDOW SAME (cuRrwind)
 ENDIF
*
***
*** BARCODE.SPX
***
*
 PRIVATE m.cuRrarea, m.taLkstat, m.coMpstat
 IF SET('TALK')='ON'
      SET TALK OFF
      m.taLkstat = 'ON'
 ELSE
      m.taLkstat = 'OFF'
 ENDIF
 m.coMpstat = SET('COMPATIBLE')
 SET COMPATIBLE FOXPLUS
 IF  .NOT. WEXIST('barcode') .OR. UPPER(WTITLE('BARCODE'))=='BARCODE.PJX'  ;
     .OR. UPPER(WTITLE('BARCODE'))=='BARCODE.SCX' .OR.  ;
     UPPER(WTITLE('BARCODE'))=='BARCODE.MNX' .OR.  ;
     UPPER(WTITLE('BARCODE'))=='BARCODE.PRG' .OR.  ;
     UPPER(WTITLE('BARCODE'))=='BARCODE.FRX' .OR.  ;
     UPPER(WTITLE('BARCODE'))=='BARCODE.QPR'
      DEFINE WINDOW baRcode FROM 2, 2 TO 6, 75 NOFLOAT NOCLOSE SHADOW  ;
             TITLE 'Enter Seat Barcode Number' NOMINIMIZE COLOR SCHEME 1
 ENDIF
 PUSH KEY CLEAR
 SET TOPIC TO BARCODE
 PRIVATE baRcodenum
 m.baRcodenum = ''
 SELECT 0
 USE NOUPDATE (m.cpArtnos) ALIAS paRts ORDER PARTNUM
 IF m.cfGdvrside=1
      SET FILTER TO paRts.siDe='D'
 ELSE
      SET FILTER TO paRts.siDe='P'
 ENDIF
 IF WVISIBLE('barcode')
      ACTIVATE WINDOW SAME baRcode
 ELSE
      ACTIVATE WINDOW NOSHOW baRcode
 ENDIF
 @ 1, 26 GET m.baRcodenum DEFAULT ' ' SIZE 1, 20 PICTURE '@!K'
 IF  .NOT. WVISIBLE('barcode')
      ACTIVATE WINDOW baRcode
 ENDIF
 READ VALID _s9t1chf88() WHEN _s9t1chf89()
 RELEASE WINDOW baRcode
 IF m.taLkstat='ON'
      SET TALK ON
 ENDIF
 IF m.coMpstat='ON'
      SET COMPATIBLE DB4
 ENDIF
 USE IN paRts
 SET TOPIC TO
 POP KEY
*
FUNCTION _s9t1chf88
 IF LASTKEY()<>13
      RETURN .F.
 ENDIF
 IF m.cfGptr .AND. m.cfGtypeptr=1
      IF  .NOT. laBelstat()
           = swRingbell()
           RETURN .F.
      ENDIF
 ENDIF
 IF SEEK(m.baRcodenum, 'PARTS')
      SELECT paRts
      SCATTER MEMVAR FIELDS paRtnum, paRtdesc, moDuletype, h_Version, s_Version
      SCATTER TO teSt_lvl FIELDS veRsion, frOnt, reAr, hoRizontal,  ;
              reCline, luMbar, heAt, diAgnostic, miRrors, raTeoftrav,  ;
              seAtbelt, seAtoccup, phOne, reClswitch, reClmanual, scHukra,  ;
              p_Point, heAtonbom, un93heat
      SCATTER MEMVAR FIELDS h_Time, f_Time, b_Time, r_Time
      SCATTER MEMVAR FIELDS h_Travel, f_Travel, b_Travel, r_Travel
      m.bcOdeinfo = m.paRtnum
      CLEAR READ
 ELSE
      = swRingbell()
      WAIT WINDOW NOWAIT 'Seat not found in database !'
      RETURN .F.
 ENDIF
*
PROCEDURE _s9t1chf89
 ON KEY LABEL Alt+X Do End_all
 ON KEY LABEL Alt+M Do Config.spr
 ON KEY LABEL ALT+V Do Viewtog
 ON KEY LABEL ALT+L Do LargeTog
 ON KEY LABEL ALT+H Do ViewHistry
 ON KEY LABEL ALT+A Do About.spr
 ON KEY LABEL ALT+C Do ViewCodes
 ON KEY LABEL ALT+E Do ViewErrors
 ON KEY LABEL F1 Do DO_Help
 ON KEY LABEL ESC Do Silly
*
***
*** BOX.SPX
***
*
 PRIVATE m.cuRrarea, m.taLkstat, m.coMpstat
 IF SET('TALK')='ON'
      SET TALK OFF
      m.taLkstat = 'ON'
 ELSE
      m.taLkstat = 'OFF'
 ENDIF
 m.coMpstat = SET('COMPATIBLE')
 SET COMPATIBLE FOXPLUS
 IF  .NOT. WEXIST('box') .OR. UPPER(WTITLE('BOX'))=='BOX.PJX' .OR.  ;
     UPPER(WTITLE('BOX'))=='BOX.SCX' .OR. UPPER(WTITLE('BOX'))=='BOX.MNX'  ;
     .OR. UPPER(WTITLE('BOX'))=='BOX.PRG' .OR. UPPER(WTITLE('BOX'))== ;
     'BOX.FRX' .OR. UPPER(WTITLE('BOX'))=='BOX.QPR'
      DEFINE WINDOW boX FROM INT((SROWS()-25)/2), INT((SCOLS()-80)/2) TO  ;
             INT((SROWS()-25)/2)+24, INT((SCOLS()-80)/2)+79 NOFLOAT  ;
             NOCLOSE SHADOW TITLE  ;
             ' FN-74/FN-116/FN-145/PN-102 Seat Tester - Box Cycle Movement '  ;
             NOMINIMIZE COLOR SCHEME 1
 ENDIF
 PUSH KEY CLEAR
 m.poInt1 = .F.
 m.poInt2 = .F.
 m.poInt3 = .F.
 m.poInt4 = .F.
 IF WVISIBLE('box')
      ACTIVATE WINDOW SAME boX
 ELSE
      ACTIVATE WINDOW NOSHOW boX
 ENDIF
 @ 1, 64 GET m.duMmy DEFAULT 0 SIZE 1, 1, 1 PICTURE '@*IVN ' COLOR SCHEME 5
 @ 19, 49 SAY 'Press' SIZE 1, 5, 0
 @ 19, 59 SAY 'to Stop/Exit' SIZE 1, 12, 0
 @ 15, 5 TO 21, 40
 @ 21, 5 SAY IIF(m.poInt3, CHR(51), CHR(192)) SIZE 1, 1 COLOR W+/B 
 @ 21, 40 SAY IIF(m.poInt4, CHR(52), CHR(217)) SIZE 1, 1 COLOR W+/B 
 @ 15, 40 SAY IIF(m.poInt1, CHR(49), CHR(191)) SIZE 1, 1 COLOR W+/B 
 @ 15, 5 SAY IIF(m.poInt2, CHR(50), CHR(218)) SIZE 1, 1 COLOR W+/B 
 @ 15, 22 SAY IIF(m.poInt1, CHR(17), CHR(196)) SIZE 1, 1 COLOR W+/B 
 @ 21, 22 SAY IIF(m.poInt3, CHR(16), CHR(196)) SIZE 1, 1 COLOR W+/B 
 @ 18, 40 SAY IIF(m.poInt4, CHR(30), CHR(179)) SIZE 1, 1 COLOR W+/B 
 @ 18, 5 SAY IIF(m.poInt2, CHR(31), CHR(179)) SIZE 1, 1 COLOR W+/B 
 @ 18, 49 SAY 'Press' SIZE 1, 5, 0
 @ 18, 55 SAY 'S' SIZE 1, 1, 0 COLOR GR+/RB 
 @ 18, 57 SAY 'to Start' SIZE 1, 8, 0
 @ 2, 3 SAY ALLTRIM(m.paRtdesc) SIZE 1, 73
 @ 1, 25 SAY IIF(m.cfGdvrside=1, 'DRIVER SIDE', 'PASSENGER SIDE') SIZE 1, 14
 @ 6, 3 SAY 'Horizontal Fwd.:' SIZE 1, 16, 0 COLOR W/B 
 @ 7, 3 SAY 'Horizontal Rev.:' SIZE 1, 16, 0 COLOR W/B 
 @ 8, 3 SAY 'Front Tilt Up  :' SIZE 1, 16, 0 COLOR W/B 
 @ 9, 3 SAY 'Front Tilt Down:' SIZE 1, 16, 0 COLOR W/B 
 @ 10, 3 SAY 'Rear Tilt Up   :' SIZE 1, 16, 0 COLOR W/B 
 @ 11, 3 SAY 'Rear Tilt Down :' SIZE 1, 16, 0 COLOR W/B 
 @ 12, 3 SAY 'Recliner Fwd.  :' SIZE 1, 16, 0 COLOR W/B 
 @ 13, 3 SAY 'Recliner Rev.  :' SIZE 1, 16, 0 COLOR W/B 
 @ 7, 27 SAY 'mm/sec' SIZE 1, 6, 0 COLOR W/B 
 @ 8, 27 SAY 'mm/sec' SIZE 1, 6, 0 COLOR W/B 
 @ 9, 27 SAY 'mm/sec' SIZE 1, 6, 0 COLOR W/B 
 @ 10, 27 SAY 'mm/sec' SIZE 1, 6, 0 COLOR W/B 
 @ 11, 27 SAY 'mm/sec' SIZE 1, 6, 0 COLOR W/B 
 @ 12, 27 SAY 'deg/sec' SIZE 1, 7, 0 COLOR W/B 
 @ 13, 27 SAY 'deg/sec' SIZE 1, 7, 0 COLOR W/B 
 @ 4, 3 SAY 'Motor/Direction' SIZE 1, 15, 0 COLOR W/B 
 @ 4, 20 SAY 'Average Speed' SIZE 1, 13, 0 COLOR W/B 
 @ 4, 50 SAY 'Travel Time' SIZE 1, 11, 0 COLOR W/B 
 @ 5, 3 TO 5, 60 COLOR W/B 
 @ 6, 58 SAY 'sec' SIZE 1, 3, 0 COLOR W/B 
 @ 7, 58 SAY 'sec' SIZE 1, 3, 0 COLOR W/B 
 @ 8, 58 SAY 'sec' SIZE 1, 3, 0 COLOR W/B 
 @ 9, 58 SAY 'sec' SIZE 1, 3, 0 COLOR W/B 
 @ 10, 58 SAY 'sec' SIZE 1, 3, 0 COLOR W/B 
 @ 11, 58 SAY 'sec' SIZE 1, 3, 0 COLOR W/B 
 @ 12, 58 SAY 'sec' SIZE 1, 3, 0 COLOR W/B 
 @ 13, 58 SAY 'sec' SIZE 1, 3, 0 COLOR W/B 
 @ 6, 20 SAY m.roT_hf SIZE 1, 6 PICTURE '99.999'
 @ 7, 20 SAY m.roT_hr SIZE 1, 6 PICTURE '99.999'
 @ 8, 20 SAY m.roT_fu SIZE 1, 6 PICTURE '99.999'
 @ 9, 20 SAY m.roT_fd SIZE 1, 6 PICTURE '99.999'
 @ 10, 20 SAY m.roT_bu SIZE 1, 6 PICTURE '99.999'
 @ 11, 20 SAY m.roT_bd SIZE 1, 6 PICTURE '99.999'
 @ 12, 20 SAY m.roT_rf SIZE 1, 6 PICTURE '99.999'
 @ 13, 20 SAY m.roT_rr SIZE 1, 6 PICTURE '99.999'
 @ 6, 27 SAY 'mm/sec' SIZE 1, 6, 0 COLOR W/B 
 @ 6, 51 SAY m.tiMe_hf SIZE 1, 6 PICTURE '99.999'
 @ 7, 51 SAY m.tiMe_hr SIZE 1, 6 PICTURE '99.999'
 @ 8, 51 SAY m.tiMe_fu SIZE 1, 6 PICTURE '99.999'
 @ 9, 51 SAY m.tiMe_fd SIZE 1, 6 PICTURE '99.999'
 @ 10, 51 SAY m.tiMe_bu SIZE 1, 6 PICTURE '99.999'
 @ 11, 51 SAY m.tiMe_bd SIZE 1, 6 PICTURE '99.999'
 @ 12, 51 SAY m.tiMe_rf SIZE 1, 6 PICTURE '99.999'
 @ 13, 51 SAY m.tiMe_rr SIZE 1, 6 PICTURE '99.999'
 @ 4, 35 SAY 'Travel Length' SIZE 1, 13, 0 COLOR W/B 
 @ 6, 37 SAY m.h_Travel SIZE 1, 6 PICTURE '999.9'
 @ 7, 37 SAY m.h_Travel SIZE 1, 6 PICTURE '999.9'
 @ 8, 37 SAY m.f_Travel SIZE 1, 6 PICTURE '999.9'
 @ 9, 37 SAY m.f_Travel SIZE 1, 6 PICTURE '999.9'
 @ 10, 37 SAY m.b_Travel SIZE 1, 6 PICTURE '999.9'
 @ 11, 37 SAY m.b_Travel SIZE 1, 6 PICTURE '999.9'
 @ 12, 40 SAY m.r_Travel SIZE 1, 3 PICTURE '999'
 @ 13, 40 SAY m.r_Travel SIZE 1, 3 PICTURE '999'
 @ 6, 44 SAY 'mm' SIZE 1, 2, 0 COLOR W/B 
 @ 7, 44 SAY 'mm' SIZE 1, 2, 0 COLOR W/B 
 @ 8, 44 SAY 'mm' SIZE 1, 2, 0 COLOR W/B 
 @ 9, 44 SAY 'mm' SIZE 1, 2, 0 COLOR W/B 
 @ 10, 44 SAY 'mm' SIZE 1, 2, 0 COLOR W/B 
 @ 11, 44 SAY 'mm' SIZE 1, 2, 0 COLOR W/B 
 @ 12, 44 SAY 'deg' SIZE 1, 3, 0 COLOR W/B 
 @ 13, 44 SAY 'deg' SIZE 1, 3, 0 COLOR W/B 
 @ 1, 3 SAY ALLTRIM(m.paRtnum) SIZE 1, 20
 @ 1, 41 SAY DATE() SIZE 1, 8
 @ 1, 51 SAY TIME() SIZE 1, 8
 @ 20, 49 SAY 'Press' SIZE 1, 5, 0
 @ 20, 55 SAY 'P' SIZE 1, 1, 0 COLOR GR+/RB 
 @ 20, 57 SAY 'to Print' SIZE 1, 8, 0
 @ 19, 55 SAY 'Esc' SIZE 1, 3, 0 COLOR GR+/RB 
 IF  .NOT. WVISIBLE('box')
      ACTIVATE WINDOW boX
 ENDIF
 READ CYCLE SHOW _s9t1chfl6() WHEN _s9t1chfl5()
 RELEASE WINDOW boX
 IF m.taLkstat='ON'
      SET TALK ON
 ENDIF
 IF m.coMpstat='ON'
      SET COMPATIBLE DB4
 ENDIF
 = poWerdown()
 POP KEY
*
PROCEDURE geT_keypre
 PARAMETER thEkey
 IF m.viEwit
      DEACTIVATE WINDOW viEwwin
 ENDIF
 DO CASE
      CASE m.thEkey=83 .OR. m.thEkey=115
           m.baIlout = .F.
           DO boX_cycle
      CASE m.thEkey=80 .OR. m.thEkey=112
           DO prInt_rot
 ENDCASE
 RETURN
*
PROCEDURE _s9t1chfl5
 ON KEY LABEL X DO GET_KEYPRESSED WITH LASTKEY()
 ON KEY LABEL S DO GET_KEYPRESSED WITH LASTKEY()
 ON KEY LABEL Alt+V Do viewtog
 ON KEY LABEL ALT+L Do LargeTog
 ON KEY LABEL P DO GET_KEYPRESSED WITH LASTKEY()
 IF  .NOT. poWerup()
      WAIT WINDOW NOWAIT 'Power Up Failure !'
      CLEAR READ
 ENDIF
*
PROCEDURE _s9t1chfl6
 PRIVATE cuRrwind
 STORE WOUTPUT() TO cuRrwind
 IF SYS(2016)='BOX' .OR. SYS(2016)='*'
      ACTIVATE WINDOW SAME boX
      @ 21, 5 SAY IIF(m.poInt3, CHR(51), CHR(192)) SIZE 1, 1, 0 COLOR W+/B 
      @ 21, 40 SAY IIF(m.poInt4, CHR(52), CHR(217)) SIZE 1, 1, 0 COLOR W+/B 
      @ 15, 40 SAY IIF(m.poInt1, CHR(49), CHR(191)) SIZE 1, 1, 0 COLOR W+/B 
      @ 15, 5 SAY IIF(m.poInt2, CHR(50), CHR(218)) SIZE 1, 1, 0 COLOR W+/B 
      @ 15, 22 SAY IIF(m.poInt1, CHR(17), CHR(196)) SIZE 1, 1, 0 COLOR W+/B 
      @ 21, 22 SAY IIF(m.poInt3, CHR(16), CHR(196)) SIZE 1, 1, 0 COLOR W+/B 
      @ 18, 40 SAY IIF(m.poInt4, CHR(30), CHR(179)) SIZE 1, 1, 0 COLOR W+/B 
      @ 18, 5 SAY IIF(m.poInt2, CHR(31), CHR(179)) SIZE 1, 1, 0 COLOR W+/B 
      @ 2, 3 SAY ALLTRIM(m.paRtdesc) SIZE 1, 73, 0
      @ 1, 25 SAY IIF(m.cfGdvrside=1, 'DRIVER SIDE', 'PASSENGER SIDE')  ;
        SIZE 1, 14, 0
      @ 6, 20 SAY m.roT_hf SIZE 1, 6, 0 PICTURE '99.999'
      @ 7, 20 SAY m.roT_hr SIZE 1, 6, 0 PICTURE '99.999'
      @ 8, 20 SAY m.roT_fu SIZE 1, 6, 0 PICTURE '99.999'
      @ 9, 20 SAY m.roT_fd SIZE 1, 6, 0 PICTURE '99.999'
      @ 10, 20 SAY m.roT_bu SIZE 1, 6, 0 PICTURE '99.999'
      @ 11, 20 SAY m.roT_bd SIZE 1, 6, 0 PICTURE '99.999'
      @ 12, 20 SAY m.roT_rf SIZE 1, 6, 0 PICTURE '99.999'
      @ 13, 20 SAY m.roT_rr SIZE 1, 6, 0 PICTURE '99.999'
      @ 6, 51 SAY m.tiMe_hf SIZE 1, 6, 0 PICTURE '99.999'
      @ 7, 51 SAY m.tiMe_hr SIZE 1, 6, 0 PICTURE '99.999'
      @ 8, 51 SAY m.tiMe_fu SIZE 1, 6, 0 PICTURE '99.999'
      @ 9, 51 SAY m.tiMe_fd SIZE 1, 6, 0 PICTURE '99.999'
      @ 10, 51 SAY m.tiMe_bu SIZE 1, 6, 0 PICTURE '99.999'
      @ 11, 51 SAY m.tiMe_bd SIZE 1, 6, 0 PICTURE '99.999'
      @ 12, 51 SAY m.tiMe_rf SIZE 1, 6, 0 PICTURE '99.999'
      @ 13, 51 SAY m.tiMe_rr SIZE 1, 6, 0 PICTURE '99.999'
      @ 6, 37 SAY m.h_Travel SIZE 1, 6, 0 PICTURE '999.9'
      @ 7, 37 SAY m.h_Travel SIZE 1, 6, 0 PICTURE '999.9'
      @ 8, 37 SAY m.f_Travel SIZE 1, 6, 0 PICTURE '999.9'
      @ 9, 37 SAY m.f_Travel SIZE 1, 6, 0 PICTURE '999.9'
      @ 10, 37 SAY m.b_Travel SIZE 1, 6, 0 PICTURE '999.9'
      @ 11, 37 SAY m.b_Travel SIZE 1, 6, 0 PICTURE '999.9'
      @ 12, 40 SAY m.r_Travel SIZE 1, 3, 0 PICTURE '999'
      @ 13, 40 SAY m.r_Travel SIZE 1, 3, 0 PICTURE '999'
      @ 1, 3 SAY ALLTRIM(m.paRtnum) SIZE 1, 20, 0
      @ 1, 41 SAY DATE() SIZE 1, 8, 0
      @ 1, 51 SAY TIME() SIZE 1, 8, 0
 ENDIF
 IF  .NOT. EMPTY(cuRrwind)
      ACTIVATE WINDOW SAME (cuRrwind)
 ENDIF
*
***
*** CHGPARM.SPX
***
*
 PRIVATE m.cuRrarea, m.taLkstat, m.coMpstat
 IF SET('TALK')='ON'
      SET TALK OFF
      m.taLkstat = 'ON'
 ELSE
      m.taLkstat = 'OFF'
 ENDIF
 m.coMpstat = SET('COMPATIBLE')
 SET COMPATIBLE FOXPLUS
 IF  .NOT. WEXIST('chgparm') .OR. UPPER(WTITLE('CHGPARM'))=='CHGPARM.PJX'  ;
     .OR. UPPER(WTITLE('CHGPARM'))=='CHGPARM.SCX' .OR.  ;
     UPPER(WTITLE('CHGPARM'))=='CHGPARM.MNX' .OR.  ;
     UPPER(WTITLE('CHGPARM'))=='CHGPARM.PRG' .OR.  ;
     UPPER(WTITLE('CHGPARM'))=='CHGPARM.FRX' .OR.  ;
     UPPER(WTITLE('CHGPARM'))=='CHGPARM.QPR'
      DEFINE WINDOW chGparm FROM INT((SROWS()-12)/2), INT((SCOLS()-63)/2)  ;
             TO INT((SROWS()-12)/2)+11, INT((SCOLS()-63)/2)+62 NOFLOAT  ;
             NOCLOSE SHADOW TITLE 'Change threshold parameters'  ;
             NOMINIMIZE COLOR SCHEME 1
 ENDIF
 PUBLIC olDhofwsta, olDhobksta, olDhorista
 m.olDhofwsta = m.hoFwstall
 m.olDhobksta = m.hoBkstall
 m.olDhorista = m.hoRistall
 IF WVISIBLE('chgparm')
      ACTIVATE WINDOW SAME chGparm
 ELSE
      ACTIVATE WINDOW NOSHOW chGparm
 ENDIF
 @ 4, 4 SAY 'New ' SIZE 1, 4, 0
 @ 2, 4 SAY 'New horizontal forward stall threshold:' SIZE 1, 39, 0
 @ 4, 8 SAY 'horizontal backward stall threshold: ' SIZE 1, 37, 0
 @ 6, 4 SAY 'New horizontal forward/backward stall timing:' SIZE 1, 45, 0
 @ 2, 50 GET hoFwstall DEFAULT 0 SIZE 1, 10 PICTURE '@K'
 @ 4, 50 GET hoBkstall DEFAULT 0 SIZE 1, 10 PICTURE '@K' VALID _s9t1chfv4()
 @ 6, 50 GET hoRistall DEFAULT 0 SIZE 1, 10 PICTURE '@K'
 @ 9, 21 GET btNend DEFAULT 1 SIZE 1, 8, 1 PICTURE '@*HT \!\<Ok;\<Cancel'  ;
   VALID _s9t1chfwb()
 IF  .NOT. WVISIBLE('chgparm')
      ACTIVATE WINDOW chGparm
 ENDIF
 READ CYCLE
 RELEASE WINDOW chGparm
 IF m.taLkstat='ON'
      SET TALK ON
 ENDIF
 IF m.coMpstat='ON'
      SET COMPATIBLE DB4
 ENDIF
*
FUNCTION _s9t1chfv4
 IF m.hoBkstall<0
      m.hoBkstall = m.olDhobksta
 ENDIF
 RETURN .T.
*
PROCEDURE _s9t1chfwb
 IF m.btNend=2
      m.hoFwstall = m.olDhofwsta
      m.hoBkstall = m.olDhobksta
      m.hoRistall = m.olDhorista
 ENDIF
*
***
*** EPROGRAM.FXP
***
*
 SET SYSMENU TO DEFAULT
 ON ERROR
 CLOSE DATABASES
 IF  .NOT. ISBLANK(SYS(9))
      SET HELP TO
 ENDIF
 ON KEY
 SET LIBRARY TO
 CLEAR
 CLEAR MEMO
 CLEAR ALL
 CLOSE ALL
 RELEASE ALL
*
***
*** FILENAME.FXP
***
*
 PUBLIC ciSo_mess
 PUBLIC csCp_mess
 PUBLIC cdAtalog
 PUBLIC cdTc
 PUBLIC cpArtnos
 m.ciSo_mess = ''
 m.csCp_mess = ''
 m.cdAtalog = ''
 m.cdTc = ''
 m.cpArtnos = ''
 PUBLIC ciNstance
 PUBLIC ccOnfigure
 PUBLIC coPerator
 PUBLIC csEtuppath
 PUBLIC cdAtapath
 PUBLIC cpRogpath
 m.csEtuppath = ALLTRIM(GETENV('FNSETUP'))
 m.cdAtapath = ALLTRIM(GETENV('FNDATA'))
 m.cpRogpath = ALLTRIM(GETENV('FNPROG'))
 PUBLIC viEwit
 viEwit = .F.
 PUBLIC cfGshort
 PUBLIC cfGshtest
 PUBLIC cfGshtime
 PUBLIC cfGtypeptr
 PUBLIC cfGid
 PUBLIC cfGdvrside
 PUBLIC cfGbarcode
 PUBLIC cfGautoonl
 PUBLIC cfGptr
 PUBLIC cfGtesttyp
 PUBLIC cfGshtimer
 PUBLIC cfGlabelsi
 PUBLIC cfGcell
 PUBLIC cfGhshippo
 PUBLIC cfGfshippo
 PUBLIC cfGbshippo
 PUBLIC cfGrshippo
 PUBLIC cfGbagpmpt
 PUBLIC cfGmanpmpt
 PUBLIC cfGqc
 PUBLIC cfG2wylumb
 PUBLIC cfGshwait
 PUBLIC op_recldn, op_reclup, op_reclrel, op_lout, op_lin, op_lup, op_ldn
 PUBLIC op_lrel, op_bagfwd, op_bagfwd, op_bagrel, op_sbout, op_sbin, op_cushpr
 PUBLIC op_cushrel, op_reclshp
 PUBLIC un93htlow, un93hthigh, un93httime, un93swtime
 PUBLIC un93cable, un93htrlay, un93igrlay, un93sprlay, caBletype
 IF (m.cdAtapath=='')
      WAIT CLEAR
      CLEAR
      ? 'FNDATA Environment variable not found !'
      ? '---------------------------------------'
      ? 'Please create a DOS environment variable named FNDATA which'
      ? 'contains the name of the directory where the data base files are'
      ? 'located.'
      ?
      ? 'The environment variable(s) may be created using the DOS SET command.'
      ? ' For example:'
      ? '    SET FNDATA=C:\DATABASE'
      ?
      ? 'Press any key to continue.'
      ? ''
      = INKEY(0)
      QUIT
 ELSE
      IF RIGHT(m.cdAtapath, 1)<>'\'
           m.cdAtapath = m.cdAtapath+'\'
      ENDIF
      m.ciSo_mess = m.cdAtapath+'ISO_MESS.DBF'
      m.csCp_mess = m.cdAtapath+'SCP_MESS.DBF'
      m.cdAtalog = m.cdAtapath+'DATALOG.DBF'
      m.cdTc = m.cdAtapath+'DTC.DBF'
      m.cpArtnos = m.cdAtapath+'PARTS.DBF'
 ENDIF
 PUBLIC m.op_mlin
 PUBLIC m.op_mlout
 PUBLIC m.op_mlrel
 IF (m.csEtuppath=='')
      WAIT CLEAR
      CLEAR
      ? 'FNSETUP Environment variable not found !'
      ? '---------------------------------------'
      ? 'Please create a DOS environment variable named FNSETUP which'
      ? "contains the name of the directory where the application's setup"
      ? 'files are located.'
      ?
      ? 'The environment variable(s) may be created using the DOS SET command.'
      ? ' For example:'
      ? '    SET FNSETUP=C:\SETUPS'
      ?
      ? 'Press any key to continue.'
      ? ''
      = INKEY(0)
      QUIT
 ENDIF
 IF (m.cpRogpath=='')
      WAIT CLEAR
      CLEAR
      ? 'FNPROG Environment variable not found !'
      ? '---------------------------------------'
      ? 'Please create a DOS environment variable named FNPROG which'
      ? 'contains the name of the directory where the application files'
      ? 'are located.'
      ?
      ? 'The environment variable(s) may be created using the DOS SET command.'
      ? ' For example:'
      ? '    SET FNPROG=C:\PROGRAM'
      ?
      ? 'Press any key to continue.'
      ? ''
      = INKEY(0)
      QUIT
 ELSE
      IF RIGHT(m.cpRogpath, 1)<>'\'
           m.cpRogpath = m.cpRogpath+'\'
      ENDIF
      SET HELP TO cpRogpath+'HELPFILE.DBF'
 ENDIF
 IF  .NOT. FILE(m.ciSo_mess)
      WAIT CLEAR
      CLEAR
      ? 'Tester ISO-9141 Message Database file not found !'
      ? '-------------------------------------------------'
      ? 'Please make sure the DOS environment variable named FNDATA contains'
      ? 'the name of the directory where the data base files are located.'
      ?
      ? 'The environment variable may be created using the DOS SET command.'
      ? '  For example:'
      ? '    SET FNDATA=C:\DATABASE'
      ?
      ? 'Press any key to continue.'
      ? ''
      = INKEY(0)
      QUIT
 ENDIF
 IF  .NOT. FILE(m.csCp_mess)
      WAIT CLEAR
      CLEAR
      ? 'Tester SCP Message Database file not found !'
      ? '--------------------------------------------'
      ? 'Please make sure the DOS environment variable named FNDATA contains'
      ? 'the name of the directory where the data base files are located.'
      ?
      ? 'The environment variable may be created using the DOS SET command.'
      ? '  For example:'
      ? '    SET FNDATA=C:\DATABASE'
      ?
      ? 'Press any key to continue.'
      ? ''
      = INKEY(0)
      QUIT
 ENDIF
 IF  .NOT. FILE(m.cdAtalog)
      WAIT CLEAR
      CLEAR
      ? 'Tester Datalog Database file not found !'
      ? '----------------------------------------'
      ? 'Please make sure the DOS environment variable named FNDATA contains'
      ? 'the name of the directory where the data base files are located.'
      ?
      ? 'The environment variable may be created using the DOS SET command.'
      ? '  For example:'
      ? '    SET FNDATA=C:\DATABASE'
      ?
      ? 'Press any key to continue.'
      ? ''
      = INKEY(0)
      QUIT
 ENDIF
 IF  .NOT. FILE(m.cdTc)
      WAIT CLEAR
      CLEAR
      ? 'Tester DTC Database file not found !'
      ? '------------------------------------'
      ? 'Please make sure the DOS environment variable named FNDATA contains'
      ? 'the name of the directory where the data base files are located.'
      ?
      ? 'The environment variable may be created using the DOS SET command.'
      ? '  For example:'
      ? '    SET FNDATA=C:\DATABASE'
      ?
      ? 'Press any key to continue.'
      ? ''
      = INKEY(0)
      QUIT
 ENDIF
 IF RIGHT(m.csEtuppath, 1)<>'\'
      m.csEtuppath = m.csEtuppath+'\'
 ENDIF
 m.ciNstance = m.csEtuppath+'INSTANCE.MEM'
 RESTORE FROM (ciNstance) ADDITIVE
 m.ccOnfigure = m.csEtuppath+'TESTER.MEM'
 IF FILE(ccOnfigure)
      RESTORE FROM (ccOnfigure) ADDITIVE
 ENDIF
 m.teSter_id = m.cfGid
 m.ccOnfigure = m.csEtuppath+'CFGUN93.MEM'
 IF FILE(ccOnfigure)
      RESTORE FROM (ccOnfigure) ADDITIVE
 ENDIF
 m.coPerator = m.csEtuppath+'TIMING.MEM'
 IF FILE(coPerator)
      RESTORE FROM (coPerator) ADDITIVE
 ELSE
      SAVE TO (coPerator) ALL LIKE Op_*
 ENDIF
*
***
*** MAIN_SCR.SPX
***
*
 PRIVATE m.cuRrarea, m.taLkstat, m.coMpstat
 IF SET('TALK')='ON'
      SET TALK OFF
      m.taLkstat = 'ON'
 ELSE
      m.taLkstat = 'OFF'
 ENDIF
 m.coMpstat = SET('COMPATIBLE')
 SET COMPATIBLE FOXPLUS
 IF  .NOT. WEXIST('main_scr') .OR. UPPER(WTITLE('MAIN_SCR'))== ;
     'MAIN_SCR.PJX' .OR. UPPER(WTITLE('MAIN_SCR'))=='MAIN_SCR.SCX' .OR.  ;
     UPPER(WTITLE('MAIN_SCR'))=='MAIN_SCR.MNX' .OR.  ;
     UPPER(WTITLE('MAIN_SCR'))=='MAIN_SCR.PRG' .OR.  ;
     UPPER(WTITLE('MAIN_SCR'))=='MAIN_SCR.FRX' .OR.  ;
     UPPER(WTITLE('MAIN_SCR'))=='MAIN_SCR.QPR'
      DEFINE WINDOW maIn_scr FROM 0, 0 TO 24, 79 NOFLOAT NOCLOSE SHADOW  ;
             TITLE  ;
             ' FN-74/FN-116/FN-145/PN-102 Seat Tester - Main Screen '  ;
             NOMINIMIZE COLOR SCHEME 1
 ENDIF
 PUSH KEY CLEAR
 PRIVATE leAving, teSttotal, teStspass, teStsfail, yiEld, avEtime, avEstime
 PRIVATE mcOunt
 PRIVATE meNuchange, siDechange, coNfigdone
 m.leAving = .F.
 m.teSttotal = 0
 m.teStspass = 0
 m.teStsfail = 0
 m.yiEld = 0
 m.avEtime = 0
 m.avEstime = 0
 m.mcOunt = 0
 m.meNuchange = .F.
 m.siDechange = .F.
 m.coNfigdone = .F.
 IF WVISIBLE('main_scr')
      ACTIVATE WINDOW SAME maIn_scr
 ELSE
      ACTIVATE WINDOW NOSHOW maIn_scr
 ENDIF
 @ 17, 28 GET m.duMmy DEFAULT 0 SIZE 1, 10, 1 PICTURE '@*IVN '
 @ 1, 3 SAY ALLTRIM(m.paRtdesc) SIZE 1, 73
 @ 18, 28 SAY m.d_Version SIZE 1, 10
 @ 19, 28 SAY IIF(m.cfGdvrside=1, 'DRIVER', 'PASSENGER') SIZE 1, 10
 @ 20, 28 SAY m.inStance SIZE 1, 10 PICTURE '@B'
 @ 18, 66 SAY m.teSttotal SIZE 1, 10 PICTURE '@B'
 @ 19, 66 SAY m.teStspass SIZE 1, 10 PICTURE '@B'
 @ 20, 66 SAY m.teStsfail SIZE 1, 10 PICTURE '@B'
 @ 21, 66 SAY m.yiEld SIZE 1, 10 PICTURE '@B 999.9'
 @ 21, 28 SAY ALLTRIM(STR(m.avEtime))+' seconds' SIZE 1, 10
 @ 18, 40 SAY 'Number of Tests Recorded:' SIZE 1, 25, 0 COLOR W/B 
 @ 19, 2 SAY 'Tester Configuration....:' SIZE 1, 25, 0 COLOR W/B 
 @ 18, 2 SAY 'Tester Software Version.:' SIZE 1, 25, 0 COLOR W/B 
 @ 21, 40 SAY 'Percent Passed..........:' SIZE 1, 25, 0 COLOR W/B 
 @ 19, 40 SAY 'Number of Tests Passed..:' SIZE 1, 25, 0 COLOR W/B 
 @ 20, 40 SAY 'Number of Tests Failed..:' SIZE 1, 25, 0 COLOR W/B 
 @ 20, 2 SAY 'Total Tests Cycled......:' SIZE 1, 25, 0 COLOR W/B 
 @ 21, 2 SAY 'Average Test Time.......:' SIZE 1, 25, 0 COLOR W/B 
 @ 22, 2 SAY 'Average Ship Time.......:' SIZE 1, 25, 0 COLOR W/B 
 @ 22, 28 SAY ALLTRIM(STR(m.avEstime))+' seconds' SIZE 1, 10
 IF  .NOT. WVISIBLE('main_scr')
      ACTIVATE WINDOW maIn_scr
 ENDIF
 READ VALID _s9t1chg7k() CYCLE SHOW _s9t1chg7m() WHEN _s9t1chg7l() MODAL
 RELEASE WINDOW maIn_scr
 IF m.taLkstat='ON'
      SET TALK ON
 ENDIF
 IF m.coMpstat='ON'
      SET COMPATIBLE DB4
 ENDIF
 IF m.leAving
      DO enD_all
 ENDIF
 POP KEY
*
PROCEDURE teStselect
 PARAMETER chOice
 DO CASE
      CASE m.chOice=1
           DO Auto.spr
      CASE m.chOice=2
           DO Manual.spr
      CASE m.chOice=3
           DO Box.spr
      CASE m.chOice=4
           WAIT WINDOW NOWAIT 'Moving to Shipping Position...'
           IF poWerup()
                m.baIlout = .F.
                = shIpit()
                = poWerdown()
           ELSE
                = swRingbell()
                WAIT WINDOW TIMEOUT 3 'Unable to Apply Power to Seat.'
           ENDIF
           WAIT CLEAR
 ENDCASE
 RETURN
*
FUNCTION _s9t1chg7k
 IF READKEY()<>2
      RETURN .F.
 ENDIF
*
FUNCTION _s9t1chg7l
 ON KEY LABEL ESC Do Silly
 ON KEY LABEL ALT+A Do About.spr
 ON KEY LABEL ALT+V Do Viewtog
 ON KEY LABEL ALT+L Do LargeTog
 SELECT 0
 USE NOUPDATE (cdAtalog) ALIAS daTalog
 COUNT ALL TO m.mcOunt
 m.teSttotal = m.mcOunt
 COUNT ALL FOR daTalog.reSult=.T. TO m.mcOunt
 m.teStspass = m.mcOunt
 COUNT ALL FOR daTalog.reSult=.F. TO m.mcOunt
 m.teStsfail = m.mcOunt
 m.yiEld = m.teStspass/m.teSttotal*100
 AVERAGE ALL daTalog.teSt_time TO m.mcOunt
 m.avEtime = m.mcOunt
 AVERAGE ALL daTalog.shIp_time TO m.mcOunt
 m.avEstime = m.mcOunt
 USE IN daTalog
 SHOW GETS
 IF cfGbarcode
      DO Barcode.spr
 ELSE
      DO SeatChoi.spr
 ENDIF
 SHOW GETS
 IF  .NOT. m.meNuchange .AND.  .NOT. m.coNfigdone
      IF m.cfGautoonl
           m.teStchosen = 1
      ELSE
           DO TestChoi.spr
      ENDIF
      IF m.cfGptr .AND. m.cfGtypeptr=1
           IF  .NOT. laBelstat()
                = swRingbell()
                RETURN .F.
           ELSE
                IF  .NOT. m.siDechange
                     DO teStselect WITH m.teStchosen
                ELSE
                     m.siDechange = .F.
                ENDIF
           ENDIF
      ELSE
           IF  .NOT. m.siDechange
                DO teStselect WITH m.teStchosen
           ELSE
                m.siDechange = .F.
           ENDIF
      ENDIF
 ELSE
      m.meNuchange = .F.
 ENDIF
 CLEAR READ
*
PROCEDURE _s9t1chg7m
 PRIVATE cuRrwind
 STORE WOUTPUT() TO cuRrwind
 IF SYS(2016)='MAIN_SCR' .OR. SYS(2016)='*'
      ACTIVATE WINDOW SAME maIn_scr
      @ 1, 3 SAY ALLTRIM(m.paRtdesc) SIZE 1, 73, 0
      @ 18, 28 SAY m.d_Version SIZE 1, 10, 0
      @ 19, 28 SAY IIF(m.cfGdvrside=1, 'DRIVER', 'PASSENGER') SIZE 1, 10, 0
      @ 20, 28 SAY m.inStance SIZE 1, 10, 0 PICTURE '@B'
      @ 18, 66 SAY m.teSttotal SIZE 1, 10, 0 PICTURE '@B'
      @ 19, 66 SAY m.teStspass SIZE 1, 10, 0 PICTURE '@B'
      @ 20, 66 SAY m.teStsfail SIZE 1, 10, 0 PICTURE '@B'
      @ 21, 66 SAY m.yiEld SIZE 1, 10, 0 PICTURE '@B 999.9'
      @ 21, 28 SAY ALLTRIM(STR(m.avEtime))+' seconds' SIZE 1, 10, 0
      @ 22, 28 SAY ALLTRIM(STR(m.avEstime))+' seconds' SIZE 1, 10, 0
 ENDIF
 IF  .NOT. EMPTY(cuRrwind)
      ACTIVATE WINDOW SAME (cuRrwind)
 ENDIF
*
***
*** MANUAL.SPX
***
*
 PRIVATE m.cuRrarea, m.taLkstat, m.coMpstat
 IF SET('TALK')='ON'
      SET TALK OFF
      m.taLkstat = 'ON'
 ELSE
      m.taLkstat = 'OFF'
 ENDIF
 m.coMpstat = SET('COMPATIBLE')
 SET COMPATIBLE FOXPLUS
 IF  .NOT. WEXIST('manual') .OR. UPPER(WTITLE('MANUAL'))=='MANUAL.PJX'  ;
     .OR. UPPER(WTITLE('MANUAL'))=='MANUAL.SCX' .OR.  ;
     UPPER(WTITLE('MANUAL'))=='MANUAL.MNX' .OR. UPPER(WTITLE('MANUAL'))== ;
     'MANUAL.PRG' .OR. UPPER(WTITLE('MANUAL'))=='MANUAL.FRX' .OR.  ;
     UPPER(WTITLE('MANUAL'))=='MANUAL.QPR'
      DEFINE WINDOW maNual FROM INT((SROWS()-25)/2), INT((SCOLS()-80)/2)  ;
             TO INT((SROWS()-25)/2)+24, INT((SCOLS()-80)/2)+79 NOFLOAT  ;
             NOCLOSE SHADOW TITLE  ;
             ' FN-74/FN-116/FN-145/PN-102 Seat Tester - Manual Screen '  ;
             NOMINIMIZE COLOR SCHEME 1
 ENDIF
 PUSH KEY CLEAR
 PRIVATE cuShtoggle, baCktoggle, seTrecall, heAtpresse, meMstatus
 PRIVATE reClactive
 SET TYPEAHEAD TO 0
 m.meMstatus = 'U'
 m.reClactive = .F.
 IF m.moDuletype<>'NONE'
      IF m.moDuletype='FN-74'
           DEFINE POPUP meMchoice FROM 8, 37 TITLE 'Memory' SHADOW MARGIN
           DEFINE BAR 1 OF meMchoice PROMPT 'Recall'
           ON SELECTION POPUP meMchoice DO MemSelect WITH BAR()
      ELSE
           DEFINE POPUP meMchoice FROM 8, 37 TITLE 'Memory' SHADOW MARGIN
           DEFINE BAR 1 OF meMchoice PROMPT 'Recall'
           DEFINE BAR 2 OF meMchoice PROMPT 'Set'
           ON SELECTION POPUP meMchoice DO MemSelect WITH BAR()
      ENDIF
      IF m.moDuletype='FN-74'
           DEFINE POPUP meMwhich FROM 9, 45 TITLE 'Which?' SHADOW MARGIN
           DEFINE BAR 1 OF meMwhich PROMPT '\<1'
           DEFINE BAR 2 OF meMwhich PROMPT '\<2'
           ON SELECTION POPUP meMwhich DO MemFunct WITH BAR()
      ELSE
           DEFINE POPUP meMwhich FROM 9, 45 TITLE 'Which?' SHADOW MARGIN
           DEFINE BAR 1 OF meMwhich PROMPT '\<1'
           DEFINE BAR 2 OF meMwhich PROMPT '\<2'
           DEFINE BAR 3 OF meMwhich PROMPT '\<3'
           ON SELECTION POPUP meMwhich DO MemFunct WITH BAR()
      ENDIF
 ENDIF
 DEFINE POPUP frOnt FROM 15, 61 TITLE 'Front' SHADOW MARGIN
 DEFINE BAR 1 OF frOnt PROMPT 'UP' KEY UPARROW, ''
 DEFINE BAR 2 OF frOnt PROMPT 'DOWN' KEY DNARROW, ''
 ON SELECTION POPUP frOnt DO FrontSel WITH BAR()
 DEFINE POPUP reCline FROM 0, 17 TITLE 'Recline' SHADOW MARGIN
 DEFINE BAR 1 OF reCline PROMPT 'FORWARD' KEY RIGHTARROW, ''
 DEFINE BAR 2 OF reCline PROMPT 'BACK' KEY LEFTARROW, ''
 ON SELECTION POPUP reCline DO ReclineSel WITH BAR()
 DEFINE POPUP baCk FROM 15, 8 TITLE 'Back' SHADOW MARGIN
 DEFINE BAR 1 OF baCk PROMPT 'UP' KEY UPARROW, ''
 DEFINE BAR 2 OF baCk PROMPT 'DOWN' KEY DNARROW, ''
 ON SELECTION POPUP baCk DO BackSel WITH BAR()
 DEFINE POPUP hoRizontal FROM 19, 32 TITLE 'Horizontal' SHADOW MARGIN
 DEFINE BAR 1 OF hoRizontal PROMPT 'FORWARD' KEY RIGHTARROW, ''
 DEFINE BAR 2 OF hoRizontal PROMPT 'BACK' KEY LEFTARROW, ''
 ON SELECTION POPUP hoRizontal DO HorizSel WITH BAR()
 m.cuShtoggle = .F.
 m.baCktoggle = .F.
 m.seTrecall = .T.
 m.heAtpresse = .F.
 IF WVISIBLE('manual')
      ACTIVATE WINDOW SAME maNual
 ELSE
      ACTIVATE WINDOW NOSHOW maNual
 ENDIF
 @ 6, 39 GET m.duMmy DEFAULT 0 SIZE 1, 1, 1 PICTURE '@*IVN ' COLOR SCHEME 1
 @ 15, 19 TO 19, 60
 @ 17, 63 SAY 'RONT' SIZE 1, 4, 0
 @ 17, 62 SAY 'F' SIZE 1, 1, 0 COLOR GR+/RB 
 @ 21, 36 SAY 'ORIZONTAL' SIZE 1, 9, 0
 @ 21, 35 SAY 'H' SIZE 1, 1, 0 COLOR GR+/RB 
 @ 17, 15 SAY 'ACK' SIZE 1, 3, 0
 @ 17, 14 SAY 'B' SIZE 1, 1, 0 COLOR GR+/RB 
 @ 1, 21 SAY 'ECLINE' SIZE 1, 6, 0
 @ 1, 20 SAY 'R' SIZE 1, 1, 0 COLOR GR+/RB 
 @ 17, 35 SAY 'USHION HEAT' SIZE 1, 11, 0
 @ 17, 34 SAY 'C' SIZE 1, 1, 0 COLOR GR+/RB 
 @ 6, 22 SAY 'BACK' SIZE 1, 4, 0
 @ 1, 18 SAY '' SIZE 1, 1, 0
 @ 1, 29 SAY '' SIZE 1, 1, 0
 @ 21, 46 SAY '' SIZE 1, 1, 0
 @ 21, 33 SAY '' SIZE 1, 1, 0
 @ 16, 15 SAY '' SIZE 1, 1, 0
 @ 16, 64 SAY '' SIZE 1, 1, 0
 @ 18, 64 SAY '' SIZE 1, 1, 0
 @ 18, 15 SAY '' SIZE 1, 1, 0
 @ 7, 22 SAY 'HEAT' SIZE 1, 4, 0
 @ 5, 22 SAY 'SE' SIZE 1, 2, 0
 @ 5, 25 SAY 'T' SIZE 1, 1, 0
 @ 5, 24 SAY 'A' SIZE 1, 1, 0 COLOR GR+/RB 
 @ 6, 39 SAY IIF(m.moDuletype<>'NONE' .AND. m.cfGqc, 'M', '') SIZE 1, 1  ;
   COLOR GR+/RB 
 @ 6, 40 SAY IIF(m.moDuletype<>'NONE' .AND. m.cfGqc, 'EMORY:', '') SIZE 1, 13
 @ 7, 40 SAY IIF(m.moDuletype='FN-74' .AND. m.cfGqc, IIF(m.meMstatus='U',  ;
   'UNIDENTIFIED', IIF(m.meMstatus='O', 'OFF', IIF(m.meMstatus='1',  ;
   'DRIVER 1', 'DRIVER 2'))), '') SIZE 1, 12
 @ 5, 37 TO 8, 54
 @ 2, 19 TO 14, 28
 @ 3, 38 SAY 'Press' SIZE 1, 5, 0
 @ 3, 48 SAY 'to Stop/Exit' SIZE 1, 12, 0
 @ 3, 44 SAY 'Esc' SIZE 1, 3, 0 COLOR GR+/RB 
 IF  .NOT. WVISIBLE('manual')
      ACTIVATE WINDOW maNual
 ENDIF
 READ CYCLE SHOW _s9t1chgo7() WHEN _s9t1chgo6()
 RELEASE WINDOW maNual
 IF m.taLkstat='ON'
      SET TALK ON
 ENDIF
 IF m.coMpstat='ON'
      SET COMPATIBLE DB4
 ENDIF
 = poWerdown()
 IF m.moDuletype<>'NONE'
      RELEASE POPUP meMwhich
      RELEASE POPUP meMchoice
 ENDIF
 RELEASE POPUP frOnt
 RELEASE POPUP baCk
 RELEASE POPUP hoRizontal
 SET TYPEAHEAD TO 20
 = INKEY()
 POP KEY
*
PROCEDURE keYdecode
 PARAMETER chOice
 DO CASE
      CASE (m.chOice=114) .OR. (m.chOice=82)
           WAIT WINDOW NOWAIT 'Recline'
           ACTIVATE POPUP reCline
      CASE (m.chOice=97) .OR. (m.chOice=65)
           IF  .NOT. m.baCktoggle
                DO baCkheat WITH 1
                @ 2, 19 FILL TO 14, 28 COLOR W+/R 
                @ 5, 24 FILL TO 5, 24 COLOR GR+/RB 
                m.baCktoggle = .T.
           ELSE
                DO cuShheat WITH 2
                @ 15, 19 FILL TO 19, 60 COLOR W+/B 
                @ 17, 34 FILL TO 17, 34 COLOR GR+/RB 
                m.cuShtoggle = .F.
                DO baCkheat WITH 2
                @ 2, 19 FILL TO 14, 28 COLOR W+/B 
                @ 5, 24 FILL TO 5, 24 COLOR GR+/RB 
                m.baCktoggle = .F.
           ENDIF
      CASE (m.chOice=109) .OR. (m.chOice=77)
           WAIT WINDOW NOWAIT 'Memory'
           ACTIVATE POPUP meMchoice
      CASE (m.chOice=99) .OR. (m.chOice=67)
           IF m.baCktoggle
                IF  .NOT. m.cuShtoggle
                     DO cuShheat WITH 1
                     @ 15, 19 FILL TO 19, 60 COLOR W+/R 
                     @ 17, 34 FILL TO 17, 34 COLOR GR+/RB 
                     m.cuShtoggle = .T.
                ELSE
                     DO cuShheat WITH 2
                     @ 15, 19 FILL TO 19, 60 COLOR W+/B 
                     @ 17, 34 FILL TO 17, 34 COLOR GR+/RB 
                     m.cuShtoggle = .F.
                ENDIF
           ELSE
                WAIT WINDOW NOWAIT 'Seatback heat must be enabled !'
           ENDIF
      CASE (m.chOice=98) .OR. (m.chOice=66)
           WAIT WINDOW NOWAIT 'Back Movement'
           ACTIVATE POPUP baCk
      CASE (m.chOice=104) .OR. (m.chOice=72)
           WAIT WINDOW NOWAIT 'Horizontal Movement'
           ACTIVATE POPUP hoRizontal
      CASE (m.chOice=102) .OR. (m.chOice=70)
           WAIT WINDOW NOWAIT 'Front Movement'
           ACTIVATE POPUP frOnt
      CASE (m.chOice=88) .OR. (m.chOice=120)
           WAIT WINDOW NOWAIT 'Exit'
           CLEAR READ
      OTHERWISE
           WAIT CLEAR
 ENDCASE
 RETURN
*
PROCEDURE meMselect
 PARAMETER chOice
 DO CASE
      CASE m.chOice=1
           WAIT WINDOW NOWAIT 'Memory Recall ?'
           m.seTrecall = .F.
      CASE m.chOice=2
           WAIT WINDOW NOWAIT 'Memory Set ?'
           m.seTrecall = .T.
 ENDCASE
 ACTIVATE POPUP meMwhich
 DEACTIVATE POPUP meMchoice
 RETURN
*
PROCEDURE meMfunct
 PARAMETER chOice
 IF m.seTrecall
      DO meMset WITH m.chOice
 ELSE
      DO meMrecall WITH m.chOice
 ENDIF
 DEACTIVATE POPUP meMwhich
 RETURN
*
PROCEDURE frOntsel
 PARAMETER chOice
 PUSH KEY CLEAR
 SET TYPEAHEAD TO 1
 DO CASE
      CASE m.chOice=1
           DEFINE BAR 1 OF frOnt PROMPT 'STOP' KEY UPARROW, ''
           IF m.cfGqc
                = moVemanual(1)
           ELSE
                = moVeloop(1)
           ENDIF
           DEFINE BAR 1 OF frOnt PROMPT 'UP' KEY UPARROW, ''
      CASE m.chOice=2
           DEFINE BAR 2 OF frOnt PROMPT 'STOP' KEY DNARROW, ''
           IF m.cfGqc
                = moVemanual(2)
           ELSE
                = moVeloop(2)
           ENDIF
           DEFINE BAR 2 OF frOnt PROMPT 'DOWN' KEY DNARROW, ''
 ENDCASE
 SET TYPEAHEAD TO 0
 POP KEY
 RETURN
*
PROCEDURE baCksel
 PARAMETER chOice
 PUSH KEY CLEAR
 SET TYPEAHEAD TO 1
 DO CASE
      CASE m.chOice=1
           DEFINE BAR 1 OF baCk PROMPT 'STOP' KEY UPARROW, ''
           IF m.cfGqc
                = moVemanual(3)
           ELSE
                = moVeloop(3)
           ENDIF
           DEFINE BAR 1 OF baCk PROMPT 'UP' KEY UPARROW, ''
      CASE m.chOice=2
           DEFINE BAR 2 OF baCk PROMPT 'STOP' KEY DNARROW, ''
           IF m.cfGqc
                = moVemanual(4)
           ELSE
                = moVeloop(4)
           ENDIF
           DEFINE BAR 2 OF baCk PROMPT 'DOWN' KEY DNARROW, ''
 ENDCASE
 SET TYPEAHEAD TO 0
 POP KEY
 RETURN
*
PROCEDURE reClinesel
 PARAMETER chOice
 PUSH KEY CLEAR
 SET TYPEAHEAD TO 1
 DO CASE
      CASE m.chOice=1
           DEFINE BAR 1 OF reCline PROMPT 'STOP' KEY RIGHTARROW, ''
           IF m.cfGqc
                = moVemanual(5)
           ELSE
                = moVeloop(5)
           ENDIF
           DEFINE BAR 1 OF reCline PROMPT 'FORWARD' KEY RIGHTARROW, ''
      CASE m.chOice=2
           DEFINE BAR 2 OF reCline PROMPT 'STOP' KEY LEFTARROW, ''
           IF m.cfGqc
                = moVemanual(6)
           ELSE
                = moVeloop(6)
           ENDIF
           DEFINE BAR 2 OF reCline PROMPT 'BACK' KEY LEFTARROW, ''
 ENDCASE
 SET TYPEAHEAD TO 0
 POP KEY
 RETURN
*
PROCEDURE hoRizsel
 PARAMETER chOice
 PUSH KEY CLEAR
 SET TYPEAHEAD TO 1
 DO CASE
      CASE m.chOice=1
           DEFINE BAR 1 OF hoRizontal PROMPT 'STOP' KEY RIGHTARROW, ''
           IF m.cfGqc
                = moVemanual(7)
           ELSE
                = moVeloop(7)
           ENDIF
           DEFINE BAR 1 OF hoRizontal PROMPT 'FORWARD' KEY RIGHTARROW, ''
      CASE m.chOice=2
           DEFINE BAR 2 OF hoRizontal PROMPT 'STOP' KEY LEFTARROW, ''
           IF m.cfGqc
                = moVemanual(8)
           ELSE
                = moVeloop(8)
           ENDIF
           DEFINE BAR 2 OF hoRizontal PROMPT 'BACK' KEY LEFTARROW, ''
 ENDCASE
 SET TYPEAHEAD TO 0
 POP KEY
 RETURN
*
PROCEDURE doManual
 PARAMETER chOice
 IF m.viEwit
      DEACTIVATE WINDOW viEwwin
 ENDIF
 DEACTIVATE POPUP frOnt, baCk, hoRizontal, reCline, meMwhich, meMchoice
 IF LASTKEY()<>97 .AND. LASTKEY()<>65 .AND. LASTKEY()<>99 .AND. LASTKEY()<>67
      m.heAtpresse = .F.
 ENDIF
 DO keYdecode WITH m.chOice
 IF LASTKEY()<>97 .AND. LASTKEY()<>65 .AND. LASTKEY()<>99 .AND. LASTKEY()<>67
      m.heAtpresse = .F.
      KEYBOARD CHR(LASTKEY())
 ELSE
      IF  .NOT. m.heAtpresse
           m.heAtpresse = .T.
           KEYBOARD CHR(LASTKEY())
      ENDIF
 ENDIF
 RETURN
*
PROCEDURE moVemanual
 PARAMETER chOice
 m.baIlout = .F.
 DO CASE
      CASE UPPER(ALLTRIM(m.moDuletype))='FN-74' .OR.  ;
           UPPER(ALLTRIM(m.moDuletype))='FN-145'
           m.stArttime = SECONDS()
           DO CASE
                CASE m.chOice=1
                     = swCrttimer(1,(swSecond*m.frOnstall))
                     = swCrttimer(2,24)
                     DO WHILE swGtimer(2)>0
                          IF baIlout()
                               EXIT
                          ENDIF
                          = frOntmove(1)
                     ENDDO
                     = swDsytimer(2)
                     IF  .NOT. m.baIlout
                          DO WHILE swGtimer(1)>0
                               = frOntmove(1)
                               IF stAll1()
                                    IF m.viEwit
                                         ACTIVATE WINDOW viEwwin
                                         ? 'stall detected'
                                    ENDIF
                                    EXIT
                               ENDIF
                          ENDDO
                     ENDIF
                     = swDsytimer(1)
                CASE m.chOice=2
                     = swCrttimer(1,(swSecond*m.frOnstall))
                     = swCrttimer(2,24)
                     DO WHILE swGtimer(2)>0
                          IF baIlout()
                               EXIT
                          ENDIF
                          = frOntmove(2)
                     ENDDO
                     = swDsytimer(2)
                     IF  .NOT. m.baIlout
                          DO WHILE swGtimer(1)>0
                               = frOntmove(2)
                               IF stAll1()
                                    IF m.viEwit
                                         ACTIVATE WINDOW viEwwin
                                         ? 'stall detected'
                                    ENDIF
                                    EXIT
                               ENDIF
                          ENDDO
                     ENDIF
                     = swDsytimer(1)
                CASE m.chOice=3
                     = swCrttimer(1,(swSecond*m.baCkstall))
                     = swCrttimer(2,24)
                     DO WHILE swGtimer(2)>0
                          IF baIlout()
                               EXIT
                          ENDIF
                          = baCkmove(1)
                     ENDDO
                     = swDsytimer(2)
                     IF  .NOT. m.baIlout
                          DO WHILE swGtimer(1)>0
                               = baCkmove(1)
                               IF stAll1()
                                    IF m.viEwit
                                         ACTIVATE WINDOW viEwwin
                                         ? 'stall detected'
                                    ENDIF
                                    EXIT
                               ENDIF
                          ENDDO
                     ENDIF
                     = swDsytimer(1)
                CASE m.chOice=4
                     = swCrttimer(1,(swSecond*m.baCkstall))
                     = swCrttimer(2,24)
                     DO WHILE swGtimer(2)>0
                          IF baIlout()
                               EXIT
                          ENDIF
                          = baCkmove(2)
                     ENDDO
                     = swDsytimer(2)
                     IF  .NOT. m.baIlout
                          DO WHILE swGtimer(1)>0
                               = baCkmove(2)
                               IF stAll1()
                                    IF m.viEwit
                                         ACTIVATE WINDOW viEwwin
                                         ? 'stall detected'
                                    ENDIF
                                    EXIT
                               ENDIF
                          ENDDO
                     ENDIF
                     = swDsytimer(1)
                CASE m.chOice=5
                     = swCrttimer(1,(swSecond*m.reClstall))
                     = swCrttimer(2,72)
                     DO WHILE swGtimer(2)>0
                          IF baIlout()
                               EXIT
                          ENDIF
                          = reClmove(1)
                     ENDDO
                     = swDsytimer(2)
                     IF  .NOT. m.baIlout
                          DO WHILE swGtimer(1)>0
                               = reClmove(1)
                               IF stAll1()
                                    IF m.viEwit
                                         ACTIVATE WINDOW viEwwin
                                         ? 'stall detected'
                                    ENDIF
                                    EXIT
                               ENDIF
                          ENDDO
                     ENDIF
                     = swDsytimer(1)
                CASE m.chOice=6
                     = swCrttimer(1,(swSecond*m.reClstall))
                     = swCrttimer(2,72)
                     DO WHILE swGtimer(2)>0
                          IF baIlout()
                               EXIT
                          ENDIF
                          = reClmove(2)
                     ENDDO
                     = swDsytimer(2)
                     IF  .NOT. m.baIlout
                          DO WHILE swGtimer(1)>0
                               = reClmove(2)
                               IF stAll1()
                                    IF m.viEwit
                                         ACTIVATE WINDOW viEwwin
                                         ? 'stall detected'
                                    ENDIF
                                    EXIT
                               ENDIF
                          ENDDO
                     ENDIF
                     = swDsytimer(1)
                CASE m.chOice=7
                     = swCrttimer(1,(swSecond*m.hoRistall))
                     = swCrttimer(2,72)
                     DO WHILE swGtimer(2)>0
                          IF baIlout()
                               EXIT
                          ENDIF
                          = hoRizmove(1)
                     ENDDO
                     = swDsytimer(2)
                     IF  .NOT. m.baIlout
                          DO WHILE swGtimer(1)>0
                               = hoRizmove(1)
                               IF stAll1()
                                    IF m.viEwit
                                         ACTIVATE WINDOW viEwwin
                                         ? 'stall detected'
                                    ENDIF
                                    EXIT
                               ENDIF
                          ENDDO
                     ENDIF
                     = swDsytimer(1)
                CASE m.chOice=8
                     = swCrttimer(1,(swSecond*m.hoRistall))
                     = swCrttimer(2,72)
                     DO WHILE swGtimer(2)>0
                          IF baIlout()
                               EXIT
                          ENDIF
                          = hoRizmove(2)
                     ENDDO
                     = swDsytimer(2)
                     IF  .NOT. m.baIlout
                          DO WHILE swGtimer(1)>0
                               = hoRizmove(2)
                               IF stAll1()
                                    IF m.viEwit
                                         ACTIVATE WINDOW viEwwin
                                         ? 'stall detected'
                                    ENDIF
                                    EXIT
                               ENDIF
                          ENDDO
                     ENDIF
                     = swDsytimer(1)
           ENDCASE
      OTHERWISE
           DO CASE
                CASE m.chOice=1
                     = seNd_scp('RELAY01OFF')
                     = seNd_scp('RELAY02ON')
                     = swWait(2)
                     = swCrttimer(1,(swSecond*m.frOnstall))
                     DO WHILE swGtimer(1)>0
                          IF baIlout()
                               EXIT
                          ENDIF
                          IF stAll(m.frUpstall)
                               EXIT
                          ENDIF
                     ENDDO
                     = swDsytimer(1)
                     = seNd_scp('RELAY01OFF')
                     = seNd_scp('RELAY02OFF')
                CASE m.chOice=2
                     = seNd_scp('RELAY01ON')
                     = seNd_scp('RELAY02OFF')
                     = swWait(2)
                     = swCrttimer(1,(swSecond*m.frOnstall))
                     DO WHILE swGtimer(1)>0
                          IF baIlout()
                               EXIT
                          ENDIF
                          IF stAll(m.frDnstall)
                               EXIT
                          ENDIF
                     ENDDO
                     = swDsytimer(1)
                     = seNd_scp('RELAY01OFF')
                     = seNd_scp('RELAY02OFF')
                CASE m.chOice=3
                     = seNd_scp('RELAY05ON')
                     = seNd_scp('RELAY06OFF')
                     = swWait(2)
                     = swCrttimer(1,(swSecond*m.baCkstall))
                     DO WHILE swGtimer(1)>0
                          IF baIlout()
                               EXIT
                          ENDIF
                          IF stAll(m.bkUpstall)
                               EXIT
                          ENDIF
                     ENDDO
                     = swDsytimer(1)
                     = seNd_scp('RELAY05OFF')
                     = seNd_scp('RELAY06OFF')
                CASE m.chOice=4
                     = seNd_scp('RELAY06ON')
                     = seNd_scp('RELAY05OFF')
                     = swWait(2)
                     = swCrttimer(1,(swSecond*m.baCkstall))
                     DO WHILE swGtimer(1)>0
                          IF baIlout()
                               EXIT
                          ENDIF
                          IF stAll(m.bkDnstall)
                               EXIT
                          ENDIF
                     ENDDO
                     = swDsytimer(1)
                     = seNd_scp('RELAY06OFF')
                     = seNd_scp('RELAY05OFF')
                CASE m.chOice=5
                     = seNd_scp('RELAY07ON')
                     = seNd_scp('RELAY08OFF')
                     = swWait(2)
                     = swCrttimer(1,(swSecond*m.reClstall))
                     DO WHILE swGtimer(1)>0
                          IF baIlout()
                               EXIT
                          ENDIF
                          IF stAll(m.reFwstall)
                               EXIT
                          ENDIF
                     ENDDO
                     = swDsytimer(1)
                     = seNd_scp('RELAY07OFF')
                     = seNd_scp('RELAY08OFF')
                CASE m.chOice=6
                     = seNd_scp('RELAY08ON')
                     = seNd_scp('RELAY07OFF')
                     = swWait(2)
                     = swCrttimer(1,(swSecond*m.reClstall))
                     DO WHILE swGtimer(1)>0
                          IF baIlout()
                               EXIT
                          ENDIF
                          IF stAll(m.reBkstall)
                               EXIT
                          ENDIF
                     ENDDO
                     = swDsytimer(1)
                     = seNd_scp('RELAY08OFF')
                     = seNd_scp('RELAY07OFF')
                CASE m.chOice=7
                     = seNd_scp('RELAY03ON')
                     = seNd_scp('RELAY04OFF')
                     = swWait(2)
                     = swCrttimer(1,(swSecond*m.hoRistall))
                     DO WHILE swGtimer(1)>0
                          IF baIlout()
                               EXIT
                          ENDIF
                          IF stAll(m.hoFwstall)
                               EXIT
                          ENDIF
                     ENDDO
                     = swDsytimer(1)
                     = seNd_scp('RELAY03OFF')
                     = seNd_scp('RELAY04OFF')
                CASE m.chOice=8
                     = seNd_scp('RELAY04ON')
                     = seNd_scp('RELAY03OFF')
                     = swWait(2)
                     = swCrttimer(1,(swSecond*m.hoRistall))
                     DO WHILE swGtimer(1)>0
                          IF baIlout()
                               EXIT
                          ENDIF
                          IF stAll(m.hoBkstall)
                               EXIT
                          ENDIF
                     ENDDO
                     = swDsytimer(1)
                     = seNd_scp('RELAY04OFF')
                     = seNd_scp('RELAY03OFF')
           ENDCASE
 ENDCASE
 RETURN
*
PROCEDURE _s9t1chgo6
 ON KEY LABEL X DO DoManual WITH LASTKEY()
 ON KEY LABEL R DO DoManual WITH LASTKEY()
 ON KEY LABEL A DO DoManual WITH LASTKEY()
 IF m.moDuletype<>'NONE' .AND. m.cfGqc
      ON KEY LABEL M DO DoManual WITH LASTKEY()
 ENDIF
 ON KEY LABEL C DO DoManual WITH LASTKEY()
 ON KEY LABEL B DO DoManual WITH LASTKEY()
 ON KEY LABEL H DO DoManual WITH LASTKEY()
 ON KEY LABEL F DO DoManual WITH LASTKEY()
 ON KEY LABEL Alt+V Do viewtog
 ON KEY LABEL ALT+L Do LargeTog
 IF poWerup()
      IF UPPER(ALLTRIM(m.moDuletype))='FN-74' .OR.  ;
         UPPER(ALLTRIM(m.moDuletype))='FN-145'
           WAIT WINDOW NOWAIT 'Sending Ignition off Message...'
           = seNd_scp('88')
           WAIT WINDOW TIMEOUT 0.05 'Sending PRNDL Park Message...'
           = seNd_scp('94')
           IF UPPER(ALLTRIM(m.moDuletype))='FN-74'
                WAIT WINDOW TIMEOUT 0.05 'Sending Driver Unidentified...'
                = seNd_scp('RECALL_S0')
           ENDIF
      ENDIF
 ELSE
      WAIT WINDOW NOWAIT 'Power Up Failure !'
      CLEAR READ
 ENDIF
*
PROCEDURE _s9t1chgo7
 PRIVATE cuRrwind
 STORE WOUTPUT() TO cuRrwind
 IF SYS(2016)='MANUAL' .OR. SYS(2016)='*'
      ACTIVATE WINDOW SAME maNual
      @ 6, 39 SAY IIF(m.moDuletype<>'NONE' .AND. m.cfGqc, 'M', '') SIZE 1,  ;
        1, 0 COLOR GR+/RB 
      @ 6, 40 SAY IIF(m.moDuletype<>'NONE' .AND. m.cfGqc, 'EMORY:', '')  ;
        SIZE 1, 13, 0
      @ 7, 40 SAY IIF(m.moDuletype='FN-74' .AND. m.cfGqc, IIF(m.meMstatus= ;
        'U', 'UNIDENTIFIED', IIF(m.meMstatus='O', 'OFF', IIF(m.meMstatus= ;
        '1', 'DRIVER 1', 'DRIVER 2'))), '') SIZE 1, 12, 0
 ENDIF
 IF  .NOT. EMPTY(cuRrwind)
      ACTIVATE WINDOW SAME (cuRrwind)
 ENDIF
*
***
*** PASSWORD.SPX
***
*
 PRIVATE m.cuRrarea, m.taLkstat, m.coMpstat
 IF SET('TALK')='ON'
      SET TALK OFF
      m.taLkstat = 'ON'
 ELSE
      m.taLkstat = 'OFF'
 ENDIF
 m.coMpstat = SET('COMPATIBLE')
 SET COMPATIBLE FOXPLUS
 IF  .NOT. WEXIST('password') .OR. UPPER(WTITLE('PASSWORD'))== ;
     'PASSWORD.PJX' .OR. UPPER(WTITLE('PASSWORD'))=='PASSWORD.SCX' .OR.  ;
     UPPER(WTITLE('PASSWORD'))=='PASSWORD.MNX' .OR.  ;
     UPPER(WTITLE('PASSWORD'))=='PASSWORD.PRG' .OR.  ;
     UPPER(WTITLE('PASSWORD'))=='PASSWORD.FRX' .OR.  ;
     UPPER(WTITLE('PASSWORD'))=='PASSWORD.QPR'
      DEFINE WINDOW paSsword FROM INT((SROWS()-5)/2), INT((SCOLS()-31)/2)  ;
             TO INT((SROWS()-5)/2)+4, INT((SCOLS()-31)/2)+30 NOFLOAT  ;
             NOCLOSE SHADOW TITLE 'PASSWORD' NOMINIMIZE COLOR SCHEME 1
 ENDIF
 PUSH KEY CLEAR
 SET ESCAPE OFF
 m.paSsword = ''
 m.paSsresult = .F.
 IF WVISIBLE('password')
      ACTIVATE WINDOW SAME paSsword
 ELSE
      ACTIVATE WINDOW NOSHOW paSsword
 ENDIF
 @ 1, 3 GET m.paSsword DEFAULT ' ' SIZE 1, 23 PICTURE '@K' VALID _s9t1chhtq()
 IF  .NOT. WVISIBLE('password')
      ACTIVATE WINDOW paSsword
 ENDIF
 READ
 RELEASE WINDOW paSsword
 IF m.taLkstat='ON'
      SET TALK ON
 ENDIF
 IF m.coMpstat='ON'
      SET COMPATIBLE DB4
 ENDIF
 POP KEY
*
PROCEDURE _s9t1chhtq
 IF UPPER(ALLTRIM(m.paSsword))==UPPER(ALLTRIM(STRTRAN(DTOC(DATE()), '/',  ;
    '')+m.d_Version))
      m.paSsresult = .T.
 ELSE
      m.paSsresult = .F.
 ENDIF
*
***
*** PORTINIT.FXP
***
*
*
FUNCTION poRtinit
 PARAMETER loPen
 PRIVATE cvArname
 m.cvArname = ''
 PRIVATE reSult
 m.reSult = .T.
 PRIVATE baUdvar, paRityvar, daTavar, stOpvar
 IF  .NOT. m.loPen
      = swClosecom(1,0)
      = swClosecom(0,0)
      = swDaltimer()
 ELSE
      cvArname = 'nP_Ret2'
      STORE SWOpenCom(1, 400, 1000, 0) TO &cVarName.
      IF &cVarName <> SWCSUCCESSFUL
           DO CASE
                case &cVarName=SWCNOINTSPECIFIED
                     ? 'No Interrupt Specified on COM2.'
                case &cVarName=SWCNOUARTPRESENT
                     ? 'No UART Present on COM2.'
                case &cVarName=SWCNOINTAVAILABLE
                     ? 'No Interrupt Available COM2.'
                case &cVarName=SWCNOMEMORY
                     ? 'No Memory on COM2.'
           ENDCASE
           m.reSult = .F.
      ELSE
           = swSetuart(1,9600,swParityev,7,1)
      ENDIF
      cvArname = 'nP_Ret1'
      STORE SWOpenCom(0, 100, 100, 0) TO &cVarName.
      IF &cVarName <> SWCSUCCESSFUL
           DO CASE
                case &cVarName=SWCNOINTSPECIFIED
                     ? 'No Interrupt Specified on COM1.'
                case &cVarName=SWCNOUARTPRESENT
                     ? 'No UART Present on COM1.'
                case &cVarName=SWCNOINTAVAILABLE
                     ? 'No Interrupt Available on COM1.'
                case &cVarName=SWCNOMEMORY
                     ? 'No Memory on COM1.'
           ENDCASE
           m.reSult = .F.
      ELSE
           = swSetuart(0,9600,swParityma,8,1)
      ENDIF
 ENDIF
 RETURN m.reSult
*
***
*** SCHUK99P.SPX
***
*
 PRIVATE m.cuRrarea, m.taLkstat, m.coMpstat
 IF SET('TALK')='ON'
      SET TALK OFF
      m.taLkstat = 'ON'
 ELSE
      m.taLkstat = 'OFF'
 ENDIF
 m.coMpstat = SET('COMPATIBLE')
 SET COMPATIBLE FOXPLUS
 IF  .NOT. WEXIST('schuk99prm') .OR. UPPER(WTITLE('SCHUK99PRM'))== ;
     'SCHUK99PRM.PJX' .OR. UPPER(WTITLE('SCHUK99PRM'))=='SCHUK99PRM.SCX'  ;
     .OR. UPPER(WTITLE('SCHUK99PRM'))=='SCHUK99PRM.MNX' .OR.  ;
     UPPER(WTITLE('SCHUK99PRM'))=='SCHUK99PRM.PRG' .OR.  ;
     UPPER(WTITLE('SCHUK99PRM'))=='SCHUK99PRM.FRX' .OR.  ;
     UPPER(WTITLE('SCHUK99PRM'))=='SCHUK99PRM.QPR'
      DEFINE WINDOW scHuk99prm FROM INT((SROWS()-18)/2), INT((SCOLS()-47)/ ;
             2) TO INT((SROWS()-18)/2)+17, INT((SCOLS()-47)/2)+46 NOFLOAT  ;
             NOCLOSE SHADOW TITLE 'Change 1999 UN93 Schukra Parameters'  ;
             NOMINIMIZE COLOR SCHEME 1
 ENDIF
 PUBLIC skRmax, skStcur, skInt, skOutt, skRel
 m.skRmax = m.skRunmax
 m.skStcur = m.skStallcur
 m.skInt = m.skIntime
 m.skOutt = m.skOuttime
 m.skRel = m.skRelease
 IF WVISIBLE('schuk99prm')
      ACTIVATE WINDOW SAME scHuk99prm
 ELSE
      ACTIVATE WINDOW NOSHOW scHuk99prm
 ENDIF
 @ 1, 37 SAY 'Amps' SIZE 1, 4, 0
 @ 4, 37 SAY 'Amps' SIZE 1, 4, 0
 @ 7, 37 SAY 'Seconds' SIZE 1, 7, 0
 @ 10, 37 SAY 'Seconds' SIZE 1, 7, 0
 @ 10, 1 SAY 'Maximum lumbar OUT cycle time:' SIZE 1, 30, 0
 @ 7, 1 SAY 'Maximum lumbar IN cycle time.:' SIZE 1, 30, 0
 @ 4, 1 SAY 'Stall current................:' SIZE 1, 30, 0
 @ 1, 1 SAY 'Maximum running current......:' SIZE 1, 30, 0
 @ 15, 12 GET m.chOice DEFAULT 1 SIZE 1, 8, 4 PICTURE  ;
   '@*HT \!\<Save;\<Cancel' VALID _s9t1chi33()
 @ 13, 37 SAY 'Seconds' SIZE 1, 7, 0
 @ 13, 1 SAY 'Maximum switch wait time.....:' SIZE 1, 30, 0
 @ 1, 32 GET m.skRunmax DEFAULT ' ' SIZE 1, 4 PICTURE '@!K'
 @ 4, 32 GET m.skStallcur DEFAULT ' ' SIZE 1, 4 PICTURE '@!K'
 @ 7, 32 GET m.skIntime DEFAULT ' ' SIZE 1, 4 PICTURE '@!K'
 @ 10, 32 GET m.skOuttime DEFAULT ' ' SIZE 1, 4 PICTURE '@!K'
 @ 13, 32 GET m.skRelease DEFAULT ' ' SIZE 1, 4 PICTURE '@!K'
 IF  .NOT. WVISIBLE('schuk99prm')
      ACTIVATE WINDOW scHuk99prm
 ENDIF
 READ CYCLE
 RELEASE WINDOW scHuk99prm
 IF m.taLkstat='ON'
      SET TALK ON
 ENDIF
 IF m.coMpstat='ON'
      SET COMPATIBLE DB4
 ENDIF
*
PROCEDURE _s9t1chi33
 IF m.chOice=2
      m.skRunmax = m.skRmax
      m.skStallcur = m.skStcur
      m.skIntime = m.skInt
      m.skOuttime = m.skOutt
      m.skRelease = m.skRel
 ELSE
      SAVE TO SCHUK99.MEM ALL LIKE SK*
 ENDIF
 RELEASE skRmax, skStcur, skInt, skOutt, skRel
*
***
*** SEATCHOI.SPX
***
*
 PRIVATE m.cuRrarea, m.taLkstat, m.coMpstat
 IF SET('TALK')='ON'
      SET TALK OFF
      m.taLkstat = 'ON'
 ELSE
      m.taLkstat = 'OFF'
 ENDIF
 m.coMpstat = SET('COMPATIBLE')
 SET COMPATIBLE FOXPLUS
 IF  .NOT. WEXIST('seatchoi') .OR. UPPER(WTITLE('SEATCHOI'))== ;
     'SEATCHOI.PJX' .OR. UPPER(WTITLE('SEATCHOI'))=='SEATCHOI.SCX' .OR.  ;
     UPPER(WTITLE('SEATCHOI'))=='SEATCHOI.MNX' .OR.  ;
     UPPER(WTITLE('SEATCHOI'))=='SEATCHOI.PRG' .OR.  ;
     UPPER(WTITLE('SEATCHOI'))=='SEATCHOI.FRX' .OR.  ;
     UPPER(WTITLE('SEATCHOI'))=='SEATCHOI.QPR'
      DEFINE WINDOW seAtchoi FROM INT((SROWS()-17)/2), INT((SCOLS()-80)/ ;
             2) TO INT((SROWS()-17)/2)+16, INT((SCOLS()-80)/2)+79 NOFLOAT  ;
             NOCLOSE SHADOW TITLE 'Select Seat to Be Tested' NOMINIMIZE  ;
             NONE COLOR SCHEME 9
 ENDIF
 PUSH KEY CLEAR
 USE NOUPDATE (m.cpArtnos) ALIAS paRts ORDER PARTNUM
 IF m.cfGdvrside=1
      SET FILTER TO paRts.siDe='D'
 ELSE
      SET FILTER TO paRts.siDe='P'
 ENDIF
 DEFINE POPUP _s9t1chi9x PROMPT FIELDS paRts.paRtnum+'-'+paRts.paRtdesc  ;
        MARK '' MARGIN SCROLL
 IF WVISIBLE('seatchoi')
      ACTIVATE WINDOW SAME seAtchoi
 ELSE
      ACTIVATE WINDOW NOSHOW seAtchoi
 ENDIF
 @ 1,0 GET m.TypeTested  PICTURE "@&T"  POPUP _s9t1chi9x  SIZE 16,80  DEFAULT " "  VALID _s9t1chiaa()  COLOR SCHEME 9
 @ 0, 24 SAY 'Select the seat to be tested...' SIZE 1, 31, 0 COLOR GR+/BG* 
 IF  .NOT. WVISIBLE('seatchoi')
      ACTIVATE WINDOW seAtchoi
 ENDIF
 READ VALID _s9t1chib2() CYCLE WHEN _s9t1chib3()
 RELEASE WINDOW seAtchoi
 RELEASE POPUP _s9t1chi9x
 IF m.taLkstat='ON'
      SET TALK ON
 ENDIF
 IF m.coMpstat='ON'
      SET COMPATIBLE DB4
 ENDIF
 USE IN paRts
 POP KEY
*
PROCEDURE _s9t1chiaa
 SELECT paRts
 SCATTER MEMVAR FIELDS paRtnum, paRtdesc, moDuletype, h_Version, s_Version
 SCATTER TO teSt_lvl FIELDS veRsion, frOnt, reAr, hoRizontal, reCline,  ;
         luMbar, heAt, diAgnostic, miRrors, raTeoftrav, seAtbelt,  ;
         seAtoccup, phOne, reClswitch, reClmanual, scHukra, p_Point,  ;
         heAtonbom, un93heat, scHukra99
 SCATTER MEMVAR FIELDS h_Time, f_Time, b_Time, r_Time
 SCATTER MEMVAR FIELDS h_Travel, f_Travel, b_Travel, r_Travel
 m.bcOdeinfo = m.paRtnum
*
FUNCTION _s9t1chib2
 IF m.cfGptr .AND. m.cfGtypeptr=1
      IF  .NOT. laBelstat()
           = swRingbell()
           RETURN .F.
      ENDIF
 ENDIF
*
PROCEDURE _s9t1chib3
 ON KEY LABEL Alt+X Do End_all
 ON KEY LABEL ESC Do Silly
 ON KEY LABEL ALT+M Do Config.spr
 ON KEY LABEL ALT+V Do Viewtog
 ON KEY LABEL ALT+L Do LargeTog
 ON KEY LABEL ALT+H Do ViewHistry
 ON KEY LABEL ALT+A Do About.spr
 ON KEY LABEL ALT+C Do ViewCodes
 ON KEY LABEL ALT+E Do ViewErrors
 ON KEY LABEL F1 Do DO_HELP
*
***
*** SETUP.FXP
***
*
 PUBLIC m.viEwit
 PUBLIC d_Appname
 PUBLIC d_Version
 PUBLIC d_Revdate
 PUBLIC daTe
 PUBLIC tiMe
 m.daTe = DATE()
 m.tiMe = TIME()
 PUBLIC m.cyClenos
 m.cyClenos = 1
 PUBLIC teSter_id
 m.teSter_id = 'PROTOTYPE'
 PUBLIC inStance
 m.inStance = 1
 PUBLIC teSt_type
 m.teSt_type = 1
 PUBLIC teSt_time
 m.teSt_time = 0
 PUBLIC shIp_time
 m.shIp_time = 0
 PUBLIC bcOdeinfo
 m.bcOdeinfo = ''
 PUBLIC reSult
 m.reSult = .T.
 PUBLIC erRor_code
 m.erRor_code = ''
 PUBLIC coMment
 m.coMment = ''
 PUBLIC soUrce
 m.soUrce = 'fd'
 PUBLIC teMparray[ 11]
 STORE '' TO teMparray
 PUBLIC ouTarray[ 11]
 STORE 0 TO ouTarray
 PUBLIC rxMessage[ 100]
 STORE 0 TO rxMessage
 PUBLIC teSt_lvl[ 20]
 teSt_lvl[ 1] = .T.
 teSt_lvl[ 2] = .F.
 teSt_lvl[ 3] = .F.
 teSt_lvl[ 4] = .F.
 teSt_lvl[ 5] = .F.
 teSt_lvl[ 6] = .F.
 teSt_lvl[ 7] = .F.
 teSt_lvl[ 8] = .F.
 teSt_lvl[ 9] = .F.
 teSt_lvl[ 10] = .F.
 teSt_lvl[ 11] = .F.
 teSt_lvl[ 12] = .F.
 teSt_lvl[ 13] = .F.
 teSt_lvl[ 14] = .F.
 teSt_lvl[ 15] = .F.
 teSt_lvl[ 16] = .F.
 teSt_lvl[ 17] = .F.
 teSt_lvl[ 18] = .F.
 teSt_lvl[ 19] = .F.
 teSt_lvl[ 20] = .F.
 PUBLIC reSp_lvl[ 20, 2]
 reSp_lvl[ 1, 1] = .F.
 reSp_lvl[ 2, 1] = .F.
 reSp_lvl[ 3, 1] = .F.
 reSp_lvl[ 4, 1] = .F.
 reSp_lvl[ 5, 1] = .F.
 reSp_lvl[ 6, 1] = .F.
 reSp_lvl[ 7, 1] = .F.
 reSp_lvl[ 8, 1] = .F.
 reSp_lvl[ 9, 1] = .F.
 reSp_lvl[ 10, 1] = .F.
 reSp_lvl[ 11, 1] = .F.
 reSp_lvl[ 12, 1] = .F.
 reSp_lvl[ 13, 1] = .F.
 reSp_lvl[ 14, 1] = .F.
 reSp_lvl[ 15, 1] = .F.
 reSp_lvl[ 16, 1] = .F.
 reSp_lvl[ 17, 1] = .F.
 reSp_lvl[ 18, 1] = .F.
 reSp_lvl[ 19, 1] = .F.
 reSp_lvl[ 20, 1] = .F.
 reSp_lvl[ 1, 2] = ''
 reSp_lvl[ 2, 2] = ''
 reSp_lvl[ 3, 2] = ''
 reSp_lvl[ 4, 2] = ''
 reSp_lvl[ 5, 2] = ''
 reSp_lvl[ 6, 2] = ''
 reSp_lvl[ 7, 2] = ''
 reSp_lvl[ 8, 2] = ''
 reSp_lvl[ 9, 2] = ''
 reSp_lvl[ 10, 2] = ''
 reSp_lvl[ 11, 2] = ''
 reSp_lvl[ 12, 2] = ''
 reSp_lvl[ 13, 2] = ''
 reSp_lvl[ 14, 2] = ''
 reSp_lvl[ 15, 2] = ''
 reSp_lvl[ 16, 2] = ''
 reSp_lvl[ 17, 2] = ''
 reSp_lvl[ 18, 2] = ''
 reSp_lvl[ 19, 2] = ''
 reSp_lvl[ 20, 2] = ''
 PUBLIC lvL1rslt
 PUBLIC lvL2rslt
 PUBLIC lvL3rslt
 PUBLIC lvL4rslt
 PUBLIC lvL5rslt
 PUBLIC lvL6rslt
 PUBLIC lvL7rslt
 PUBLIC lvL8rslt
 PUBLIC lvL9rslt
 PUBLIC lvL10rslt
 PUBLIC lvL11rslt
 PUBLIC lvL12rslt
 PUBLIC lvL13rslt
 PUBLIC lvL14rslt
 PUBLIC lvL15rslt
 PUBLIC lvL16rslt
 PUBLIC lvL17rslt
 PUBLIC lvL18rslt
 PUBLIC lvL19rslt
 PUBLIC lvL20rslt
 PUBLIC peNding
 m.peNding = .T.
 PUBLIC svErsion, smOnth, sdAy, syEar
 m.svErsion = 0
 m.smOnth = 0
 m.sdAy = 0
 m.syEar = 0
 PUBLIC hvErsion, hmOnth, hdAy, hyEar
 m.hvErsion = 0
 m.hmOnth = 0
 m.hdAy = 0
 m.hyEar = 0
 PUBLIC tyPetested
 m.tyPetested = 1
 PUBLIC teStchosen
 m.teStchosen = 1
 PUBLIC cfGdvrside
 m.cfGdvrside = 1
 PUBLIC cfGbarcode
 m.cfGbarcode = .F.
 PUBLIC cfGautoonl
 m.cfGautoonl = .F.
 PUBLIC cfGid
 m.cfGid = 'PROTOTYPE'
 PUBLIC cfGptr
 m.cfGptr = .T.
 PUBLIC cfGtesttyp
 PUBLIC cfGshtimer
 m.cfGshortte = .T.
 PUBLIC cfGtypeptr
 m.cfGtypeptr = 1
 PUBLIC cfGlabelsi
 m.cfGlabelsi = 1
 PUBLIC cfGcell
 m.cfGcell = ''
 PUBLIC cfGhshippo
 PUBLIC cfGfshippo
 PUBLIC cfGbshippo
 PUBLIC cfGrshippo
 m.cfGhshippo = 1
 m.cfGfshippo = 1
 m.cfGbshippo = 1
 m.cfGrshippo = 1
 m.cfGhtime = 3.8
 m.cfGftime = 1
 m.cfGbtime = 0
 m.cfGrtime = 0
 PUBLIC cfGbagpmpt, cfGmanpmpt
 m.cfGbagpmpt = .F.
 m.cfGmanpmpt = .F.
 PUBLIC cfGqc
 m.cfGqc = .F.
 PUBLIC cfG2wylumb
 m.cfG2wylumb = .F.
 PUBLIC h_Time
 PUBLIC f_Time
 PUBLIC b_Time
 PUBLIC r_Time
 m.h_Time = 3.8
 m.f_Time = 1
 m.b_Time = 0
 m.r_Time = 0
 PUBLIC h_Travel
 PUBLIC f_Travel
 PUBLIC b_Travel
 PUBLIC r_Travel
 m.h_Travel = 254.0
 m.f_Travel = 38.0
 m.b_Travel = 40.0
 m.r_Travel = 39
 PUBLIC paRtnum
 PUBLIC paRtdesc
 PUBLIC moDuletype
 PUBLIC h_Version
 PUBLIC s_Version
 PUBLIC dr_testset
 PUBLIC pa_testset
 m.paRtnum = ''
 m.paRtdesc = ''
 m.moDuletype = ''
 m.h_Version = 0
 m.s_Version = 0
 m.dr_testset = 0
 m.pa_testset = 0
 PUBLIC r_Pt
 PUBLIC r_Dest
 PUBLIC r_Source
 PUBLIC r_Byte1
 PUBLIC r_Byte2
 PUBLIC r_Byte3
 PUBLIC r_Byte4
 PUBLIC r_Byte5
 PUBLIC r_Byte6
 PUBLIC r_Byte7
 PUBLIC r_Ndbs
 m.r_Pt = 0
 m.r_Dest = 0
 m.r_Source = 0
 m.r_Byte1 = 0
 m.r_Byte2 = 0
 m.r_Byte3 = 0
 m.r_Byte4 = 0
 m.r_Byte5 = 0
 m.r_Byte6 = 0
 m.r_Byte7 = 0
 m.r_Ndbs = 0
 PUBLIC heAt1, heAt2, heAt3, heAtoff, un93htlow, un93hthigh, un93httime,  ;
        un93swtime
 PUBLIC caBletype, un93cable, un93htrlay, un93igrlay, un93sprlay
 m.heAt1 = 1.75
 m.heAt2 = 3.75
 m.heAt3 = 6.50
 m.heAtoff = 0.75
 PUBLIC skRunmax, skStallcur, skIntime, skOuttime, skRelease
 RESTORE FROM SCHUK99.mem ADDITIVE
 PUBLIC vfRuncur, vfStallcur, vfMintime, vfMaxtime
 PUBLIC vrRuncur, vrStallcur, vrMintime, vrMaxtime
 RESTORE FROM VERT.MEM ADDITIVE
 PUBLIC luMbardrop, luMbarrun, luMbarstal, inFlatetim
 m.luMbardrop = 1.5
 m.inFlatetim = 20
 m.luMbarrun = 0.05
 m.luMbarstal = 4.0
 PUBLIC beLttime
 m.beLttime = 30
 PUBLIC shIptime
 m.shIptime = 20
 PUBLIC stEptime
 m.stEptime = 5
 PUBLIC frUp_run
 PUBLIC frDn_run
 PUBLIC bkUp_run
 PUBLIC bkDn_run
 PUBLIC reFw_run
 PUBLIC reBk_run
 PUBLIC hoFw_run
 PUBLIC hoBk_run
 m.frUp_run = 1
 m.frDn_run = 1
 m.bkUp_run = 0.5
 m.bkDn_run = 0.5
 m.reFw_run = 0.30
 m.reBk_run = 0.30
 m.hoFw_run = 1
 m.hoBk_run = 1
 PUBLIC frUpstall
 PUBLIC frDnstall
 PUBLIC bkUpstall
 PUBLIC bkDnstall
 PUBLIC reFwstall
 PUBLIC reBkstall
 PUBLIC hoFwstall
 PUBLIC hoBkstall
 m.frUpstall = 7.0
 m.frDnstall = 7.0
 m.bkUpstall = 7.0
 m.bkDnstall = 7.0
 m.reFwstall = 4.0
 m.reBkstall = 4.0
 m.hoFwstall = 7.5
 m.hoBkstall = 7.5
 PUBLIC frOnstall, baCkstall, reClstall, hoRistall
 m.frOnstall = 10
 m.baCkstall = 10
 m.reClstall = 24
 m.hoRistall = 25
 PUBLIC auTotest
 m.auTotest = .F.
 m.viEwit = .F.
 DEFINE WINDOW viEwwin FROM 5, 47 TO 23, 77 GROW SHADOW TITLE 'Test Readings'
 PUBLIC m.poInt1
 PUBLIC m.poInt2
 PUBLIC m.poInt3
 PUBLIC m.poInt4
 m.poInt1 = .F.
 m.poInt2 = .F.
 m.poInt3 = .F.
 m.poInt4 = .F.
 PUBLIC m.cuRrvidmod
 DEFINE WINDOW coVerwin FROM 0, 0 TO 24, 79 NONE COLOR N 
 PUBLIC meMstatus
 m.meMstatus = 'U'
 PUBLIC roT_hf, tiMe_hf
 PUBLIC roT_hr, tiMe_hr
 PUBLIC roT_fu, tiMe_fu
 PUBLIC roT_fd, tiMe_fd
 PUBLIC roT_bu, tiMe_bu
 PUBLIC roT_bd, tiMe_bd
 PUBLIC roT_rf, tiMe_rf
 PUBLIC roT_rr, tiMe_rr
 m.roT_hf = 0.0
 m.roT_hr = 0.0
 m.roT_fu = 0.0
 m.roT_fd = 0.0
 m.roT_bu = 0.0
 m.roT_bd = 0.0
 m.roT_rf = 0.0
 m.roT_rr = 0.0
 m.tiMe_hf = 0.0
 m.tiMe_hr = 0.0
 m.tiMe_fu = 0.0
 m.tiMe_fd = 0.0
 m.tiMe_bu = 0.0
 m.tiMe_bd = 0.0
 m.tiMe_rf = 0.0
 m.tiMe_rr = 0.0
 PUBLIC laRge
 m.laRge = .T.
 PUBLIC op_recldn
 PUBLIC op_reclup
 PUBLIC op_reclrel
 PUBLIC op_lout
 PUBLIC op_lin
 PUBLIC op_lup
 PUBLIC op_ldn
 PUBLIC op_lrel
 PUBLIC op_bagfwd
 PUBLIC op_bagrel
 PUBLIC op_sbout
 PUBLIC op_sbin
 PUBLIC op_cushpr
 PUBLIC op_cushrel
 PUBLIC op_reclshp
 m.op_recldn = 30
 m.op_reclup = 30
 m.op_reclrel = 30
 m.op_lout = 30
 m.op_lin = 30
 m.op_lup = 30
 m.op_ldn = 30
 m.op_lrel = 30
 m.op_bagfwd = 30
 m.op_bagrel = 30
 m.op_sbout = 30
 m.op_sbin = 30
 m.op_cushpr = 30
 m.op_cushrel = 30
 m.op_reclshp = 30
 PUBLIC paSsresult
 m.paSsresult = .F.
 PUBLIC baIlout
 m.baIlout = .F.
 PUBLIC atOdfactor
 m.atOdfactor = 0.392
*
***
*** SHORTIME.SPX
***
*
 PRIVATE m.cuRrarea, m.taLkstat, m.coMpstat
 IF SET('TALK')='ON'
      SET TALK OFF
      m.taLkstat = 'ON'
 ELSE
      m.taLkstat = 'OFF'
 ENDIF
 m.coMpstat = SET('COMPATIBLE')
 SET COMPATIBLE FOXPLUS
 IF  .NOT. WEXIST('shortime') .OR. UPPER(WTITLE('SHORTIME'))== ;
     'SHORTIME.PJX' .OR. UPPER(WTITLE('SHORTIME'))=='SHORTIME.SCX' .OR.  ;
     UPPER(WTITLE('SHORTIME'))=='SHORTIME.MNX' .OR.  ;
     UPPER(WTITLE('SHORTIME'))=='SHORTIME.PRG' .OR.  ;
     UPPER(WTITLE('SHORTIME'))=='SHORTIME.FRX' .OR.  ;
     UPPER(WTITLE('SHORTIME'))=='SHORTIME.QPR'
      DEFINE WINDOW shOrtime FROM INT((SROWS()-13)/2), INT((SCOLS()-63)/ ;
             2) TO INT((SROWS()-13)/2)+12, INT((SCOLS()-63)/2)+62 NOFLOAT  ;
             NOCLOSE SHADOW TITLE 'Test Timing Setup' NOMINIMIZE COLOR SCHEME 1
 ENDIF
 PRIVATE olDshtime
 PRIVATE olDwait
 olDshtime = m.cfGshtime
 olDwait = m.cfGshwait
 IF WVISIBLE('shortime')
      ACTIVATE WINDOW SAME shOrtime
 ELSE
      ACTIVATE WINDOW NOSHOW shOrtime
 ENDIF
 @ 1, 2 SAY 'Short test - button cycle timing' SIZE 1, 32, 0
 @ 6, 2 SAY 'This is the number of seconds the operators will hold the'  ;
   SIZE 1, 57, 0 COLOR R+/B 
 @ 7, 2 SAY 'Front down, Rear down, and Horizontal back buttons during'  ;
   SIZE 1, 57, 0 COLOR R+/B 
 @ 8, 2 SAY 'the SHORT test cycle.' SIZE 1, 21, 0 COLOR R+/B 
 @ 1, 44 GET m.cfGshtime DEFAULT 0 SIZE 1, 10 PICTURE '@K'
 @ 3, 44 GET m.cfGshwait DEFAULT ' ' SIZE 1, 10 PICTURE '@K'
 @ 10, 21 GET m.btNshort DEFAULT 1 SIZE 1, 8, 1 PICTURE  ;
   '@*HT \!\<Ok;\<Cancel' VALID _s9t1chil9()
 @ 3, 2 SAY 'Time to wait for operator to cycle button' SIZE 1, 41, 0
 IF  .NOT. WVISIBLE('shortime')
      ACTIVATE WINDOW shOrtime
 ENDIF
 READ CYCLE
 RELEASE WINDOW shOrtime
 IF m.taLkstat='ON'
      SET TALK ON
 ENDIF
 IF m.coMpstat='ON'
      SET COMPATIBLE DB4
 ENDIF
 RELEASE ALL LIKE oldshtime
 RELEASE ALL LIKE oldwait
 RETURN
*
PROCEDURE _s9t1chil9
 m.ccOnfigure = m.csEtuppath+'tester.mem'
 IF m.btNshort=1
      SAVE TO (ccOnfigure) ALL LIKE CFG*
 ELSE
      m.cfGshtime = m.olDshtime
      m.cfGshwait = m.olDwait
 ENDIF
*
***
*** SLVRFOX.FXP
***
*
 SET TALK OFF
 PUBLIC swTrue, swFalse, swSecond
 swTrue = .T.
 swFalse = .F.
 swSecond = 18
 PUBLIC coM1, coM2, coM3, coM4, coM5, coM6, coM7, coM8
 PUBLIC coM9, coM10, coM11, coM12, coM13, coM14, coM15, coM16
 PUBLIC coM17, coM18, coM19, coM20, coM21, coM22, coM23, coM24
 PUBLIC coM25, coM26, coM27, coM28, coM29, coM30, coM31, coM32
 PUBLIC coM33, coM34
 coM1 = 0
 coM2 = 1
 coM3 = 2
 coM4 = 3
 coM5 = 4
 coM6 = 5
 coM7 = 6
 coM8 = 7
 coM9 = 8
 coM10 = 9
 coM11 = 10
 coM12 = 11
 coM13 = 12
 coM14 = 13
 coM15 = 14
 coM16 = 15
 coM17 = 16
 coM18 = 17
 coM19 = 18
 coM20 = 19
 coM21 = 20
 coM22 = 21
 coM23 = 22
 coM24 = 23
 coM25 = 24
 coM26 = 25
 coM27 = 26
 coM28 = 27
 coM29 = 28
 coM30 = 29
 coM31 = 30
 coM32 = 31
 coM33 = 32
 coM34 = 33
 PUBLIC irQ2, irQ3, irQ4, irQ5, irQ6, irQ7
 irQ2 = 2
 irQ3 = 3
 irQ4 = 4
 irQ5 = 5
 irQ6 = 6
 irQ7 = 7
 PUBLIC irQ8, irQ9, irQ10, irQ11, irQ12, irQ13, irQ14, irQ15
 PUBLIC coM1baseio, coM2baseio
 irQ8 = 8
 irQ9 = 9
 irQ10 = 10
 irQ11 = 11
 irQ12 = 12
 irQ13 = 13
 irQ14 = 14
 irQ15 = 15
 coM1baseio = 1016
 coM2baseio = 760
 PUBLIC coM3baseio, coM4baseio, coM5baseio, coM6baseio, coM7baseio, coM8baseio
 coM3baseio = 12832
 coM4baseio = 12840
 coM5baseio = 16928
 coM6baseio = 16936
 coM7baseio = 21024
 coM8baseio = 21032
 PUBLIC swNoasdtr, swNoasrts, swCuseint1
 swNoasdtr = 1
 swNoasrts = 2
 swCuseint1 = 4
 swNouartfi = 8
 swEnableua = 16
 PUBLIC swAsdtr, swAsrts, swDeasdtr, swDeasrts, swNofree, swNorestor
 swAsdtr = 1
 swAsrts = 2
 swDeasdtr = 4
 swDeasrts = 8
 swNofree = 16
 swNorestor = 32
 PUBLIC swCsuccess, swCinvalid, swCqueueis, swCqueueis
 PUBLIC swCinvalid, swCnouartp, swCnointav, swCnointsp
 PUBLIC swCnomemor, swCtimedou, swCabort, swCnotfoun, swCnocarri
 PUBLIC swCunablet, swCbadbloc, swCnoremot
 PUBLIC swClocalab, swCremotea, swCbadbloc, swCblockfr
 PUBLIC swCreceive, swCeotdete, swCmaxleng
 PUBLIC swCtermina, swCqueuewe, swCfeature
 PUBLIC swCfilewri, swCfileclo, swCfileexi, swCfilesee
 PUBLIC swCzmexnew, swCzmdatel, swCzmnewfi, swCzmfiles
 PUBLIC swCzmbadhe, swCzmbades, swCzmgarbl
 swCsuccess = 0
 swCinvalid = -500
 swCqueueis = -499
 swCqueueis = -498
 swCinvalid = -497
 swCnouartp = -496
 swCnointav = -495
 swCnointsp = -494
 swCnomemor = -493
 swCtimedou = -492
 swCabort = -491
 swCnotfoun = -490
 swCnocarri = -489
 swCunablet = -488
 swCbadbloc = -487
 swCnoremot = -486
 swClocalab = -485
 swCremotea = -484
 swCbadbloc = -483
 swCblockfr = -482
 swCreceive = -481
 swCeotdete = -480
 swCmaxleng = -479
 swCtermina = -478
 swCqueuewe = -477
 swCfeature = -476
 swCfilewri = -475
 swCfileclo = -474
 swCfileexi = -473
 swCfilesee = -472
 swCzmexnew = -471
 swCzmdatel = -470
 swCzmnewfi = -469
 swCzmfiles = -468
 swCzmbadhe = -467
 swCzmbades = -466
 swCzmgarbl = -465
 PUBLIC swParityno, swParityod, swParityev, swParityst, swParityms
 PUBLIC swParityma, swParitysp
 swParityno = 0
 swParityod = 8
 swParityev = 24
 swParityst = 40
 swParityms = 56
 swParityma = 40
 swParitysp = 56
 PUBLIC txWforxon, txWforcts, txWfordsr, txWforcarr, txWformanu
 txWforxon = 1
 txWforcts = 2
 txWfordsr = 4
 txWforcarr = 8
 txWformanu = 16
 PUBLIC xoNxoffise, rtSctsisen, dtRdsrisen, caRrdetise
 xoNxoffise = 1
 rtSctsisen = 2
 dtRdsrisen = 4
 caRrdetise = 8
 PUBLIC swCsmoff, swCsmon, swCsmmodep, swCsmmodet
 swCsmoff = '0'
 swCsmon = '1'
 swCsmmodep = 0
 swCsmmodet = 1
 PUBLIC swBlack, swBlue, swGreen, swCyan, swRed, swMagenta, swBrown
 PUBLIC swWhite, swBlink, swIntense
 swBlack = 0
 swBlue = 1
 swGreen = 2
 swCyan = 3
 swRed = 4
 swMagenta = 5
 swBrown = 6
 swWhite = 7
 swBlink = 128
 swIntense = 8
 PUBLIC swPosreg0, swPosreg1, swPosreg2, swPosreg3, swPosreg4
 PUBLIC swPosreg5, swPosreg6, swPosreg7, swPosminch, swPosmaxch
 swPosreg0 = 0
 swPosreg1 = 1
 swPosreg2 = 2
 swPosreg3 = 3
 swPosreg4 = 4
 swPosreg5 = 5
 swPosreg6 = 6
 swPosreg7 = 7
 swPosminch = 0
 swPosmaxch = 7
 PUBLIC swPosibmdu
 swPosibmdu = 61183
 PUBLIC swPos16dig, swPos8digi, swPos4digi
 swPos16dig = 28644
 swPos8digi = 28645
 swPos4digi = 28646
 RETURN
*
***
*** SPROGRAM.FXP
***
*
 SET TALK OFF
 SET DELETED ON
 SET CONFIRM OFF
 SET SAFETY OFF
 SET ESCAPE OFF
 SET EXCLUSIVE OFF
 SET BELL OFF
 SET EXACT ON
 RELEASE ALL
 CLOSE ALL
 CLEAR ALL
 CLEAR MACROS
 CLEAR MEMO
 CLEAR MENU
 CLEAR POPUPS
 RELEASE WINDOW
 ON KEY
 SET REFRESH TO 30
 SET REPROCESS TO 5 SECONDS
*
***
*** TESTCHOI.SPX
***
*
 PRIVATE m.cuRrarea, m.taLkstat, m.coMpstat
 IF SET('TALK')='ON'
      SET TALK OFF
      m.taLkstat = 'ON'
 ELSE
      m.taLkstat = 'OFF'
 ENDIF
 m.coMpstat = SET('COMPATIBLE')
 SET COMPATIBLE FOXPLUS
 IF  .NOT. WEXIST('testchoi') .OR. UPPER(WTITLE('TESTCHOI'))== ;
     'TESTCHOI.PJX' .OR. UPPER(WTITLE('TESTCHOI'))=='TESTCHOI.SCX' .OR.  ;
     UPPER(WTITLE('TESTCHOI'))=='TESTCHOI.MNX' .OR.  ;
     UPPER(WTITLE('TESTCHOI'))=='TESTCHOI.PRG' .OR.  ;
     UPPER(WTITLE('TESTCHOI'))=='TESTCHOI.FRX' .OR.  ;
     UPPER(WTITLE('TESTCHOI'))=='TESTCHOI.QPR'
      DEFINE WINDOW teStchoi FROM 4, 43 TO 11, 76 NOFLOAT NOCLOSE SHADOW  ;
             TITLE 'Select the test to run' NOMINIMIZE NONE COLOR SCHEME 9
 ENDIF
 PUSH KEY CLEAR
 PUBLIC teSttypes[ 5]
 teSttypes[ 1] = 'Perform AUTO Test'
 teSttypes[ 2] = 'Perform MANUAL Seat Movement'
 teSttypes[ 3] = 'Perform BOX CYCLE Movement'
 teSttypes[ 4] = 'Move Seat to SHIPPING POSITION'
 teSttypes[ 5] = 'Choose Another SEAT TYPE'
 IF WVISIBLE('testchoi')
      ACTIVATE WINDOW SAME teStchoi
 ELSE
      ACTIVATE WINDOW NOSHOW teStchoi
 ENDIF
 @ 1,0 GET m.TestChosen  PICTURE "@&T"  FROM TestTypes  SIZE 7,34  DEFAULT 1  COLOR SCHEME 9
 @ 0, 1 SAY 'Select the Action to take...' SIZE 1, 28, 0 COLOR GR+/BG* 
 IF  .NOT. WVISIBLE('testchoi')
      ACTIVATE WINDOW teStchoi
 ENDIF
 READ CYCLE WHEN _s9t1chix5()
 RELEASE WINDOW teStchoi
 IF m.taLkstat='ON'
      SET TALK ON
 ENDIF
 IF m.coMpstat='ON'
      SET COMPATIBLE DB4
 ENDIF
 POP KEY
 RELEASE teSttypes
*
PROCEDURE _s9t1chix5
 ON KEY LABEL Alt+X Do End_All
 ON KEY LABEL ESC Do Silly
 ON KEY LABEL ALT+V Do Viewtog
 ON KEY LABEL ALT+L Do LargeTog
 ON KEY LABEL F1 HELP
*
***
*** TIMING.SPX
***
*
 PRIVATE m.cuRrarea, m.taLkstat, m.coMpstat
 IF SET('TALK')='ON'
      SET TALK OFF
      m.taLkstat = 'ON'
 ELSE
      m.taLkstat = 'OFF'
 ENDIF
 m.coMpstat = SET('COMPATIBLE')
 SET COMPATIBLE FOXPLUS
 IF  .NOT. WEXIST('timing') .OR. UPPER(WTITLE('TIMING'))=='TIMING.PJX'  ;
     .OR. UPPER(WTITLE('TIMING'))=='TIMING.SCX' .OR.  ;
     UPPER(WTITLE('TIMING'))=='TIMING.MNX' .OR. UPPER(WTITLE('TIMING'))== ;
     'TIMING.PRG' .OR. UPPER(WTITLE('TIMING'))=='TIMING.FRX' .OR.  ;
     UPPER(WTITLE('TIMING'))=='TIMING.QPR'
      DEFINE WINDOW tiMing FROM INT((SROWS()-25)/2), INT((SCOLS()-80)/2)  ;
             TO INT((SROWS()-25)/2)+24, INT((SCOLS()-80)/2)+79 NOFLOAT  ;
             NOCLOSE SHADOW TITLE  ;
             ' FN-74/FN-116/FN-145/PN-102 Operator Timing Setup '  ;
             NOMINIMIZE COLOR SCHEME 1
 ENDIF
 PUSH KEY CLEAR
 IF WVISIBLE('timing')
      ACTIVATE WINDOW SAME tiMing
 ELSE
      ACTIVATE WINDOW NOSHOW tiMing
 ENDIF
 @ 6, 14 SAY 'Move Recline to Shipping Position:' SIZE 1, 34, 0 COLOR W/B 
 @ 15, 14 SAY 'Seat Belt Insert.................:' SIZE 1, 34, 0 COLOR W/B 
 @ 14, 14 SAY 'Seat Belt Remove.................:' SIZE 1, 34, 0 COLOR W/B 
 @ 3, 52 SAY 'seconds' SIZE 1, 7, 0 COLOR W/B 
 @ 4, 52 SAY 'seconds' SIZE 1, 7, 0 COLOR W/B 
 @ 5, 52 SAY 'seconds' SIZE 1, 7, 0 COLOR W/B 
 @ 6, 52 SAY 'seconds' SIZE 1, 7, 0 COLOR W/B 
 @ 7, 52 SAY 'seconds' SIZE 1, 7, 0 COLOR W/B 
 @ 8, 52 SAY 'seconds' SIZE 1, 7, 0 COLOR W/B 
 @ 9, 52 SAY 'seconds' SIZE 1, 7, 0 COLOR W/B 
 @ 10, 52 SAY 'seconds' SIZE 1, 7, 0 COLOR W/B 
 @ 11, 52 SAY 'seconds' SIZE 1, 7, 0 COLOR W/B 
 @ 12, 52 SAY 'seconds' SIZE 1, 7, 0 COLOR W/B 
 @ 13, 52 SAY 'seconds' SIZE 1, 7, 0 COLOR W/B 
 @ 14, 52 SAY 'seconds' SIZE 1, 7, 0 COLOR W/B 
 @ 15, 52 SAY 'seconds' SIZE 1, 7, 0 COLOR W/B 
 @ 16, 52 SAY 'seconds' SIZE 1, 7, 0 COLOR W/B 
 @ 17, 52 SAY 'seconds' SIZE 1, 7, 0 COLOR W/B 
 @ 7, 14 SAY 'Schukra Lumbar Out...............:' SIZE 1, 34, 0 COLOR W/B 
 @ 8, 14 SAY 'Schukra Lumbar In................:' SIZE 1, 34, 0 COLOR W/B 
 @ 9, 14 SAY 'Schukra Lumbar Up................:' SIZE 1, 34, 0 COLOR W/B 
 @ 10, 14 SAY 'Schukra Lumbar Down..............:' SIZE 1, 34, 0 COLOR W/B 
 @ 11, 14 SAY 'Schukra Lumbar Release...........:' SIZE 1, 34, 0 COLOR W/B 
 @ 3, 14 SAY 'Recline Switch Down..............:' SIZE 1, 34, 0 COLOR W/B 
 @ 4, 14 SAY 'Recline Switch Up................:' SIZE 1, 34, 0 COLOR W/B 
 @ 5, 14 SAY 'Recline Switch Release...........:' SIZE 1, 34, 0 COLOR W/B 
 @ 12, 14 SAY 'Lumbar Bag Switch Forward........:' SIZE 1, 34, 0 COLOR W/B 
 @ 13, 14 SAY 'Lumbar Bag Switch Release........:' SIZE 1, 34, 0 COLOR W/B 
 @ 16, 14 SAY 'Driver Seat Occupied Pressed.....:' SIZE 1, 34, 0 COLOR W/B 
 @ 17, 14 SAY 'Driver Seat Occupied Released....:' SIZE 1, 34, 0 COLOR W/B 
 @ 1, 8 SAY 'for the operator to react when prompted by the program.'  ;
   SIZE 1, 55, 0
 @ 0, 8 SAY 'This screen allows adjustment of the amount of time allowed'  ;
   SIZE 1, 59, 0
 @ 18, 52 SAY 'seconds' SIZE 1, 7, 0 COLOR W/B 
 @ 19, 52 SAY 'seconds' SIZE 1, 7, 0 COLOR W/B 
 @ 20, 52 SAY 'seconds' SIZE 1, 7, 0 COLOR W/B 
 @ 20, 14 SAY 'Mustang Lumbar Release...........:' SIZE 1, 34, 0 COLOR W/B 
 @ 18, 14 SAY 'Mustang Lumbar In................:' SIZE 1, 34, 0 COLOR W/B 
 @ 19, 14 SAY 'Mustang Lumbar Out...............:' SIZE 1, 34, 0 COLOR W/B 
 @ 3, 49 GET m.op_recldn DEFAULT 0 SIZE 1, 2 RANGE 0 PICTURE '@K 99'
 @ 4, 49 GET m.op_reclup DEFAULT 0 SIZE 1, 2 RANGE 0 PICTURE '@K 99'
 @ 5, 49 GET m.op_reclrel DEFAULT 0 SIZE 1, 2 RANGE 0 PICTURE '@K 99'
 @ 6, 49 GET m.op_reclshp DEFAULT 0 SIZE 1, 2 RANGE 0 PICTURE '@K 99'
 @ 7, 49 GET m.op_lout DEFAULT 0 SIZE 1, 2 RANGE 0 PICTURE '@K 99'
 @ 8, 49 GET m.op_lin DEFAULT 0 SIZE 1, 2 RANGE 0 PICTURE '@K 99'
 @ 9, 49 GET m.op_lup DEFAULT 0 SIZE 1, 2 RANGE 0 PICTURE '@K 99'
 @ 10, 49 GET m.op_ldn DEFAULT 0 SIZE 1, 2 RANGE 0 PICTURE '@K 99'
 @ 11, 49 GET m.op_lrel DEFAULT 0 SIZE 1, 2 RANGE 0 PICTURE '@K 99'
 @ 12, 49 GET m.op_bagfwd DEFAULT 0 SIZE 1, 2 RANGE 0 PICTURE '@K 99'
 @ 13, 49 GET m.op_bagrel DEFAULT 0 SIZE 1, 2 RANGE 0 PICTURE '@K 99'
 @ 14, 49 GET m.op_sbout DEFAULT 0 SIZE 1, 2 RANGE 0 PICTURE '@K 99'
 @ 15, 49 GET m.op_sbin DEFAULT 0 SIZE 1, 2 RANGE 0 PICTURE '@K 99'
 @ 16, 49 GET m.op_cushpr DEFAULT 0 SIZE 1, 2 RANGE 0 PICTURE '@K 99'
 @ 17, 49 GET m.op_cushrel DEFAULT 0 SIZE 1, 2 RANGE 0 PICTURE '@K 99'
 @ 18, 49 GET op_mlin DEFAULT 0 SIZE 1, 2 RANGE 0 PICTURE '@K 99'
 @ 19, 49 GET op_mlout DEFAULT 0 SIZE 1, 2 RANGE 0 PICTURE '@K 99'
 @ 20, 49 GET op_mlrel DEFAULT 0 SIZE 1, 2 RANGE 0 PICTURE '@K 99'
 @ 22, 22 GET m.chOice DEFAULT 1 SIZE 1, 10, 10 PICTURE  ;
   '@*HT \!\<Save;\<Cancel' VALID _s9t1chj70()
 IF  .NOT. WVISIBLE('timing')
      ACTIVATE WINDOW tiMing
 ENDIF
 READ CYCLE WHEN _s9t1chj7k()
 RELEASE WINDOW tiMing
 IF m.taLkstat='ON'
      SET TALK ON
 ENDIF
 IF m.coMpstat='ON'
      SET COMPATIBLE DB4
 ENDIF
 POP KEY
*
PROCEDURE _s9t1chj70
 m.ccOnfigure = m.csEtuppath+'Timing.mem'
 IF m.chOice=1
      SAVE TO (ccOnfigure) ALL LIKE Op_*
 ELSE
      RESTORE FROM (ccOnfigure) ADDITIVE
 ENDIF
*
PROCEDURE _s9t1chj7k
 ON KEY LABEL ESC DO Silly
*
***
*** UN93PARM.SPX
***
*
 PRIVATE m.cuRrarea, m.taLkstat, m.coMpstat
 IF SET('TALK')='ON'
      SET TALK OFF
      m.taLkstat = 'ON'
 ELSE
      m.taLkstat = 'OFF'
 ENDIF
 m.coMpstat = SET('COMPATIBLE')
 SET COMPATIBLE FOXPLUS
 IF  .NOT. WEXIST('un93parms') .OR. UPPER(WTITLE('UN93PARMS'))== ;
     'UN93PARMS.PJX' .OR. UPPER(WTITLE('UN93PARMS'))=='UN93PARMS.SCX'  ;
     .OR. UPPER(WTITLE('UN93PARMS'))=='UN93PARMS.MNX' .OR.  ;
     UPPER(WTITLE('UN93PARMS'))=='UN93PARMS.PRG' .OR.  ;
     UPPER(WTITLE('UN93PARMS'))=='UN93PARMS.FRX' .OR.  ;
     UPPER(WTITLE('UN93PARMS'))=='UN93PARMS.QPR'
      DEFINE WINDOW un93parms FROM INT((SROWS()-14)/2), INT((SCOLS()-74)/ ;
             2) TO INT((SROWS()-14)/2)+13, INT((SCOLS()-74)/2)+73 NOFLOAT  ;
             NOCLOSE SHADOW TITLE 'Modify UN93 Settings' NOMINIMIZE COLOR  ;
             SCHEME 1
 ENDIF
 IF WVISIBLE('un93parms')
      ACTIVATE WINDOW SAME un93parms
 ELSE
      ACTIVATE WINDOW NOSHOW un93parms
 ENDIF
 @ 2, 4 SAY 'Minimum allowed current draw when heat is on' SIZE 1, 44, 0
 @ 4, 4 SAY 'Maximum allowed current draw when heat is on' SIZE 1, 44, 0
 @ 8, 4 SAY 'Time to wait for heat test to be completed' SIZE 1, 42, 0
 @ 6, 4 SAY 'Maximum time to wait for switch to be cycled  ' SIZE 1, 46, 0
 @ 2, 50 GET un93htlow DEFAULT ' ' SIZE 1, 4 PICTURE '@K'
 @ 4, 50 GET un93hthigh DEFAULT ' ' SIZE 1, 4 PICTURE '@K'
 @ 6, 50 GET un93swtime DEFAULT 0 SIZE 1, 4 PICTURE '@K'
 @ 8, 50 GET un93httime DEFAULT ' ' SIZE 1, 4 RANGE 5.0,99.9 PICTURE '@K'
 @ 10, 26 GET btNokcance DEFAULT 1 SIZE 1, 8, 5 PICTURE  ;
   '@*HT \!\<Ok;\?\<Cancel' VALID _s9t1chjev()
 IF  .NOT. WVISIBLE('un93parms')
      ACTIVATE WINDOW un93parms
 ENDIF
 READ CYCLE
 RELEASE WINDOW un93parms
 IF m.taLkstat='ON'
      SET TALK ON
 ENDIF
 IF m.coMpstat='ON'
      SET COMPATIBLE DB4
 ENDIF
*
PROCEDURE _s9t1chjev
 m.ccOnfigure = m.csEtuppath+'cfgUn93.mem'
 IF btNokcance=1
      SET SAFETY OFF
      SAVE TO (ccOnfigure) ALL LIKE UN93*
 ELSE
      RESTORE FROM (ccOnfigure) ADDITIVE
 ENDIF
 SHOW GETS
*
***
*** VERTPARM.SPX
***
*
 PRIVATE m.cuRrarea, m.taLkstat, m.coMpstat
 IF SET('TALK')='ON'
      SET TALK OFF
      m.taLkstat = 'ON'
 ELSE
      m.taLkstat = 'OFF'
 ENDIF
 m.coMpstat = SET('COMPATIBLE')
 SET COMPATIBLE FOXPLUS
 IF  .NOT. WEXIST('vertparm') .OR. UPPER(WTITLE('VERTPARM'))== ;
     'VERTPARM.PJX' .OR. UPPER(WTITLE('VERTPARM'))=='VERTPARM.SCX' .OR.  ;
     UPPER(WTITLE('VERTPARM'))=='VERTPARM.MNX' .OR.  ;
     UPPER(WTITLE('VERTPARM'))=='VERTPARM.PRG' .OR.  ;
     UPPER(WTITLE('VERTPARM'))=='VERTPARM.FRX' .OR.  ;
     UPPER(WTITLE('VERTPARM'))=='VERTPARM.QPR'
      DEFINE WINDOW veRtparm FROM INT((SROWS()-16)/2), INT((SCOLS()-45)/ ;
             2) TO INT((SROWS()-16)/2)+15, INT((SCOLS()-45)/2)+44 NOFLOAT  ;
             NOCLOSE SHADOW TITLE 'Modify FRT/RR Motor Settings'  ;
             NOMINIMIZE COLOR SCHEME 1
 ENDIF
 IF WVISIBLE('vertparm')
      ACTIVATE WINDOW SAME veRtparm
 ELSE
      ACTIVATE WINDOW NOSHOW veRtparm
 ENDIF
 @ 2, 4 SAY 'Running current draw (amperes)' SIZE 1, 30, 0
 @ 3, 4 SAY 'Stall current draw' SIZE 1, 18, 0
 @ 4, 4 SAY 'Minimum run time' SIZE 1, 16, 0
 @ 5, 4 SAY 'Maximum run time' SIZE 1, 16, 0
 @ 1, 2 TO 6, 40
 @ 8, 4 SAY 'Running current draw (amperes)' SIZE 1, 30, 0
 @ 9, 4 SAY 'Stall current draw' SIZE 1, 18, 0
 @ 10, 4 SAY 'Minimum run time' SIZE 1, 16, 0
 @ 11, 4 SAY 'Maximum run time' SIZE 1, 16, 0
 @ 7, 2 TO 12, 40
 @ 1, 10 SAY 'Front vertical motor' SIZE 1, 20, 0
 @ 7, 10 SAY 'Rear vertical motor' SIZE 1, 19, 0
 @ 0, 15 SAY 'M U S T A N G' SIZE 1, 13, 0
 @ 2, 35 GET m.vfRuncur DEFAULT 0 SIZE 1, 4 PICTURE '@K'
 @ 3, 35 GET m.vfStallcur DEFAULT 0 SIZE 1, 4 PICTURE '@K'
 @ 4, 35 GET m.vfMintime DEFAULT 0 SIZE 1, 4 PICTURE '@K'
 @ 5, 35 GET m.vfMaxtime DEFAULT 0 SIZE 1, 4 PICTURE '@K'
 @ 8, 35 GET m.vrRuncur DEFAULT 0 SIZE 1, 4 PICTURE '@K'
 @ 9, 35 GET m.vrStallcur DEFAULT 0 SIZE 1, 4 PICTURE '@K'
 @ 10, 35 GET m.vrMintime DEFAULT 0 SIZE 1, 4 PICTURE '@K'
 @ 11, 35 GET m.vrMaxtime DEFAULT 0 SIZE 1, 4 RANGE 5.0,99.9 PICTURE '@K'
 @ 13, 11 GET btNokcance DEFAULT 1 SIZE 1, 8, 5 PICTURE  ;
   '@*HT \!\<Ok;\<Cancel' VALID _s9t1chjm8()
 IF  .NOT. WVISIBLE('vertparm')
      ACTIVATE WINDOW veRtparm
 ENDIF
 READ CYCLE
 RELEASE WINDOW veRtparm
 IF m.taLkstat='ON'
      SET TALK ON
 ENDIF
 IF m.coMpstat='ON'
      SET COMPATIBLE DB4
 ENDIF
*
PROCEDURE _s9t1chjm8
 IF btNokcance=1
      SET SAFETY OFF
      SAVE TO c:\seattest\vert.mem ALL LIKE V*
 ELSE
      RESTORE FROM c:\seattest\vert.mem ADDITIVE
 ENDIF
 SHOW GETS
*
***
*** ABOUT.SPX
***
*
 PRIVATE m.cuRrarea, m.taLkstat, m.coMpstat
 IF SET('TALK')='ON'
      SET TALK OFF
      m.taLkstat = 'ON'
 ELSE
      m.taLkstat = 'OFF'
 ENDIF
 m.coMpstat = SET('COMPATIBLE')
 SET COMPATIBLE FOXPLUS
 IF  .NOT. WEXIST('about') .OR. UPPER(WTITLE('ABOUT'))=='ABOUT.PJX' .OR.  ;
     UPPER(WTITLE('ABOUT'))=='ABOUT.SCX' .OR. UPPER(WTITLE('ABOUT'))== ;
     'ABOUT.MNX' .OR. UPPER(WTITLE('ABOUT'))=='ABOUT.PRG' .OR.  ;
     UPPER(WTITLE('ABOUT'))=='ABOUT.FRX' .OR. UPPER(WTITLE('ABOUT'))== ;
     'ABOUT.QPR'
      DEFINE WINDOW abOut FROM INT((SROWS()-14)/2), INT((SCOLS()-65)/2)  ;
             TO INT((SROWS()-14)/2)+13, INT((SCOLS()-65)/2)+64 NOFLOAT  ;
             NOCLOSE SHADOW TITLE ' ABOUT THE SYSTEM ' NOMINIMIZE DOUBLE  ;
             COLOR SCHEME 1
 ENDIF
 IF WVISIBLE('about')
      ACTIVATE WINDOW SAME abOut
 ELSE
      ACTIVATE WINDOW NOSHOW abOut
 ENDIF
 @ 10, 29 GET ln_ok DEFAULT 1 SIZE 1, 4, 1 PICTURE '@*HT \!\<OK'
 @ 3, 25 SAY 'Version' SIZE 1, 7, 0
 @ 3, 33 SAY m.d_Version SIZE 1, 13
 @ 5, 23 SAY m.d_Revdate SIZE 1, 18 PICTURE '@TI'
 @ 1, 17 SAY m.d_Appname SIZE 1, 31 PICTURE '@I'
 @ 7, 20 SAY '(c) 1994,95,96 Motorola' SIZE 1, 23, 0
 @ 8, 14 SAY 'Portions (c) 1997, 1998, 1999 TTI, L.L.P.' SIZE 1, 41, 0
 IF  .NOT. WVISIBLE('about')
      ACTIVATE WINDOW abOut
 ENDIF
 READ TIMEOUT 3 CYCLE SHOW _s9t1chjsm() ACTIVATE _s9t1chjsl()
 RELEASE WINDOW abOut
 IF m.taLkstat='ON'
      SET TALK ON
 ENDIF
 IF m.coMpstat='ON'
      SET COMPATIBLE DB4
 ENDIF
*
PROCEDURE _s9t1chjsl
 SHOW GETS
*
PROCEDURE _s9t1chjsm
 PRIVATE cuRrwind
 STORE WOUTPUT() TO cuRrwind
 IF SYS(2016)='ABOUT' .OR. SYS(2016)='*'
      ACTIVATE WINDOW SAME abOut
      @ 3, 33 SAY m.d_Version SIZE 1, 13, 0
      @ 5, 23 SAY m.d_Revdate SIZE 1, 18, 0 PICTURE '@TI'
      @ 1, 17 SAY m.d_Appname SIZE 1, 31, 0 PICTURE '@I'
 ENDIF
 IF  .NOT. EMPTY(cuRrwind)
      ACTIVATE WINDOW SAME (cuRrwind)
 ENDIF
*
***
*** SEATTEST.FXP
***
*
*** 
*** ReFox 8.25  #Ï¦I7Ö%+ç  Ronald D. Redmer  180 Engelwood Suite J   
***
 DO sprogram.fxp
 SET CURSOR OFF
 WAIT WINDOW NOWAIT 'One moment please...'
 SET SYSMENU OFF
 CLEAR
 DO setup.fxp
 DO slvrfox.fxp
 SET LIBRARY TO slvrfox.plb
 m.cuRrvidmod = swSetvideo(-1)
 DO poRtinit WITH .T.
 = swFlushtx(coM1)
 = swFlushtx(coM2)
 SET LIBRARY TO iso_fox.plb ADDITIVE
 = seTspeed(1016,11)
 SET LIBRARY TO dspa_fox.plb ADDITIVE
 IF inItdspa(1)<>0
      WAIT CLEAR
      CLEAR
      ? 'DSPA Card failed to initialize!'
      ? '-------------------------------'
      ? 'The tester needs repair in order to perform testing properly.'
      ?
      ? 'Press any key to continue...'
      = swRingbell()
      = INKEY(0)
      QUIT
 ENDIF
 IF adDsource(m.soUrce)<>0
      WAIT CLEAR
      CLEAR
      ? 'DSPA Card failed while trying to add Source Address!'
      ? '----------------------------------------------------'
      ? 'The tester needs repair in order to perform testing properly.'
      ?
      ? 'Press any key to continue....'
      = swRingbell()
      = INKEY(0)
      QUIT
 ENDIF
 IF adDfrm(m.soUrce)<>0
      WAIT CLEAR
      CLEAR
      ? 'DSPA Card failed while trying to add Function Read Message!'
      ? '-----------------------------------------------------------'
      ? 'The tester needs repair in order to perform testing properly.'
      ?
      ? 'Press any key to continue....'
      = swRingbell()
      = INKEY(0)
      QUIT
 ENDIF
 = seTfilter()
 DO filename.fxp
 IF m.cfGtypeptr=1
      = swSetuart(1,9600,swParityev,7,1)
 ELSE
      = swSetuart(1,9600,swParityno,8,1)
 ENDIF
 m.d_Appname = 'Seat Tester Long/Short Test'
 m.d_Version = 'V6.02'
 m.d_Revdate = 'November 04, 1999'
 WAIT WINDOW NOWAIT 'Opening Databases...'
 SELECT 0
 USE NOUPDATE (m.cdTc) ALIAS dtC_file ORDER DTC
 SELECT 0
 USE NOUPDATE (m.csCp_mess) ALIAS scP_mess ORDER MESSAGENO
 CREATE CURSOR errorlist (erRcode C (4), erRdesc C (80))
 SELECT erRorlist
 INDEX ON erRorlist.erRcode TAG erRcode ASCENDING
 WAIT CLEAR
 DO about.spr
 DO WHILE .T.
      = swDaltimer()
      DO MAIN_SCR.SPR
 ENDDO
*
FUNCTION chK_port
 PARAMETER poRt, waIttime
 IF TYPE('m.WaitTime')<>'N'
      m.waIttime = 1
 ENDIF
 PRIVATE cbUf, i, nsWret
 PUSH KEY CLEAR
 SET CURSOR OFF
 DIMENSION cbUf[ 11]
 m.cbUf = ''
 m.i = 0
 nsWret = swCrttimer(1,(swSecond*m.waIttime))
 DO WHILE swGtimer(1)>0
      IF baIlout()
           WAIT WINDOW NOWAIT 'Transmission Aborted !'
           cbUf = 'ABORT'
           EXIT
      ENDIF
      IF  .NOT. swRxempty(m.poRt)
           m.cbUf = m.cbUf+CHR(swRxchar(m.poRt))
      ENDIF
 ENDDO
 IF EMPTY(cbUf) .AND.  .NOT. m.baIlout
      WAIT WINDOW TIMEOUT 2 'Response Not Received !'
 ENDIF
 WAIT CLEAR
 SET CURSOR ON
 = swDsytimer(1)
 POP KEY
 RETURN cbUf
*
PROCEDURE un93hton
 = seNd_scp(un93htrlay-'ON')
 = seNd_scp(un93igrlay-'ON')
 RETURN
*
PROCEDURE un93htoff
 = seNd_scp(un93htrlay-'OFF')
 = seNd_scp(un93igrlay-'OFF')
 RETURN
*
FUNCTION baIlout
 PRIVATE nkEy
 PRIVATE rvAl
 m.nkEy = INKEY()
 DO CASE
      CASE m.nkEy=27
           WAIT WINDOW NOWAIT 'Aborted!'
           m.baIlout = .T.
           rvAl = .T.
      CASE m.nkEy=46
           WAIT WINDOW NOWAIT 'Aborted!'
           m.nkEy = INKEY()
           WAIT WINDOW NOWAIT 'Aborted!'
           m.baIlout = .T.
           rvAl = .T.
      CASE m.nkEy=4
           m.baIlout = .T.
           rvAl = .T.
      CASE m.nkEy=5
           m.baIlout = .T.
           rvAl = .T.
      CASE m.nkEy=19
           m.baIlout = .T.
           rvAl = .T.
      CASE m.nkEy=24
           m.baIlout = .T.
           rvAl = .T.
      OTHERWISE
           rvAl = .F.
 ENDCASE
 RETURN rvAl
*
FUNCTION diSperror
 PARAMETER whIch
 PRIVATE frOmrow, frOmcol, toRow, toCol, chOice
 PUSH KEY CLEAR
 = swRingbell()
 IF m.whIch<>0
      SET CURSOR OFF
      IF  .NOT. WEXIST('alertwin')
           frOmrow = INT((SROWS()-6)/2)
           frOmcol = INT((SCOLS()-54)/2)
           toRow = frOmrow+6
           toCol = frOmcol+54
           DEFINE WINDOW alErtwin FROM frOmrow, frOmcol TO toRow, toCol  ;
                  NOGROW FLOAT NOCLOSE NOZOOM SHADOW DOUBLE COLOR SCHEME 7
      ENDIF
      ACTIVATE WINDOW alErtwin
      CLEAR
      DO CASE
           CASE m.whIch=1
                @ 1, 0 SAY PADC('Error 1 !', WCOLS())
           CASE m.whIch=2
                @ 1, 0 SAY PADC('Error 2 !', WCOLS())
           CASE m.whIch=3
                @ 1, 0 SAY PADC('Error 3 !', WCOLS())
           CASE m.whIch=4
                @ 1, 0 SAY PADC('Error 4 !', WCOLS())
           CASE m.whIch=5
                @ 1, 0 SAY PADC('Error 5 !', WCOLS())
           CASE m.whIch=6
                @ 1, 0 SAY PADC('Error 6 !', WCOLS())
           CASE m.whIch=7
                @ 1, 0 SAY PADC('Error 7 !', WCOLS())
           CASE m.whIch=8
                @ 1, 0 SAY PADC('Error 8 !', WCOLS())
           CASE m.whIch=9
                @ 1, 0 SAY PADC('Error 9 !', WCOLS())
           CASE m.whIch=10
                @ 1, 0 SAY PADC('Bar Code Scan Error !', WCOLS())
                @ 3, 10 SAY 'Enter Item Number:'
                IF m.csEqenable
                     @ 3, 29 GET m.baR_buf SIZE 1, 14 PICTURE  ;
                       '@KXXXXXXXXXXXXXX'
                ELSE
                     @ 3, 29 GET m.baR_buf SIZE 1, 10 PICTURE '@KXXXXXXXXXX'
                ENDIF
                ON KEY LABEL ENTER CLEAR READ
                SET CURSOR ON
                READ CYCLE
                DEACTIVATE WINDOW alErtwin
                POP KEY
                IF LASTKEY()=27 .OR. EMPTY(m.baR_buf)
                     RETURN .T.
                ELSE
                     RETURN .F.
                ENDIF
           OTHERWISE
                @ 1, 0 SAY PADC('Unknown Error !', WCOLS())
      ENDCASE
      STORE 1 TO chOice
      @ 3, INT((WCOLS()-23)/2) GET m.chOice SIZE 1, 10, 3 FUNCTION  ;
        '*H \<Abort;\!\?\<Continue'
      READ CYCLE MODAL
      SET CURSOR ON
      DEACTIVATE WINDOW alErtwin
      IF m.chOice=1
           POP KEY
           RETURN .T.
      ENDIF
 ENDIF
 POP KEY
 RETURN .F.
*
PROCEDURE do_help
 PUSH KEY CLEAR
 HELP
 POP KEY
 RETURN
*
PROCEDURE enD_all
 WAIT WINDOW NOWAIT 'Bye !'
 = poWerdown()
 = swDaltimer()
 DO poRtinit WITH .F.
 DO eprogram.fxp
 IF ISBLANK(SYS(9))
      QUIT
 ELSE
      CANCEL
 ENDIF
 RETURN
*
PROCEDURE siLly
 RETURN
*
FUNCTION poWerup
 WAIT WINDOW NOWAIT 'Applying Power...'
 DO WHILE (geTscp()=-129)
 ENDDO
 IF seNd_scp('RELAY14ON') .AND.  .NOT. baIlout()
      = swWait(4)
      DO WHILE (geTscp()=-129)
      ENDDO
      IF seNd_scp('PORT02IN')
           IF geTscp()=0
                IF swBitand(m.r_Byte3,8)=0
                     = poWerdown()
                     IF m.auTotest
                          = adD_err('0001')
                     ENDIF
                     RETURN .F.
                ENDIF
           ELSE
                = poWerdown()
                IF m.auTotest
                     = adD_err('0007')
                ENDIF
                RETURN .F.
           ENDIF
      ELSE
           = poWerdown()
           IF m.auTotest
                = adD_err('0007')
           ENDIF
           RETURN .F.
      ENDIF
 ELSE
      = poWerdown()
      IF m.auTotest .AND.  .NOT. m.baIlout
           = adD_err('0007')
      ELSE
           IF m.baIlout
                = adD_err('0000')
           ENDIF
      ENDIF
      RETURN .F.
 ENDIF
 IF seNd_scp('RELAY13ON') .AND.  .NOT. baIlout()
      = swWait(4)
      DO WHILE (geTscp()=-129)
      ENDDO
      IF seNd_scp('PORT02IN')
           IF geTscp()=0
                IF swBitand(m.r_Byte3,4)=0
                     = poWerdown()
                     IF m.auTotest
                          = adD_err('0002')
                     ENDIF
                     RETURN .F.
                ENDIF
           ELSE
                = poWerdown()
                IF m.auTotest
                     = adD_err('0007')
                ENDIF
                RETURN .F.
           ENDIF
      ELSE
           = poWerdown()
           IF m.auTotest
                = adD_err('0007')
           ENDIF
           RETURN .F.
      ENDIF
 ELSE
      = poWerdown()
      IF m.auTotest .AND.  .NOT. m.baIlout
           = adD_err('0007')
      ELSE
           IF m.baIlout
                = adD_err('0000')
           ENDIF
      ENDIF
      RETURN .F.
 ENDIF
 IF seNd_scp('RELAY12ON') .AND.  .NOT. baIlout()
      = swWait(4)
      DO WHILE (geTscp()=-129)
      ENDDO
      IF seNd_scp('PORT02IN')
           IF geTscp()=0
                IF swBitand(m.r_Byte3,2)=0
                     = poWerdown()
                     IF m.auTotest
                          = adD_err('0003')
                     ENDIF
                     RETURN .F.
                ENDIF
           ELSE
                = poWerdown()
                IF m.auTotest
                     = adD_err('0007')
                ENDIF
                RETURN .F.
           ENDIF
      ELSE
           = poWerdown()
           IF m.auTotest
                = adD_err('0007')
           ENDIF
           RETURN .F.
      ENDIF
 ELSE
      = poWerdown()
      IF m.auTotest .AND.  .NOT. m.baIlout
           = adD_err('0007')
      ELSE
           IF m.baIlout
                = adD_err('0000')
           ENDIF
      ENDIF
      RETURN .F.
 ENDIF
 IF seNd_scp('RELAY11ON') .AND.  .NOT. baIlout()
      = swWait(4)
      DO WHILE (geTscp()=-129)
      ENDDO
      IF seNd_scp('PORT02IN')
           IF geTscp()=0
                IF swBitand(m.r_Byte3,1)=0
                     = poWerdown()
                     IF m.auTotest
                          = adD_err('0004')
                     ENDIF
                     RETURN .F.
                ENDIF
           ELSE
                = poWerdown()
                IF m.auTotest
                     = adD_err('0007')
                ENDIF
                RETURN .F.
           ENDIF
      ELSE
           = poWerdown()
           IF m.auTotest
                = adD_err('0007')
           ENDIF
           RETURN .F.
      ENDIF
 ELSE
      = poWerdown()
      IF m.auTotest .AND.  .NOT. m.baIlout
           = adD_err('0007')
      ELSE
           IF m.baIlout
                = adD_err('0000')
           ENDIF
      ENDIF
      RETURN .F.
 ENDIF
 DO CASE
      CASE UPPER(ALLTRIM(m.moDuletype))='FN-74'
           = seNd_scp('i_am_a_74')
      CASE UPPER(ALLTRIM(m.moDuletype))='FN-145'
           = seNd_scp('i_am_a_145')
 ENDCASE
 WAIT CLEAR
 RETURN .T.
*
PROCEDURE poWerdown
 WAIT WINDOW NOWAIT 'Removing power...'
 = seNd_scp('RELAYOFFP0')
 = seNd_scp('RELAYOFFP1')
 DO WHILE geTscp()=0
 ENDDO
 WAIT CLEAR
 RETURN
*
PROCEDURE meMset
 PARAMETER chOice
 WAIT WINDOW NOWAIT 'Memory Set '+ALLTRIM(STR(m.chOice))
 IF UPPER(ALLTRIM(m.moDuletype))<>'FN-74' .AND.  ;
    UPPER(ALLTRIM(m.moDuletype))<>'FN-145'
      = seNd_iso('D1')
      = seNd_scp('OUT01ON')
      = swWait(4)
      = seNd_scp('OUT01OFF')
      DO CASE
           CASE m.chOice=1
                = seNd_scp('OUT02ON')
                = swWait(4)
                = seNd_scp('OUT02OFF')
           CASE m.chOice=2
                = seNd_scp('OUT03ON')
                = swWait(4)
                = seNd_scp('OUT03OFF')
           CASE m.chOice=3
                = seNd_scp('OUT02ON')
                = seNd_scp('OUT03ON')
                = swWait(4)
                = seNd_scp('OUT02OFF')
                = seNd_scp('OUT03OFF')
      ENDCASE
 ELSE
      DO CASE
           CASE m.chOice=1
                = seNd_scp('SET_1')
                m.meMstatus = '1'
           CASE m.chOice=2
                = seNd_scp('SET_2')
                m.meMstatus = '2'
           CASE m.chOice=3
                = seNd_scp('SET_3')
                m.meMstatus = '3'
      ENDCASE
 ENDIF
 RETURN
*
PROCEDURE meMrecall
 PARAMETER chOice
 WAIT WINDOW NOWAIT 'Memory Recall '+ALLTRIM(STR(m.chOice))
 IF UPPER(ALLTRIM(m.moDuletype))<>'FN-74' .AND.  ;
    UPPER(ALLTRIM(m.moDuletype))<>'FN-145'
      = seNd_iso('D1')
      DO CASE
           CASE m.chOice=1
                = seNd_scp('OUT02ON')
                = swWait(4)
                = seNd_scp('OUT02OFF')
                m.meMstatus = '1'
           CASE m.chOice=2
                = seNd_scp('OUT03ON')
                = swWait(4)
                = seNd_scp('OUT03OFF')
                m.meMstatus = '2'
           CASE m.chOice=3
                = seNd_scp('OUT02ON')
                = seNd_scp('OUT03ON')
                = swWait(4)
                = seNd_scp('OUT02OFF')
                = seNd_scp('OUT03OFF')
                m.meMstatus = '3'
      ENDCASE
 ELSE
      DO CASE
           CASE m.chOice=1
                = seNd_scp('RECALL_C1')
                IF UPPER(ALLTRIM(m.moDuletype))='FN-74'
                     = seNd_scp('RECALL_S1')
                ENDIF
                m.meMstatus = '1'
           CASE m.chOice=2
                = seNd_scp('RECALL_C2')
                IF UPPER(ALLTRIM(m.moDuletype))='FN-74'
                     = seNd_scp('RECALL_S2')
                ENDIF
                m.meMstatus = '2'
           CASE m.chOice=3
                = seNd_scp('RECALL_C3')
                IF UPPER(ALLTRIM(m.moDuletype))='FN-74'
                     = seNd_scp('RECALL_S3')
                ENDIF
                m.meMstatus = '3'
      ENDCASE
 ENDIF
 SHOW GETS
 RETURN
*
PROCEDURE frOntmove
 PARAMETER chOice
 DO CASE
      CASE UPPER(ALLTRIM(m.moDuletype))='FN-74'
           DO CASE
                CASE m.chOice=1
                     = seNdscp('61','c8',2,'85220000000000')
                CASE m.chOice=2
                     = seNdscp('61','c8',2,'86220000000000')
           ENDCASE
      CASE UPPER(ALLTRIM(m.moDuletype))='FN-145'
           DO CASE
                CASE m.chOice=1
                     = seNdscp('61','c8',2,'85220000000000')
                CASE m.chOice=2
                     = seNdscp('61','c8',2,'86220000000000')
           ENDCASE
      CASE UPPER(ALLTRIM(m.moDuletype))='FN-116'
           DO CASE
                CASE m.chOice=1
                     = seNd_iso('59')
                CASE m.chOice=2
                     = seNd_iso('57')
           ENDCASE
 ENDCASE
 RETURN
*
PROCEDURE reClmove
 PARAMETER chOice
 DO CASE
      CASE UPPER(ALLTRIM(m.moDuletype))='FN-74'
           DO CASE
                CASE m.chOice=1
                     = seNdscp('61','c8',2,'89220000000000')
                CASE m.chOice=2
                     = seNdscp('61','c8',2,'8a220000000000')
           ENDCASE
      CASE UPPER(ALLTRIM(m.moDuletype))='FN-145'
           DO CASE
                CASE m.chOice=1
                     = seNdscp('61','c8',2,'89220000000000')
                CASE m.chOice=2
                     = seNdscp('61','c8',2,'8a220000000000')
           ENDCASE
      CASE UPPER(ALLTRIM(m.moDuletype))='FN-116'
           DO CASE
                CASE m.chOice=1
                     = seNd_iso('69')
                CASE m.chOice=2
                     = seNd_iso('68')
           ENDCASE
 ENDCASE
 RETURN
*
PROCEDURE baCkmove
 PARAMETER chOice
 DO CASE
      CASE UPPER(ALLTRIM(m.moDuletype))='FN-74'
           DO CASE
                CASE m.chOice=1
                     = seNdscp('61','c8',2,'87220000000000')
                CASE m.chOice=2
                     = seNdscp('61','c8',2,'88220000000000')
           ENDCASE
      CASE UPPER(ALLTRIM(m.moDuletype))='FN-145'
           DO CASE
                CASE m.chOice=1
                     = seNdscp('61','c8',2,'87220000000000')
                CASE m.chOice=2
                     = seNdscp('61','c8',2,'88220000000000')
           ENDCASE
      CASE UPPER(ALLTRIM(m.moDuletype))='FN-116'
           DO CASE
                CASE m.chOice=1
                     = seNd_iso('66')
                CASE m.chOice=2
                     = seNd_iso('64')
           ENDCASE
 ENDCASE
 RETURN
*
PROCEDURE hoRizmove
 PARAMETER chOice
 DO CASE
      CASE UPPER(ALLTRIM(m.moDuletype))='FN-74'
           DO CASE
                CASE m.chOice=1
                     = seNdscp('61','c8',2,'81220000000000')
                CASE m.chOice=2
                     = seNdscp('61','c8',2,'82220000000000')
           ENDCASE
      CASE UPPER(ALLTRIM(m.moDuletype))='FN-145'
           DO CASE
                CASE m.chOice=1
                     = seNdscp('61','c8',2,'81220000000000')
                CASE m.chOice=2
                     = seNdscp('61','c8',2,'82220000000000')
           ENDCASE
      CASE UPPER(ALLTRIM(m.moDuletype))='FN-116'
           DO CASE
                CASE m.chOice=1
                     = seNd_iso('55')
                CASE m.chOice=2
                     = seNd_iso('67')
           ENDCASE
 ENDCASE
 RETURN
*
PROCEDURE baCkheat
 PARAMETER chOice
 DO CASE
      CASE m.chOice=1
           WAIT WINDOW NOWAIT 'Seatback Heat ON'
           = seNd_scp('RELAY09ON')
      CASE m.chOice=2
           WAIT WINDOW NOWAIT 'Seatback Heat OFF'
           = seNd_scp('RELAY09OFF')
 ENDCASE
 RETURN
*
PROCEDURE cuShheat
 PARAMETER chOice
 DO CASE
      CASE m.chOice=1
           WAIT WINDOW NOWAIT 'Cushion Heat ON'
           = seNd_scp('RELAY10ON')
      CASE m.chOice=2
           WAIT WINDOW NOWAIT 'Cushion Heat OFF'
           = seNd_scp('RELAY10OFF')
 ENDCASE
 RETURN
*
FUNCTION auTocheck
 PRIVATE stArttime, stOptime, l
 IF m.viEwit
      ACTIVATE WINDOW viEwwin
      CLEAR
 ENDIF
 m.stArttime = SECONDS()
 m.peNding = .T.
 m.baIlout = .F.
 m.reSult = .T.
 m.l = 0
 SELECT erRorlist
 ZAP
 FOR m.l = 1 TO 20
      reSp_lvl[ m.l, 1] = .T.
      reSp_lvl[ m.l, 2] = ''
 ENDFOR
 IF poWerup()
      IF teSt_lvl(1)
           IF geTversion()
                reSp_lvl[ 1, 1] = .T.
                IF teSt_lvl(12)
                     IF m.viEwit
                          ACTIVATE WINDOW viEwwin
                          ? 'Testing Driver Seat Occupied...'
                     ENDIF
                     reSp_lvl[ 12, 1] = teStoccup()
                ELSE
                     reSp_lvl[ 12, 1] = .T.
                ENDIF
                IF (teSt_lvl(2) .OR. teSt_lvl(3) .OR. teSt_lvl(4) .OR.  ;
                   teSt_lvl(5) .OR. teSt_lvl(8) .OR. teSt_lvl(9)) .AND.   ;
                   .NOT. m.baIlout
                     DO CASE
                          CASE UPPER(ALLTRIM(m.moDuletype))='FN-116'  ;
                               .AND. m.cfGdvrside=1
                               = moVetime(1,2)
                               WAIT WINDOW NOWAIT  ;
                                    'Setting up for recline test...'
                               = moVetime(6,2)
                               DO fn116_st
                          CASE UPPER(ALLTRIM(m.moDuletype))='FN-74' .AND.  ;
                               m.cfGdvrside=1
                               WAIT WINDOW NOWAIT  ;
                                    'Setting up for recline test...'
                               = moVetime(6,2)
                               DO fn74_st
                          CASE UPPER(ALLTRIM(m.moDuletype))='FN-145'  ;
                               .AND. m.cfGdvrside=1
                               WAIT WINDOW NOWAIT  ;
                                    'Setting up for recline test...'
                               = moVetime(6,2)
                               DO fn145_st
                          CASE UPPER(ALLTRIM(m.moDuletype))='NONE' .AND.  ;
                               m.cfGdvrside=2
                               WAIT WINDOW NOWAIT  ;
                                    'Setting up for recline test...'
                               = moVetime(6,2)
                               DO noNe_st
                          CASE UPPER(ALLTRIM(m.moDuletype))='NONE'
                               DO noNe_st
                          CASE UPPER(ALLTRIM(m.moDuletype))='NONE2'
                               DO noNe_st1
                          CASE UPPER(ALLTRIM(m.moDuletype))='UN93NONE'
                               DO noNe_st1
                          CASE UPPER(ALLTRIM(m.moDuletype))='MUSTANG'
                               DO muStang
                          OTHERWISE
                     ENDCASE
                ENDIF
                IF UPPER(ALLTRIM(m.moDuletype))<>'MUSTANG'
                     IF  .NOT. m.baIlout
                          IF teSt_lvl(11)
                               IF m.viEwit
                                    ACTIVATE WINDOW viEwwin
                                    ? 'Testing Seat Belt Switch...'
                               ENDIF
                               reSp_lvl[ 11, 1] = teStbelt()
                          ELSE
                               reSp_lvl[ 11, 1] = .T.
                          ENDIF
                     ENDIF
                ENDIF
                IF  .NOT. m.baIlout
                     IF teSt_lvl(19)
                          IF m.viEwit
                               ACTIVATE WINDOW viEwwin
                               ? 'Testing UN93 Heat...'
                          ENDIF
                          reSp_lvl[ 19, 1] = un93testhe()
                          reSp_lvl[ 7, 1] = reSp_lvl(19,1)
                     ELSE
                          reSp_lvl[ 19, 1] = .T.
                          reSp_lvl[ 7, 1] = .T.
                          IF teSt_lvl(7)
                               IF m.viEwit
                                    ACTIVATE WINDOW viEwwin
                                    ? 'Testing Heat...'
                               ENDIF
                               IF teSt_lvl(18)
                                    reSp_lvl[ 7, 1] = teStheat()
                               ELSE
                                    IF heAtdetect()
                                         = adD_err('0705')
                                         reSp_lvl[ 7, 1] = .F.
                                         reSp_lvl[ 18, 1] = .F.
                                    ELSE
                                         reSp_lvl[ 7, 1] = .T.
                                         reSp_lvl[ 18, 1] = .T.
                                    ENDIF
                               ENDIF
                          ELSE
                               reSp_lvl[ 7, 1] = .T.
                          ENDIF
                     ENDIF
                ENDIF
                IF  .NOT. m.baIlout
                     IF m.moDuletype='NONE' .OR. m.moDuletype='NONE2'
                          IF teSt_lvl(5)
                               IF m.viEwit
                                    ACTIVATE WINDOW viEwwin
                                    ? 'Testing Recline...'
                               ENDIF
                               reSp_lvl[ 5, 1] = teStreclin()
                          ELSE
                               reSp_lvl[ 5, 1] = .T.
                          ENDIF
                     ENDIF
                ENDIF
                IF  .NOT. m.baIlout
                     IF teSt_lvl(14)
                          IF m.viEwit
                               ACTIVATE WINDOW viEwwin
                               ? 'Testing Recline Switch...'
                          ENDIF
                          IF  .NOT. teStreclsw()
                               reSp_lvl[ 14, 1] = .F.
                          ENDIF
                     ENDIF
                ENDIF
                IF  .NOT. m.baIlout
                     IF teSt_lvl(6) .AND. (UPPER(ALLTRIM(m.moDuletype))<> ;
                        'MUSTANG')
                          IF m.viEwit
                               ACTIVATE WINDOW viEwwin
                               ? 'Testing Lumbar...'
                          ENDIF
                          reSp_lvl[ 6, 1] = teStlumbar()
                     ELSE
                          reSp_lvl[ 6, 1] = .T.
                     ENDIF
                ENDIF
                IF  .NOT. m.baIlout
                     IF teSt_lvl(20)
                          IF m.viEwit
                               ACTIVATE WINDOW viEwwin
                               ? 'Testing Lumbar...'
                          ENDIF
                          reSp_lvl[ 20, 1] = teStschukr()
                     ELSE
                          reSp_lvl[ 20, 1] = .T.
                     ENDIF
                ENDIF
                IF  .NOT. m.baIlout
                     IF teSt_lvl(10)
                          IF m.viEwit
                               ACTIVATE WINDOW viEwwin
                               ? 'Testing Rate of Travel...'
                          ENDIF
                          reSp_lvl[ 10, 1] = teStroft()
                     ELSE
                          reSp_lvl[ 10, 1] = .T.
                     ENDIF
                ENDIF
                IF  .NOT. m.baIlout
                     IF teSt_lvl(13)
                          IF m.viEwit
                               ACTIVATE WINDOW viEwwin
                               ? 'Testing Phone...'
                          ENDIF
                          reSp_lvl[ 13, 1] = teStphone()
                     ELSE
                          reSp_lvl[ 13, 1] = .T.
                     ENDIF
                ENDIF
                IF  .NOT. m.baIlout
                     IF teSt_lvl(17)
                          IF m.viEwit
                               ACTIVATE WINDOW viEwwin
                               ? 'Testing Power Point...'
                          ENDIF
                          reSp_lvl[ 17, 1] = teStpowerp()
                     ELSE
                          reSp_lvl[ 17, 1] = .T.
                     ENDIF
                ENDIF
           ELSE
                WAIT WINDOW NOWAIT 'Version Failure !'
                FOR m.l = 1 TO 20
                     reSp_lvl[ m.l, 1] = .F.
                     reSp_lvl[ m.l, 2] = ''
                ENDFOR
                = adD_err('0101')
           ENDIF
      ELSE
           IF teSt_lvl(12)
                IF m.viEwit
                     ACTIVATE WINDOW viEwwin
                     ? 'Testing Driver Seat Occupied...'
                ENDIF
                reSp_lvl[ 12, 1] = teStoccup()
           ELSE
                reSp_lvl[ 12, 1] = .T.
           ENDIF
           IF teSt_lvl(2) .OR. teSt_lvl(3) .OR. teSt_lvl(4) .OR.  ;
              teSt_lvl(5) .OR. teSt_lvl(8) .OR. teSt_lvl(9) .AND.  .NOT.  ;
              m.baIlout
                DO CASE
                     CASE UPPER(ALLTRIM(m.moDuletype))='FN-116' .AND.  ;
                          m.cfGdvrside=1
                          = moVetime(1,1)
                          DO fn116_st
                     CASE UPPER(ALLTRIM(m.moDuletype))='FN-74' .AND.  ;
                          m.cfGdvrside=1
                          DO fn74_st
                     CASE UPPER(ALLTRIM(m.moDuletype))='FN-145' .AND.  ;
                          m.cfGdvrside=1
                          DO fn145_st
                     CASE UPPER(ALLTRIM(m.moDuletype))='NONE'
                          DO noNe_st
                     CASE UPPER(ALLTRIM(m.moDuletype))='NONE2'
                          DO noNe_st1
                     OTHERWISE
                ENDCASE
           ENDIF
           IF  .NOT. m.baIlout
                IF teSt_lvl(7)
                     IF m.viEwit
                          ACTIVATE WINDOW viEwwin
                          ? 'Testing Heat...'
                     ENDIF
                     IF teSt_lvl(18)
                          reSp_lvl[ 7, 1] = teStheat()
                     ELSE
                          IF heAtdetect()
                               = adD_err('0705')
                               reSp_lvl[ 7, 1] = .F.
                               reSp_lvl[ 18, 1] = .F.
                          ELSE
                               reSp_lvl[ 7, 1] = .T.
                               reSp_lvl[ 18, 1] = .T.
                          ENDIF
                     ENDIF
                ELSE
                     reSp_lvl[ 7, 1] = .T.
                     reSp_lvl[ 18, 1] = .T.
                ENDIF
           ENDIF
           IF  .NOT. m.baIlout
                IF m.moDuletype='NONE' .OR. m.moDuletype='NONE2'
                     IF teSt_lvl(5)
                          IF m.viEwit
                               ACTIVATE WINDOW viEwwin
                               ? 'Testing Recline...'
                          ENDIF
                          reSp_lvl[ 5, 1] = teStreclin()
                     ELSE
                          reSp_lvl[ 5, 1] = .T.
                     ENDIF
                ENDIF
           ENDIF
           IF  .NOT. m.baIlout
                IF teSt_lvl(14)
                     IF m.viEwit
                          ACTIVATE WINDOW viEwwin
                          ? 'Testing Recline Switch...'
                     ENDIF
                     IF  .NOT. teStreclsw()
                          reSp_lvl[ 14, 1] = .F.
                     ENDIF
                ENDIF
           ENDIF
           IF UPPER(ALLTRIM(m.moDuletype))<>'MUSTANG'
                IF  .NOT. m.baIlout
                     IF teSt_lvl(6)
                          IF m.viEwit
                               ACTIVATE WINDOW viEwwin
                               ? 'Testing Lumbar...'
                          ENDIF
                          reSp_lvl[ 6, 1] = teStlumbar()
                     ENDIF
                ENDIF
           ENDIF
           IF  .NOT. m.baIlout
                IF teSt_lvl(20)
                     IF m.viEwit
                          ACTIVATE WINDOW viEwwin
                          ? 'Testing Lumbar...'
                     ENDIF
                     reSp_lvl[ 20, 1] = teStschukr()
                ELSE
                     reSp_lvl[ 20, 1] = .T.
                ENDIF
           ENDIF
           IF  .NOT. m.baIlout
                IF teSt_lvl(10)
                     IF m.viEwit
                          ACTIVATE WINDOW viEwwin
                          ? 'Testing Rate of Travel...'
                     ENDIF
                     reSp_lvl[ 10, 1] = teStroft()
                ENDIF
           ENDIF
           IF  .NOT. m.baIlout
                IF teSt_lvl(11)
                     IF m.viEwit
                          ACTIVATE WINDOW viEwwin
                          ? 'Testing Seat Belt Switch...'
                     ENDIF
                     reSp_lvl[ 11, 1] = teStbelt()
                ENDIF
           ENDIF
           IF  .NOT. m.baIlout
                IF teSt_lvl(13)
                     IF m.viEwit
                          ACTIVATE WINDOW viEwwin
                          ? 'Testing Phone...'
                     ENDIF
                     reSp_lvl[ 13, 1] = teStphone()
                ELSE
                     reSp_lvl[ 13, 1] = .T.
                ENDIF
           ENDIF
           IF  .NOT. m.baIlout
                IF teSt_lvl(17)
                     IF m.viEwit
                          ACTIVATE WINDOW viEwwin
                          ? 'Testing Power Point...'
                     ENDIF
                     reSp_lvl[ 17, 1] = teStpowerp()
                ELSE
                     reSp_lvl[ 17, 1] = .T.
                ENDIF
           ENDIF
      ENDIF
 ELSE
      WAIT WINDOW NOWAIT 'Power-Up Failure !'
      FOR m.l = 1 TO 20
           reSp_lvl[ m.l, 1] = .F.
           reSp_lvl[ m.l, 2] = ''
      ENDFOR
 ENDIF
 m.stOptime = SECONDS()
 IF m.stOptime>=m.stArttime
      m.teSt_time = stOptime-m.stArttime
 ELSE
      m.teSt_time = 86400-stArttime+m.stOptime
 ENDIF
 m.peNding = .F.
 SHOW GETS
 m.peNding = .T.
 RETURN .T.
*
FUNCTION geTversion
 PRIVATE veR_result, meSstime
 m.veR_result = .T.
 m.meSstime = 0.05
 m.svErsion = 0
 m.smOnth = 0
 m.sdAy = 0
 m.syEar = 0
 m.hvErsion = 0
 m.hmOnth = 0
 m.hdAy = 0
 m.hyEar = 0
 WAIT WINDOW NOWAIT 'Requesting Software Version...'
 DO CASE
      CASE UPPER(ALLTRIM(m.moDuletype))='FN-116'
           = seNd_iso('PID11')
           IF geTisoresp(coM1)
                m.svErsion = swBitand(rxMessage(14),240)/16
                m.smOnth = swBitand(rxMessage(14),15)
                m.sdAy = rxMessage(15)
                m.syEar = rxMessage(16)
           ELSE
                WAIT WINDOW NOWAIT 'No Response !'
                = adD_err('0009')
                m.veR_result = .F.
           ENDIF
           IF m.svErsion<>m.s_Version
                WAIT WINDOW NOWAIT 'Invalid Version !'
                m.veR_result = .F.
           ENDIF
      CASE UPPER(ALLTRIM(m.moDuletype))='FN-74' .OR.  ;
           UPPER(ALLTRIM(m.moDuletype))='FN-145'
           IF seNd_scp('PID06')
                IF geTscp()=0
                     m.svErsion = swBitand(m.r_Byte4,240)/16
                     m.smOnth = swBitand(m.r_Byte4,15)
                     m.sdAy = m.r_Byte5
                     m.syEar = m.r_Byte6
                ELSE
                     WAIT WINDOW NOWAIT 'No Response !'
                     m.veR_result = .F.
                     = adD_err('0008')
                ENDIF
                IF m.svErsion<>m.s_Version
                     WAIT WINDOW NOWAIT 'Invalid Version !'
                     m.veR_result = .F.
                ENDIF
           ELSE
                m.veR_result = .F.
                = adD_err('0008')
           ENDIF
      CASE UPPER(ALLTRIM(m.moDuletype))='EN-114'
           = seNd_iso('PID11')
           IF geTisoresp(coM1)
                m.svErsion = swBitand(rxMessage(14),240)/16
                m.smOnth = swBitand(rxMessage(14),15)
                m.sdAy = rxMessage(15)
                m.syEar = rxMessage(16)
           ELSE
                WAIT WINDOW NOWAIT 'No Response !'
                = adD_err('0009')
                m.veR_result = .F.
           ENDIF
           IF m.svErsion<>m.s_Version
                WAIT WINDOW NOWAIT 'Invalid Version !'
                m.veR_result = .F.
           ENDIF
      OTHERWISE
           m.veR_result = .T.
 ENDCASE
 SHOW GETS
 WAIT WINDOW TIMEOUT m.meSstime 'Requesting Hardware Version...'
 DO CASE
      CASE UPPER(ALLTRIM(m.moDuletype))='FN-116'
           = seNd_iso('PID12')
           IF geTisoresp(coM1)
                m.hvErsion = swBitand(rxMessage(14),240)/16
                m.hmOnth = swBitand(rxMessage(14),15)
                m.hdAy = rxMessage(15)
                m.hyEar = rxMessage(16)
           ELSE
                WAIT WINDOW NOWAIT 'No Response !'
                = adD_err('0009')
                m.veR_result = .F.
           ENDIF
           IF m.hvErsion<>m.h_Version
                WAIT WINDOW NOWAIT 'Invalid Version !'
                m.veR_result = .F.
           ENDIF
      CASE UPPER(ALLTRIM(m.moDuletype))='FN-74' .OR.  ;
           UPPER(ALLTRIM(m.moDuletype))='FN-145'
           m.hvErsion = 0
           m.hmOnth = 0
           m.hdAy = 0
           m.hyEar = 0
      CASE UPPER(ALLTRIM(m.moDuletype))='EN-114'
           = seNd_iso('PID12')
           IF geTisoresp(coM1)
                m.hvErsion = swBitand(rxMessage(14),240)/16
                m.hmOnth = swBitand(rxMessage(14),15)
                m.hdAy = rxMessage(15)
                m.hyEar = rxMessage(16)
           ELSE
                WAIT WINDOW NOWAIT 'No Response !'
                = adD_err('0009')
                m.veR_result = .F.
           ENDIF
           IF m.hvErsion<>m.h_Version
                WAIT WINDOW NOWAIT 'Invalid Version !'
                m.veR_result = .F.
           ENDIF
      OTHERWISE
           m.veR_result = .T.
 ENDCASE
 SHOW GETS
 RETURN m.veR_result
*
PROCEDURE fn116_st
 PRIVATE l, j, nuMofdtcs
 DIMENSION miRrors[ 4]
 m.l = 0
 m.j = 0
 m.nuMofdtcs = 0
 STORE .F. TO miRrors
 WAIT WINDOW NOWAIT 'Entering Diag state...'
 = seNd_iso('D0')
 IF geTisoresp(coM1)
      WAIT WINDOW NOWAIT 'Entering Self Test...'
      = seNd_iso('D2')
      = geTisoresp(coM1)
      = swWait(18)
      FOR m.l = 1 TO 35
           WAIT WINDOW NOWAIT 'Testing...'
           IF baIlout()
                = seNd_iso('D4')
                = adD_err('0000')
                EXIT
           ENDIF
           = seNd_iso('D3')
           = geTisoresp(coM1)
           = seNd_iso('PID09')
           = geTisoresp(coM1)
           IF rxMessage(14)<3
                EXIT
           ENDIF
           = swWait(18)
           WAIT CLEAR
           = seNd_iso('B0')
           = geTisoresp(coM1)
      ENDFOR
      IF  .NOT. m.baIlout
           WAIT WINDOW NOWAIT 'Request Number of DTCs from test...'
           = seNd_iso('PID03')
           = geTisoresp(coM1)
           m.nuMofdtcs = rxMessage(14)
           WAIT WINDOW NOWAIT 'Requesting Results...'
           = seNd_iso('D5')
           = geTisoresp(coM1)
           IF m.nuMofdtcs>0
                FOR m.l = 1 TO INT(m.nuMofdtcs/3)+1
                     FOR m.j = 1 TO 3
                          IF (m.j+(m.l-1)*3)>m.nuMofdtcs
                               EXIT
                          ELSE
                               DO CASE
                                    CASE UPPER(maKe_dtc(rxMessage(9+(m.l- ;
                                     1)*11+m.j*2),rxMessage(10+(m.l-1)*11+ ;
                                     m.j*2)))='9667'
                                         miRrors[ 1] = .T.
                                    CASE UPPER(maKe_dtc(rxMessage(9+(m.l- ;
                                     1)*11+m.j*2),rxMessage(10+(m.l-1)*11+ ;
                                     m.j*2)))='9668'
                                         miRrors[ 2] = .T.
                                    CASE UPPER(maKe_dtc(rxMessage(9+(m.l- ;
                                     1)*11+m.j*2),rxMessage(10+(m.l-1)*11+ ;
                                     m.j*2)))='9669'
                                         miRrors[ 3] = .T.
                                    CASE UPPER(maKe_dtc(rxMessage(9+(m.l- ;
                                     1)*11+m.j*2),rxMessage(10+(m.l-1)*11+ ;
                                     m.j*2)))='9670'
                                         miRrors[ 4] = .T.
                                    OTHERWISE
                                         = adD_err(UPPER(maKe_dtc(rxMessage(9+ ;
                                          (m.l-1)*11+m.j*2),rxMessage(10+ ;
                                          (m.l-1)*11+m.j*2))))
                               ENDCASE
                          ENDIF
                     ENDFOR
                ENDFOR
           ELSE
                = adD_err('0005')
                reSp_lvl[ 8, 1] = .F.
           ENDIF
           IF  .NOT. miRrors(1)
                = adD_err('0901')
           ENDIF
           IF  .NOT. miRrors(2)
                = adD_err('0902')
           ENDIF
           IF  .NOT. miRrors(3)
                = adD_err('0903')
           ENDIF
           IF  .NOT. miRrors(4)
                = adD_err('0904')
           ENDIF
      ELSE
           = adD_err('0009')
      ENDIF
 ENDIF
 SHOW GETS
 RETURN
*
PROCEDURE fn74_st
 PRIVATE l, j, nuMofdtcs, meSs
 DIMENSION miRrors[ 8]
 m.l = 0
 m.j = 0
 m.nuMofdtcs = 0
 m.meSs = ''
 STORE .F. TO miRrors
 DO WHILE (geTscp()=-129)
 ENDDO
 WAIT WINDOW NOWAIT 'Sending Ignition off Message...'
 = swWait(1)
 = seNd_scp('88')
 WAIT WINDOW NOWAIT 'Sending PRNDL Park Message...'
 = swWait(1)
 = seNd_scp('94')
 WAIT WINDOW NOWAIT 'Entering Diag state...'
 = swWait(1)
 = seNd_scp('10')
 IF geT_scp(6,127,16,0,0,0,0)
      WAIT WINDOW NOWAIT 'Entering Self Test...'
      = swWait(1)
      = seNd_scp('31')
      IF geT_scp(6,127,49,2,0,0,0)
           = swWait(0036)
           FOR m.l = 1 TO 75
                WAIT WINDOW NOWAIT 'Testing...'
                IF baIlout()
                     = seNd_scp('EXIT_TEST')
                     = adD_err('0000')
                     EXIT
                ENDIF
                = seNd_scp('32')
                IF geT_scp(3,127,50,2)
                     = seNd_scp('PID04')
                     IF geT_scp(3,98,209,0)
                          IF m.r_Byte4<3
                               EXIT
                          ENDIF
                     ELSE
                          = adD_err('006A')
                     ENDIF
                ELSE
                     = adD_err('006B')
                ENDIF
                = swWait(18)
                WAIT CLEAR
                = seNd_scp('TESTER_PR')
                IF  .NOT. geT_scp(0)
                     = adD_err('006C')
                ENDIF
           ENDFOR
      ELSE
           = adD_err('006D')
      ENDIF
      IF m.r_Byte4=2 .AND.  .NOT. m.baIlout
           = seNd_scp('PID02')
           IF geTscp()<>-1
                m.nuMofdtcs = m.r_Byte4
                IF m.nuMofdtcs>0
                     WAIT WINDOW NOWAIT 'Requesting Results...'
                     = seNd_scp('33')
                     FOR m.l = 1 TO INT(m.nuMofdtcs/3)+1
                          IF geTscp()<>-1
                               FOR m.j = 1 TO 3
                                    IF (m.j+(m.l-1)*3)>m.nuMofdtcs
                                         EXIT
                                    ELSE
                                         DO CASE
                                              CASE m.j=1
                                                   m.meSs =  ;
                                                    UPPER(maKe_dtc(m.r_Byte2, ;
                                                    m.r_Byte3))
                                              CASE m.j=2
                                                   m.meSs =  ;
                                                    UPPER(maKe_dtc(m.r_Byte4, ;
                                                    m.r_Byte5))
                                              CASE m.j=3
                                                   m.meSs =  ;
                                                    UPPER(maKe_dtc(m.r_Byte6, ;
                                                    m.r_Byte7))
                                         ENDCASE
                                         DO CASE
                                              CASE m.meSs='9667'
                                                   miRrors[ 1] = .T.
                                              CASE m.meSs='9668'
                                                   miRrors[ 2] = .T.
                                              CASE m.meSs='9669'
                                                   miRrors[ 3] = .T.
                                              CASE m.meSs='9670'
                                                   miRrors[ 4] = .T.
                                              CASE m.meSs='A312'
                                                   miRrors[ 5] = .T.
                                              CASE m.meSs='A316'
                                                   miRrors[ 6] = .T.
                                              CASE m.meSs='A320'
                                                   miRrors[ 7] = .T.
                                              CASE m.meSs='A324'
                                                   miRrors[ 8] = .T.
                                              OTHERWISE
                                                   = adD_err(m.meSs)
                                         ENDCASE
                                    ENDIF
                               ENDFOR
                          ELSE
                               WAIT WINDOW TIMEOUT 3  ;
                                    'SCP Read error reporting DTCs !'
                          ENDIF
                     ENDFOR
                ENDIF
           ELSE
                WAIT WINDOW TIMEOUT 3 'SCP Read error requesting # of DTCs !'
           ENDIF
           WAIT WINDOW NOWAIT 'Returning to operating state...'
           = seNd_scp('20')
           = geTscp()
           IF  .NOT. miRrors(1)
                = adD_err('0901')
           ENDIF
           IF  .NOT. miRrors(2)
                = adD_err('0902')
           ENDIF
           IF  .NOT. miRrors(3)
                = adD_err('0903')
           ENDIF
           IF  .NOT. miRrors(4)
                = adD_err('0904')
           ENDIF
           IF  .NOT. miRrors(5)
                = adD_err('0905')
           ENDIF
           IF  .NOT. miRrors(6)
                = adD_err('0906')
           ENDIF
           IF  .NOT. miRrors(7)
                = adD_err('0907')
           ENDIF
           IF  .NOT. miRrors(8)
                = adD_err('0908')
           ENDIF
           SHOW GETS
           = swWait(18)
      ELSE
           IF  .NOT. m.baIlout
                = adD_err('0005')
                reSp_lvl[ 8, 1] = .F.
           ENDIF
           SHOW GETS
      ENDIF
 ELSE
      = adD_err('0008')
 ENDIF
 RETURN
*
PROCEDURE fn145_st
 PRIVATE l, j, nuMofdtcs, meSs
 DIMENSION miRrors[ 8]
 m.l = 0
 m.j = 0
 m.nuMofdtcs = 0
 m.meSs = ''
 STORE .F. TO miRrors
 DO WHILE (geTscp()=-129)
 ENDDO
 WAIT WINDOW NOWAIT 'Sending Ignition off Message...'
 = swWait(1)
 = seNd_scp('88')
 WAIT WINDOW NOWAIT 'Sending PRNDL Park Message...'
 = swWait(1)
 = seNd_scp('94')
 WAIT WINDOW NOWAIT 'Entering Diag state...'
 = swWait(1)
 = seNd_scp('10')
 IF geT_scp(6,127,16,0,0,0,0)
      WAIT WINDOW NOWAIT 'Entering Self Test...'
      = swWait(1)
      = seNd_scp('31')
      IF geT_scp(6,127,49,2,0,0,0)
           = swWait(0036)
           FOR m.l = 1 TO 75
                WAIT WINDOW NOWAIT 'Testing...'
                IF baIlout()
                     = seNd_scp('EXIT_TEST')
                     = adD_err('0000')
                     EXIT
                ENDIF
                = seNd_scp('32')
                IF geT_scp(3,127,50,2)
                     = seNd_scp('PID04')
                     IF geT_scp(3,98,209,0)
                          IF m.r_Byte4<3
                               EXIT
                          ENDIF
                     ELSE
                          = adD_err('006A')
                     ENDIF
                ELSE
                     = adD_err('006B')
                ENDIF
                = swWait(18)
                WAIT CLEAR
                = seNd_scp('TESTER_PR')
                IF  .NOT. geT_scp(0)
                     = adD_err('006C')
                ENDIF
           ENDFOR
      ELSE
           = adD_err('006D')
      ENDIF
      IF m.r_Byte4=2 .AND.  .NOT. m.baIlout
           = seNd_scp('PID02')
           IF geTscp()<>-1
                m.nuMofdtcs = m.r_Byte4
                IF m.nuMofdtcs>0
                     WAIT WINDOW NOWAIT 'Requesting Results...'
                     = seNd_scp('33')
                     FOR m.l = 1 TO INT(m.nuMofdtcs/3)+1
                          IF geTscp()<>-1
                               FOR m.j = 1 TO 3
                                    IF (m.j+(m.l-1)*3)>m.nuMofdtcs
                                         EXIT
                                    ELSE
                                         DO CASE
                                              CASE m.j=1
                                                   m.meSs =  ;
                                                    UPPER(maKe_dtc(m.r_Byte2, ;
                                                    m.r_Byte3))
                                              CASE m.j=2
                                                   m.meSs =  ;
                                                    UPPER(maKe_dtc(m.r_Byte4, ;
                                                    m.r_Byte5))
                                              CASE m.j=3
                                                   m.meSs =  ;
                                                    UPPER(maKe_dtc(m.r_Byte6, ;
                                                    m.r_Byte7))
                                         ENDCASE
                                         DO CASE
                                              CASE m.meSs='9667'
                                                   miRrors[ 1] = .T.
                                              CASE m.meSs='9668'
                                                   miRrors[ 2] = .T.
                                              CASE m.meSs='9669'
                                                   miRrors[ 3] = .T.
                                              CASE m.meSs='9670'
                                                   miRrors[ 4] = .T.
                                              CASE m.meSs='A312'
                                                   miRrors[ 5] = .T.
                                              CASE m.meSs='A316'
                                                   miRrors[ 6] = .T.
                                              CASE m.meSs='A320'
                                                   miRrors[ 7] = .T.
                                              CASE m.meSs='A324'
                                                   miRrors[ 8] = .T.
                                              OTHERWISE
                                                   = adD_err(m.meSs)
                                         ENDCASE
                                    ENDIF
                               ENDFOR
                          ELSE
                               WAIT WINDOW TIMEOUT 3  ;
                                    'SCP Read error reporting DTCs !'
                          ENDIF
                     ENDFOR
                ENDIF
           ELSE
                WAIT WINDOW TIMEOUT 3 'SCP Read error requesting # of DTCs !'
           ENDIF
           WAIT WINDOW NOWAIT 'Returning to operating state...'
           = seNd_scp('20')
           = geTscp()
           IF  .NOT. miRrors(1)
                = adD_err('0901')
           ENDIF
           IF  .NOT. miRrors(2)
                = adD_err('0902')
           ENDIF
           IF  .NOT. miRrors(3)
                = adD_err('0903')
           ENDIF
           IF  .NOT. miRrors(4)
                = adD_err('0904')
           ENDIF
           IF  .NOT. miRrors(5)
                = adD_err('0905')
           ENDIF
           IF  .NOT. miRrors(6)
                = adD_err('0906')
           ENDIF
           IF  .NOT. miRrors(7)
                = adD_err('0907')
           ENDIF
           IF  .NOT. miRrors(8)
                = adD_err('0908')
           ENDIF
           SHOW GETS
           = swWait(18)
      ELSE
           IF  .NOT. m.baIlout
                = adD_err('0005')
                reSp_lvl[ 8, 1] = .F.
           ENDIF
           SHOW GETS
      ENDIF
 ELSE
      = adD_err('0008')
 ENDIF
 RETURN
*
PROCEDURE noNe_st
 PRIVATE moTor11, moTor12, moTor21, moTor22, moTor31, moTor32, moTor41, moTor42
 PRIVATE cuRrent
 m.cuRrent = 0
 m.moTor11 = .F.
 m.moTor12 = .F.
 m.moTor21 = .F.
 m.moTor22 = .F.
 m.moTor31 = .F.
 m.moTor32 = .F.
 IF teSt_lvl(2)
      IF m.viEwit
           ACTIVATE WINDOW viEwwin
           ? 'Testing Front Motor...'
      ENDIF
      = seNd_scp('RELAY01OFF')
      = seNd_scp('RELAY02ON')
      = swWait(15)
      = swCrttimer(1,18)
      DO WHILE swGtimer(1)>0
           IF baIlout()
                = adD_err('0000')
                EXIT
           ENDIF
           m.cuRrent = reAd_atod1()
           IF m.cuRrent>=0.3
                m.moTor11 = .T.
                EXIT
           ENDIF
      ENDDO
      = swDsytimer(1)
      = seNd_scp('RELAY02OFF')
      IF  .NOT. m.baIlout
           = seNd_scp('RELAY01ON')
           = swWait(15)
           = swCrttimer(1,18)
           DO WHILE swGtimer(1)>0
                IF baIlout()
                     = adD_err('0000')
                     EXIT
                ENDIF
                m.cuRrent = reAd_atod1()
                IF m.cuRrent>=0.3
                     m.moTor12 = .T.
                     EXIT
                ENDIF
           ENDDO
           = swDsytimer(1)
           = seNd_scp('RELAY01OFF')
           = seNd_scp('RELAY02OFF')
      ENDIF
 ENDIF
 IF teSt_lvl(3) .AND.  .NOT. m.baIlout
      IF m.viEwit
           ACTIVATE WINDOW viEwwin
           ? 'Testing Rear Motor...'
      ENDIF
      = seNd_scp('RELAY06OFF')
      = seNd_scp('RELAY05ON')
      = swWait(15)
      = swCrttimer(1,18)
      DO WHILE swGtimer(1)>0
           IF baIlout()
                = adD_err('0000')
                EXIT
           ENDIF
           m.cuRrent = reAd_atod1()
           IF m.cuRrent>=0.3
                m.moTor21 = .T.
                EXIT
           ENDIF
      ENDDO
      = swDsytimer(1)
      = seNd_scp('RELAY05OFF')
      IF  .NOT. m.baIlout
           = seNd_scp('RELAY06ON')
           = swWait(15)
           = swCrttimer(1,18)
           DO WHILE swGtimer(1)>0
                IF baIlout()
                     = adD_err('0000')
                     EXIT
                ENDIF
                m.cuRrent = reAd_atod1()
                IF m.cuRrent>=0.3
                     m.moTor22 = .T.
                     EXIT
                ENDIF
           ENDDO
           = swDsytimer(1)
           = seNd_scp('RELAY05OFF')
           = seNd_scp('RELAY06OFF')
      ENDIF
 ENDIF
 IF teSt_lvl(4) .AND.  .NOT. m.baIlout
      IF m.viEwit
           ACTIVATE WINDOW viEwwin
           ? 'Testing Horizontal Motor...'
      ENDIF
      = seNd_scp('RELAY04OFF')
      = seNd_scp('RELAY03ON')
      = swWait(15)
      = swCrttimer(1,18)
      DO WHILE swGtimer(1)>0
           IF baIlout()
                = adD_err('0000')
                EXIT
           ENDIF
           m.cuRrent = reAd_atod1()
           IF m.cuRrent>=0.3
                m.moTor31 = .T.
                EXIT
           ENDIF
      ENDDO
      = swDsytimer(1)
      = seNd_scp('RELAY03OFF')
      IF  .NOT. m.baIlout
           = seNd_scp('RELAY04ON')
           = swWait(15)
           = swCrttimer(1,18)
           DO WHILE swGtimer(1)>0
                IF baIlout()
                     = adD_err('0000')
                     EXIT
                ENDIF
                m.cuRrent = reAd_atod1()
                IF m.cuRrent>=0.3
                     m.moTor32 = .T.
                     EXIT
                ENDIF
           ENDDO
           = swDsytimer(1)
           = seNd_scp('RELAY03OFF')
           = seNd_scp('RELAY04OFF')
      ENDIF
 ENDIF
 IF  .NOT. m.baIlout
      IF  .NOT. m.moTor11 .AND. teSt_lvl(2)
           = adD_err('0201')
      ENDIF
      IF  .NOT. m.moTor12 .AND. teSt_lvl(2)
           = adD_err('0202')
      ENDIF
      IF  .NOT. m.moTor21 .AND. teSt_lvl(3)
           = adD_err('0301')
      ENDIF
      IF  .NOT. m.moTor22 .AND. teSt_lvl(3)
           = adD_err('0302')
      ENDIF
      IF  .NOT. m.moTor31 .AND. teSt_lvl(4)
           = adD_err('0401')
      ENDIF
      IF  .NOT. m.moTor32 .AND. teSt_lvl(4)
           = adD_err('0402')
      ENDIF
 ENDIF
 RETURN
*
PROCEDURE noNe_st1
 PRIVATE goTit, stArttime, stOptime
 DIMENSION maN_motor[ 12]
 PRIVATE op_fup, op_fdn, op_frel
 m.op_fup = 30
 m.op_fdn = 30
 m.op_frel = 5
 m.op_bup = 30
 m.op_bdn = 30
 m.op_brel = 5
 m.op_hfwd = 30
 m.op_hbk = 30
 m.op_hrel = 5
 = swDaltimer()
 STORE .F. TO maN_motor
 IF teSt_lvl(2) .AND.  .NOT. m.baIlout
      IF m.cfGshort=.T.
           SET PROCEDURE TO SHORTEST.PRG
           m.goTit = shOrtfrt('DOWN',m.op_fdn,cfGshtime)
           IF m.goTit=.F.
                = adD_err('0202')
                RETURN
           ENDIF
           m.goTit = shOrtfrt('UP',m.op_fdn,cfGshtime)
           IF m.goTit=.F.
                = adD_err('0201')
                RETURN
           ENDIF
      ELSE
           SET PROCEDURE TO LONGTEST.PRG
           m.goTit = loNgfrt('DOWN',m.frDn_run,frDnstall,op_fdn,op_frel)
           IF m.goTit=.F.
                = adD_err('0202')
                RETURN
           ENDIF
           m.goTit = loNgfrt('UP',m.frUp_run,frOnstall,op_fup,op_frel)
           IF m.goTit=.F.
                = adD_err('0201')
                RETURN
           ENDIF
      ENDIF
 ENDIF
 IF teSt_lvl(3) .AND.  .NOT. m.baIlout
      IF m.cfGshort=.T.
           SET PROCEDURE TO SHORTEST.PRG
           m.goTit = shOrtrr('DOWN',m.op_bdn,cfGshtime)
           IF m.goTit=.F.
                = adD_err('0202')
                RETURN
           ENDIF
           m.goTit = shOrtrr('UP',m.op_bdn,cfGshtime)
           IF m.goTit=.F.
                = adD_err('0201')
                RETURN
           ENDIF
      ELSE
           SET PROCEDURE TO LONGTEST.PRG
           m.goTit = loNgrr('DOWN',m.bkDn_run,bkDnstall,op_bdn,op_brel)
           IF m.goTit=.F.
                = adD_err('0202')
                RETURN
           ENDIF
           m.goTit = loNgrr('UP',m.bkUp_run,bkUpstall,op_bup,op_brel)
           IF m.goTit=.F.
                = adD_err('0201')
                RETURN
           ENDIF
      ENDIF
 ENDIF
 IF teSt_lvl(4) .AND.  .NOT. m.baIlout
      IF m.cfGshort=.T.
           SET PROCEDURE TO SHORTEST.PRG
           IF m.moDuletype='UN93NONE'
                m.goTit = shOrthoriz('BACKWARD',m.op_hbk,cfGshtime)
                IF m.goTit=.F.
                     = adD_err('0402')
                     RETURN
                ENDIF
                m.goTit = shOrthoriz('FORWARD',m.op_hfwd,cfGshtime)
                IF m.goTit=.F.
                     = adD_err('0401')
                     RETURN
                ENDIF
           ELSE
                m.goTit = shOrthoriz('FORWARD',m.op_hfwd,cfGshtime)
                IF m.goTit=.F.
                     = adD_err('0401')
                     RETURN
                ENDIF
                m.goTit = shOrthoriz('BACKWARD',m.op_hbk,cfGshtime)
                IF m.goTit=.F.
                     = adD_err('0402')
                     RETURN
                ENDIF
           ENDIF
      ELSE
           SET PROCEDURE TO LONGTEST.PRG
           m.goTit = loNghoriz('FORWARD',hoFw_run,hoFwstall,op_hfwd,op_hrel)
           IF m.goTit=.F.
                = adD_err('0401')
                RETURN
           ENDIF
           m.goTit = loNghoriz('BACKWARD',hoBk_run,hoBkstall,op_hbk,op_hrel)
           IF m.goTit=.F.
                = adD_err('0402')
                RETURN
           ENDIF
      ENDIF
 ENDIF
*
PROCEDURE muStang
 PRIVATE goTit, stArttime, stOptime
 DIMENSION maN_motor[ 12]
 PRIVATE op_fup, op_fdn, op_frel
 m.op_fup = m.vfMaxtime
 m.op_fdn = m.vfMaxtime
 m.op_frel = m.vfMaxtime
 m.op_bup = m.vrMaxtime
 m.op_bdn = m.vrMaxtime
 m.op_brel = m.vrMaxtime
 m.op_hfwd = 30
 m.op_hbk = 30
 m.op_hrel = 5
 = swDaltimer()
 STORE .F. TO maN_motor
 IF teSt_lvl(2) .AND.  .NOT. m.baIlout
      IF m.cfGshort=.T.
           SET PROCEDURE TO SHORTEST.PRG
           m.goTit = shOrtfrt('UP',m.vfRuncur,cfGshtime)
           IF m.goTit=.F.
                = adD_err('0201')
                RETURN
           ENDIF
           m.goTit = shOrtfrt('DOWN',m.vfRuncur,cfGshtime)
           IF m.goTit=.F.
                = adD_err('0202')
                RETURN
           ENDIF
      ELSE
           SET PROCEDURE TO LONGTEST.PRG
           m.goTit = loNgfrt('UP',m.vfRuncur,vfStallcur,vfMaxtime,op_frel)
           IF m.goTit=.F.
                = adD_err('0201')
                RETURN
           ENDIF
           m.goTit = loNgfrt('DOWN',m.vrRuncur,vrStallcur,vrMaxtime,vrMaxtime)
           IF m.goTit=.F.
                = adD_err('0202')
                RETURN
           ENDIF
      ENDIF
 ENDIF
 IF teSt_lvl(3) .AND.  .NOT. m.baIlout
      IF m.cfGshort=.T.
           SET PROCEDURE TO SHORTEST.PRG
           m.goTit = shOrtrr('UP',vrRuncur,cfGshtime)
           IF m.goTit=.F.
                = adD_err('0301')
                RETURN
           ENDIF
           m.goTit = shOrtrr('DOWN',vrRuncur,cfGshtime)
           IF m.goTit=.F.
                = adD_err('0302')
                RETURN
           ENDIF
      ELSE
           SET PROCEDURE TO LONGTEST.PRG
           m.goTit = loNgrr('UP',vrRuncur,vrStallcur,vfMaxtime,vfMaxtime)
           IF m.goTit=.F.
                = adD_err('0301')
                RETURN
           ENDIF
           m.goTit = loNgrr('DOWN',vrRuncur,vrStallcur,vfMaxtime,vfMaxtime)
           IF m.goTit=.F.
                = adD_err('0302')
                RETURN
           ENDIF
      ENDIF
 ENDIF
 IF teSt_lvl(4) .AND.  .NOT. m.baIlout
      IF m.cfGshort=.T.
           SET PROCEDURE TO SHORTEST.PRG
           m.goTit = shOrthoriz('BACKWARD',hoBk_run,cfGshtime)
           IF m.goTit=.F.
                = adD_err('0402')
                RETURN
           ENDIF
           m.goTit = shOrthoriz('FORWARD',hoFw_run,cfGshtime)
           IF m.goTit=.F.
                = adD_err('0401')
                RETURN
           ENDIF
      ELSE
           SET PROCEDURE TO LONGTEST.PRG
           m.goTit = loNghoriz('BACKWARD',hoBk_run,hoBkstall,op_hbk,op_hrel)
           IF m.goTit=.F.
                = adD_err('0402')
                RETURN
           ENDIF
           m.goTit = loNghoriz('FORWARD',hoFw_run,hoFwstall,op_hfwd,op_hrel)
           IF m.goTit=.F.
                = adD_err('0401')
                RETURN
           ENDIF
      ENDIF
 ENDIF
 IF  .NOT. m.baIlout
      IF teSt_lvl(11)
           IF m.viEwit
                = seNd_scp('RELAY12OFF')
                = seNd_scp('RELAY14OFF')
                ACTIVATE WINDOW viEwwin
                ? 'Testing Seat Belt Switch...'
           ENDIF
           reSp_lvl[ 11, 1] = teStbelt()
      ELSE
           reSp_lvl[ 11, 1] = .T.
      ENDIF
      = seNd_scp('RELAY12ON')
      = seNd_scp('RELAY14ON')
 ENDIF
 IF  .NOT. m.baIlout
      IF teSt_lvl(6)
           IF m.viEwit
                ACTIVATE WINDOW viEwwin
                ? 'Testing Lumbar...'
           ENDIF
           reSp_lvl[ 6, 1] = muStlumbar()
      ELSE
           reSp_lvl[ 6, 1] = .T.
      ENDIF
 ENDIF
 = shIpmstng()
 = swDaltimer()
 RETURN
*
FUNCTION teStreclin
 PRIVATE moTor1, moTor2, moTor3, moTor4, moTor5, cuRrent
 m.r_Byte3 = 0
 m.r_Byte4 = 0
 m.moTor1 = .F.
 m.moTor2 = .F.
 m.moTor3 = .F.
 m.moTor4 = .F.
 m.moTor5 = .F.
 m.cuRrent = 0
 IF  .NOT. teSt_lvl(15)
      WAIT WINDOW NOWAIT 'Testing recline on non-module seat...'
      = seNd_scp('RELAY07OFF')
      = seNd_scp('RELAY08ON')
      = swWait(15)
      = swCrttimer(1,18)
      DO WHILE swGtimer(1)>0
           IF baIlout()
                = adD_err('0000')
                EXIT
           ENDIF
           m.cuRrent = reAd_atod1()
           IF m.cuRrent>=m.reBk_run
                m.moTor1 = .T.
                EXIT
           ENDIF
      ENDDO
      IF m.cuRrent>=m.reBk_run .AND. m.cuRrent<m.reFwstall
           m.moTor2 = .T.
      ENDIF
      = swDsytimer(1)
      = seNd_scp('RELAY08OFF')
      IF  .NOT. m.baIlout
           = seNd_scp('RELAY07ON')
           = swWait(15)
           = swCrttimer(1,swSecond*m.reClstall)
           DO WHILE swGtimer(1)>0
                IF baIlout()
                     = adD_err('0000')
                     EXIT
                ENDIF
                m.cuRrent = reAd_atod1()
                IF m.cuRrent>=m.reFw_run
                     m.moTor3 = .T.
                     EXIT
                ENDIF
           ENDDO
           IF m.cuRrent>=m.reFw_run .AND. m.cuRrent<m.reFwstall
                m.moTor4 = .T.
           ENDIF
           = swDsytimer(1)
           = seNd_scp('RELAY07OFF')
           = seNd_scp('RELAY08OFF')
      ENDIF
      IF  .NOT. m.baIlout
           = seNd_scp('RELAY07ON')
           = swWait(15)
           = swCrttimer(1,swSecond*m.reClstall)
           DO WHILE swGtimer(1)>0
                IF baIlout()
                     = adD_err('0000')
                     EXIT
                ENDIF
                m.cuRrent = reAd_atod1()
                IF m.cuRrent>m.reFwstall
                     m.moTor5 = .T.
                     EXIT
                ENDIF
           ENDDO
           = swDsytimer(1)
           = seNd_scp('RELAY07OFF')
           = seNd_scp('RELAY08OFF')
      ENDIF
      IF  .NOT. m.moTor1
           = adD_err('0507')
      ELSE
           IF  .NOT. m.moTor2
                = adD_err('0509')
           ENDIF
      ENDIF
      IF  .NOT. m.moTor3
           = adD_err('0506')
      ELSE
           IF  .NOT. m.moTor4
                = adD_err('0508')
           ENDIF
      ENDIF
      IF  .NOT. m.moTor5
           = adD_err('0510')
      ENDIF
      IF m.moTor1 .AND. m.moTor2 .AND. m.moTor3 .AND. m.moTor4 .AND. m.moTor5
           = clEarpromp()
           RETURN .T.
      ENDIF
 ELSE
      IF  .NOT. in_prompt('Does the Recliner Function Properly?')
           = adD_err('0511')
           = clEarpromp()
           RETURN .F.
      ELSE
           = clEarpromp()
           RETURN .T.
      ENDIF
 ENDIF
 = clEarpromp()
 RETURN .F.
*
FUNCTION teStreclsw
 PRIVATE ro_result, rc_result, rs_result, inLoop, skIpcount
 m.r_Byte3 = 0
 m.r_Byte4 = 0
 IF m.moDuletype='NONE' .OR. m.moDuletype='NONE2'
      = laRge_prom('PRESS RECLINE SWITCH DOWN...',0)
      m.ro_result = .F.
      m.rc_result = .F.
      = swCrttimer(1,(swSecond*m.op_recldn))
      DO WHILE swGtimer(1)>0
           IF baIlout()
                = adD_err('0000')
                EXIT
           ENDIF
           m.cuRrent = reAd_atod1()
           IF m.cuRrent>=m.reBk_run
                IF m.cuRrent>=m.reBkstall
                     = adD_err('0509')
                     EXIT
                ENDIF
                m.rc_result = .T.
                = laRge_prom('RELEASE RECLINE SWITCH...',1)
                = swCrttimer(2,swSecond*m.op_reclrel)
                DO WHILE swGtimer(2)>0
                     m.cuRrent = reAd_atod1()
                     IF m.cuRrent<m.reBk_run
                          m.ro_result = .T.
                          EXIT
                     ENDIF
                ENDDO
                IF m.ro_result
                     EXIT
                ENDIF
           ENDIF
      ENDDO
      = swDsytimer(1)
      = swDsytimer(2)
      = clEarpromp()
      IF  .NOT. m.rc_result
           = adD_err('0503')
           RETURN .F.
      ENDIF
      IF  .NOT. m.ro_result
           = adD_err('0502')
           RETURN .F.
      ENDIF
      IF  .NOT. m.baIlout
           = laRge_prom('PRESS & HOLD RECLINE SWITCH UP...',0)
           m.rs_result = .F.
           m.inLoop = .F.
           m.skIpcount = 0
           = swCrttimer(1,(swSecond*m.op_reclup))
           DO WHILE swGtimer(1)>0
                IF baIlout()
                     = adD_err('0000')
                     EXIT
                ENDIF
                m.cuRrent = reAd_atod1()
                IF (m.cuRrent>=m.reBk_run) .AND.  .NOT. m.inLoop
                     = swRestrttm(1,swSecond*m.op_reclup)
                     m.inLoop = .T.
                ENDIF
                IF m.inLoop .AND. (m.cuRrent<m.reBk_run)
                     m.skIpcount = m.skIpcount+1
                     IF m.skIpcount>2
                          = swDsytimer(1)
                          = adD_err('0505')
                          = clEarpromp()
                          RETURN .F.
                     ENDIF
                ELSE
                     m.skIpcount = 0
                ENDIF
                IF m.inLoop .AND. (m.cuRrent>=m.reFwstall)
                     m.rs_result = .T.
                     EXIT
                ENDIF
           ENDDO
           IF  .NOT. rs_result
                = swDsytimer(1)
                = clEarpromp()
                = adD_err('0504')
                RETURN .F.
           ELSE
                IF  .NOT. m.baIlout
                     = laRge_prom('RELEASE RECLINE SWITCH...',1)
                     = swCrttimer(2,swSecond*m.op_reclrel)
                     DO WHILE swGtimer(2)>0
                          IF baIlout()
                               = adD_err('0000')
                               EXIT
                          ENDIF
                          m.cuRrent = reAd_atod1()
                          IF m.cuRrent<m.reBk_run
                               = swDsytimer(1)
                               = swDsytimer(2)
                               = clEarpromp()
                               RETURN .T.
                          ENDIF
                     ENDDO
                     = swDsytimer(1)
                     = swDsytimer(2)
                     = adD_err('0502')
                     = clEarpromp()
                     RETURN .F.
                ENDIF
                = clEarpromp()
                = swDsytimer(1)
                = swDsytimer(2)
           ENDIF
      ENDIF
 ELSE
      = seNd_scp('RELAY07ON')
      = laRge_prom('PRESS THE RECLINE SWITCH DOWN...',0)
      = swCrttimer(1,(swSecond*m.op_recldn))
      DO WHILE swGtimer(1)>0
           IF baIlout()
                = adD_err('0000')
                EXIT
           ENDIF
           IF geTscp()=0
                IF swBitand(m.r_Byte3,64)=64
                     = laRge_prom('RELEASE THE RECLINE SWITCH...',1)
                     = swCrttimer(2,(swSecond*m.op_reclrel))
                     DO WHILE swGtimer(2)>0
                          IF baIlout()
                               = adD_err('0000')
                               EXIT
                          ENDIF
                          IF geTscp()=0
                               IF swBitand(m.r_Byte3,64)=0
                                    = seNd_scp('RELAY07OFF')
                                    = seNd_scp('RELAY08ON')
                                    = laRge_prom( ;
                                      'PRESS THE RECLINE SWITCH UP...',0)
                                    = swCrttimer(3,(swSecond*m.op_reclup))
                                    DO WHILE swGtimer(3)>0
                                         IF baIlout()
                                              = adD_err('0000')
                                              EXIT
                                         ENDIF
                                         IF geTscp()=0
                                              IF swBitand(m.r_Byte3,64)=64
                                                   = laRge_prom( ;
                                                    'RELEASE THE RECLINE SWITCH...', ;
                                                    1)
                                                   = swCrttimer(4, ;
                                                    (swSecond*m.op_reclrel))
                                                   DO WHILE swGtimer(4)>0
                                                        IF baIlout()
                                                             = adD_err('0000')
                                                             EXIT
                                                        ENDIF
                                                        IF geTscp()=0
                                                             IF  ;
                                                              swBitand(m.r_Byte3, ;
                                                              64)=0
                                                                  = swDsytimer(1)
                                                                  = swDsytimer(2)
                                                                  = swDsytimer(3)
                                                                  = swDsytimer(4)
                                                                  = seNd_scp('RELAY07OFF')
                                                                  = seNd_scp('RELAY08OFF')
                                                                  = clEarpromp()
                                                                  RETURN .T.
                                                             ENDIF
                                                        ENDIF
                                                   ENDDO
                                                   = adD_err('0802')
                                                   = swDsytimer(1)
                                                   = swDsytimer(2)
                                                   = swDsytimer(3)
                                                   = swDsytimer(4)
                                                   = seNd_scp('RELAY07OFF')
                                                   = seNd_scp('RELAY08OFF')
                                                   = clEarpromp()
                                                   RETURN .F.
                                              ENDIF
                                         ENDIF
                                    ENDDO
                                    = adD_err('0801')
                                    = swDsytimer(1)
                                    = swDsytimer(2)
                                    = swDsytimer(3)
                                    = seNd_scp('RELAY07OFF')
                                    = seNd_scp('RELAY08OFF')
                                    = clEarpromp()
                                    RETURN .F.
                               ENDIF
                          ENDIF
                     ENDDO
                     = adD_err('0804')
                     = swDsytimer(1)
                     = swDsytimer(2)
                     = seNd_scp('RELAY07OFF')
                     = seNd_scp('RELAY08OFF')
                     = clEarpromp()
                     RETURN .F.
                ENDIF
           ENDIF
      ENDDO
      = adD_err('0803')
      = swDsytimer(1)
      = seNd_scp('RELAY07OFF')
      = seNd_scp('RELAY08OFF')
 ENDIF
 = clEarpromp()
 = swDaltimer()
 RETURN .F.
*
FUNCTION muStlumbar
 PRIVATE goTit, cuRrdraw
 DIMENSION luMbar[ 2]
 = swDaltimer()
 m.r_Byte3 = 0
 m.r_Byte4 = 0
 m.l = 0
 luMbar[ 1] = .F.
 luMbar[ 2] = .F.
 m.goTit = .F.
 cuRrdraw = 0
 m.goTit = .F.
 = laRge_prom('PRESS & HOLD LUMBAR *OUT* SWITCH...',0)
 = swCrttimer(1,(swSecond*m.cfGshwait))
 DO WHILE swGtimer(1)>0
      m.cuRrdraw = reAd_atod1()
      IF m.cuRrdraw>0
           m.goTit = .T.
           EXIT
      ENDIF
 ENDDO
 = swDsytimer(1)
 IF m.goTit=.F.
      = adD_err('0000')
      RETURN .F.
 ELSE
      m.goTit = .F.
 ENDIF
 = swCrttimer(1,(swSecond*m.op_mlout))
 DO WHILE swGtimer(1)>0
      IF baIlout()
           = adD_err('0000')
           EXIT
      ENDIF
      IF reAd_atod1()>0
           m.goTit = .T.
           luMbar[ 1] = .T.
      ENDIF
 ENDDO
 = swDsytimer(1)
 IF luMbar(1)=.T.
      m.goTit = .F.
      = laRge_prom('RELEASE LUMBAR SWITCH...',1)
      = swCrttimer(1,(swSecond*m.op_mlrel))
      DO WHILE swGtimer(1)>0
           IF baIlout()
                = adD_err('0000')
                EXIT
           ENDIF
           IF reAd_atod1()<=0
                m.goTit = .T.
                luMbar[ 2] = .T.
                EXIT
           ENDIF
      ENDDO
      = swDsytimer(1)
      IF  .NOT. luMbar(2)
           = adD_err('0610')
           EXIT
      ENDIF
 ELSE
      = adD_err('0613')
      = swDsytimer(1)
      RETURN (.F.)
 ENDIF
 = swDsytimer(1)
 RETURN (m.goTit)
*
FUNCTION teStlumbar
 PRIVATE l, inLoop, skIpcount, reL_time, goTit, stArttime, stOptime
 DIMENSION luMbar[ 10]
 = swDaltimer()
 m.r_Byte3 = 0
 m.r_Byte4 = 0
 m.reL_time = 10
 STORE .F. TO luMbar
 m.l = 0
 m.goTit = .F.
 IF teSt_lvl(16)
      IF m.cfG2wylumb
           = laRge_prom('PRESS & HOLD LUMBAR *IN* SWITCH...',0)
           = swCrttimer(1,(swSecond*m.op_lout))
           DO WHILE swGtimer(1)>0
                IF baIlout()
                     = adD_err('0000')
                     EXIT
                ENDIF
                IF reAd_atod1()>m.luMbarstal
                     luMbar[ 1] = .T.
                     = laRge_prom('RELEASE LUMBAR SWITCH...',1)
                     = swCrttimer(2,swSecond*m.op_lrel)
                     DO WHILE swGtimer(2)>0
                          IF baIlout()
                               = adD_err('0000')
                               EXIT
                          ENDIF
                          IF reAd_atod1()<=m.luMbarrun
                               luMbar[ 2] = .T.
                               EXIT
                          ENDIF
                     ENDDO
                     = swDsytimer(2)
                     IF  .NOT. luMbar(2)
                          = adD_err('0610')
                          EXIT
                     ELSE
                          EXIT
                     ENDIF
                ENDIF
           ENDDO
           = swDsytimer(1)
           IF  .NOT. luMbar(1)
                = adD_err('0604')
           ENDIF
           IF  .NOT. m.baIlout
                m.goTit = .F.
                = laRge_prom('PRESS & HOLD LUMBAR *OUT* SWITCH...',0)
                = swCrttimer(1,(swSecond*m.op_lin))
                DO WHILE swGtimer(1)>0
                     IF baIlout()
                          = adD_err('0000')
                          EXIT
                     ENDIF
                     IF reAd_atod1()>=m.luMbarrun .AND.  .NOT. m.goTit
                          m.stArttime = SECONDS()
                          m.goTit = .T.
                     ENDIF
                     IF reAd_atod1()>m.luMbarstal
                          IF  .NOT. m.goTit
                               m.stArttime = SECONDS()
                          ENDIF
                          m.stOptime = SECONDS()
                          IF (m.stOptime-m.stArttime)<5
                               = adD_err('0614')
                               luMbar[ 5] = .F.
                          ELSE
                               luMbar[ 5] = .T.
                          ENDIF
                          luMbar[ 3] = .T.
                          = laRge_prom('RELEASE LUMBAR SWITCH...',1)
                          = swCrttimer(2,swSecond*m.op_lrel)
                          DO WHILE swGtimer(2)>0
                               IF baIlout()
                                    = adD_err('0000')
                                    EXIT
                               ENDIF
                               IF reAd_atod1()<=m.luMbarrun
                                    luMbar[ 4] = .T.
                                    EXIT
                               ENDIF
                          ENDDO
                          = swDsytimer(2)
                          IF  .NOT. luMbar(4)
                               = adD_err('0609')
                               EXIT
                          ELSE
                               EXIT
                          ENDIF
                     ENDIF
                ENDDO
                = swDsytimer(1)
                IF  .NOT. luMbar(3)
                     = adD_err('0603')
                ENDIF
           ENDIF
           FOR m.l = 1 TO 5
                IF  .NOT. luMbar(m.l)
                     = clEarpromp()
                     RETURN .F.
                ENDIF
           ENDFOR
           = clEarpromp()
           RETURN .T.
      ELSE
           m.goTit = .F.
           = laRge_prom('PRESS & HOLD LUMBAR OUT SWITCH...',0)
           = swCrttimer(1,(swSecond*m.op_lout))
           DO WHILE swGtimer(1)>0
                IF baIlout()
                     = adD_err('0000')
                     EXIT
                ENDIF
                IF reAd_atod1()>m.luMbarstal
                     luMbar[ 1] = .T.
                     = laRge_prom('RELEASE LUMBAR SWITCH...',1)
                     = swCrttimer(2,swSecond*m.op_lrel)
                     DO WHILE swGtimer(2)>0
                          IF baIlout()
                               = adD_err('0000')
                               EXIT
                          ENDIF
                          IF reAd_atod1()<=m.luMbarrun
                               luMbar[ 2] = .T.
                               EXIT
                          ENDIF
                     ENDDO
                     = swDsytimer(2)
                     IF  .NOT. luMbar(2)
                          = adD_err('0610')
                          EXIT
                     ENDIF
                ENDIF
           ENDDO
           = swDsytimer(1)
           IF  .NOT. luMbar(1)
                = adD_err('0604')
           ENDIF
           IF  .NOT. m.baIlout
                m.goTit = .F.
                = laRge_prom('PRESS & HOLD LUMBAR IN SWITCH...',0)
                = swCrttimer(1,(swSecond*m.op_lin))
                DO WHILE swGtimer(1)>0
                     IF baIlout()
                          = adD_err('0000')
                          EXIT
                     ENDIF
                     IF reAd_atod1()>=m.luMbarrun .AND.  .NOT. m.goTit
                          m.stArttime = SECONDS()
                          m.goTit = .T.
                     ENDIF
                     IF reAd_atod1()>m.luMbarstal
                          IF  .NOT. m.goTit
                               m.stArttime = SECONDS()
                          ENDIF
                          m.stOptime = SECONDS()
                          IF (m.stOptime-m.stArttime)<5
                               = adD_err('0614')
                               luMbar[ 9] = .F.
                          ELSE
                               luMbar[ 9] = .T.
                          ENDIF
                          luMbar[ 3] = .T.
                          = laRge_prom('RELEASE LUMBAR SWITCH...',1)
                          = swCrttimer(2,swSecond*m.op_lrel)
                          DO WHILE swGtimer(2)>0
                               IF baIlout()
                                    = adD_err('0000')
                                    EXIT
                               ENDIF
                               IF reAd_atod1()<=m.luMbarrun
                                    luMbar[ 4] = .T.
                                    EXIT
                               ENDIF
                          ENDDO
                          = swDsytimer(2)
                          IF  .NOT. luMbar(4)
                               = adD_err('0609')
                               EXIT
                          ELSE
                               EXIT
                          ENDIF
                     ENDIF
                ENDDO
                = swDsytimer(1)
                IF  .NOT. luMbar(3)
                     = adD_err('0603')
                ENDIF
           ENDIF
           IF  .NOT. m.baIlout
                = laRge_prom('PRESS & HOLD LUMBAR UP SWITCH...',0)
                = swCrttimer(1,(swSecond*m.op_lup))
                DO WHILE swGtimer(1)>0
                     IF baIlout()
                          = adD_err('0000')
                          EXIT
                     ENDIF
                     IF reAd_atod1()>m.luMbarstal
                          luMbar[ 5] = .T.
                          = laRge_prom('RELEASE LUMBAR SWITCH...',1)
                          = swCrttimer(2,swSecond*m.op_lrel)
                          DO WHILE swGtimer(2)>0
                               IF baIlout()
                                    = adD_err('0000')
                                    EXIT
                               ENDIF
                               IF reAd_atod1()<=m.luMbarrun
                                    luMbar[ 6] = .T.
                                    EXIT
                               ENDIF
                          ENDDO
                          = swDsytimer(2)
                          IF  .NOT. luMbar(6)
                               = adD_err('0607')
                               EXIT
                          ELSE
                               EXIT
                          ENDIF
                     ENDIF
                ENDDO
                = swDsytimer(1)
                IF  .NOT. luMbar(5)
                     = adD_err('0601')
                ENDIF
           ENDIF
           IF  .NOT. m.baIlout
                m.goTit = .F.
                = laRge_prom('PRESS & HOLD LUMBAR DOWN SWITCH...',0)
                = swCrttimer(1,(swSecond*m.op_ldn))
                DO WHILE swGtimer(1)>0
                     IF baIlout()
                          = adD_err('0000')
                          EXIT
                     ENDIF
                     IF reAd_atod1()>=m.luMbarrun .AND.  .NOT. m.goTit
                          m.stArttime = SECONDS()
                          m.goTit = .T.
                     ENDIF
                     IF reAd_atod1()>m.luMbarstal
                          IF  .NOT. m.goTit
                               m.stArttime = SECONDS()
                          ENDIF
                          m.stOptime = SECONDS()
                          IF (m.stOptime-m.stArttime)<5
                               = adD_err('0615')
                               luMbar[ 10] = .F.
                          ELSE
                               luMbar[ 10] = .T.
                          ENDIF
                          luMbar[ 7] = .T.
                          = laRge_prom('RELEASE LUMBAR SWITCH...',1)
                          = swCrttimer(2,swSecond*m.op_lrel)
                          DO WHILE swGtimer(2)>0
                               IF baIlout()
                                    = adD_err('0000')
                                    EXIT
                               ENDIF
                               IF reAd_atod1()<=m.luMbarrun
                                    luMbar[ 8] = .T.
                                    EXIT
                               ENDIF
                          ENDDO
                          = swDsytimer(2)
                          IF  .NOT. luMbar(8)
                               = adD_err('0608')
                               EXIT
                          ELSE
                               EXIT
                          ENDIF
                     ENDIF
                ENDDO
                = swDsytimer(1)
                IF  .NOT. luMbar(7)
                     = adD_err('0602')
                ENDIF
           ENDIF
           FOR m.l = 1 TO 10
                IF  .NOT. luMbar(m.l)
                     = clEarpromp()
                     RETURN .F.
                ENDIF
           ENDFOR
           = clEarpromp()
           RETURN .T.
      ENDIF
 ELSE
      = laRge_prom('PRESS & HOLD LUMBAR SWITCH FORWARD...',0)
      m.inLoop = .F.
      m.skIpcount = 0
      = swCrttimer(9,(swSecond*m.op_bagfwd))
      DO WHILE swGtimer(9)>0
           IF baIlout()
                = adD_err('0000')
                EXIT
           ENDIF
           m.cuRrent = reAd_atod1()
           IF (m.cuRrent>=m.luMbardrop) .AND.  .NOT. m.inLoop
                IF m.viEwit
                     ACTIVATE WINDOW viEwwin
                     ? 'Lumbar Detected.'
                ENDIF
                = swRestrttm(9,swSecond*m.inFlatetim)
                m.inLoop = .T.
           ENDIF
           IF m.inLoop .AND. (m.cuRrent<m.luMbardrop)
                m.skIpcount = m.skIpcount+1
                IF m.skIpcount>2
                     IF m.viEwit
                          ACTIVATE WINDOW viEwwin
                          ? 'Lumbar Not Detected.'
                     ENDIF
                     = swDsytimer(9)
                     = adD_err('0612')
                     = clEarpromp()
                     RETURN .F.
                ENDIF
           ELSE
                m.skIpcount = 0
           ENDIF
           IF m.inLoop .AND. ((m.cuRrent>m.reBkstall) .OR. (m.cuRrent> ;
              m.reFwstall))
                = swDsytimer(9)
                = adD_err('0611')
                = clEarpromp()
                RETURN .F.
           ENDIF
      ENDDO
      = swDsytimer(9)
      IF  .NOT. m.inLoop
           = adD_err('0605')
           = clEarpromp()
           RETURN .F.
      ENDIF
      IF  .NOT. m.baIlout
           = laRge_prom('RELEASE LUMBAR SWITCH...',1)
           = swCrttimer(2,swSecond*m.op_bagrel)
           DO WHILE swGtimer(2)>0
                IF baIlout()
                     = adD_err('0000')
                     EXIT
                ENDIF
                m.cuRrent = reAd_atod1()
                IF m.cuRrent<=m.luMbardrop
                     = swDsytimer(2)
                     = clEarpromp()
                     IF m.cfGbagpmpt
                          IF  .NOT. in_prompt('Did the Lumbar Bag Fill?')
                               = adD_err('0613')
                               RETURN .F.
                          ELSE
                               RETURN .T.
                          ENDIF
                     ELSE
                          RETURN .T.
                     ENDIF
                ENDIF
           ENDDO
           = swDsytimer(2)
           = adD_err('0606')
           = clEarpromp()
           RETURN .F.
      ENDIF
 ENDIF
 = clEarpromp()
 = swDaltimer()
 RETURN .F.
*
FUNCTION teStschukr
 PRIVATE l, inLoop, skIpcount, reL_time, goTit, stArttime, stOptime
 DIMENSION luMbar[ 10]
 = swDaltimer()
 m.r_Byte3 = 0
 m.r_Byte4 = 0
 m.reL_time = 10
 STORE .F. TO luMbar
 m.l = 0
 m.goTit = .F.
 m.goTit = .F.
 = laRge_prom('PRESS & HOLD LUMBAR *IN* SWITCH...',0)
 = swCrttimer(1,(swSecond*m.skIntime))
 DO WHILE swGtimer(1)>0
      IF baIlout()
           = adD_err('0000')
           EXIT
      ENDIF
      IF reAd_atod1()>=m.skStallcur
           luMbar[ 1] = .T.
           m.goTit = .F.
           = laRge_prom('RELEASE LUMBAR SWITCH...',1)
           = swCrttimer(2,swSecond*m.skRelease)
           DO WHILE swGtimer(2)>0
                IF baIlout()
                     = adD_err('0000')
                     EXIT
                ENDIF
                IF reAd_atod1()<=m.skRunmax
                     luMbar[ 2] = .T.
                     m.goTit = .T.
                     EXIT
                ENDIF
           ENDDO
           = swDsytimer(2)
           IF  .NOT. luMbar(2)
                = adD_err('0614')
                EXIT
           ELSE
                EXIT
           ENDIF
      ENDIF
 ENDDO
 = swDsytimer(1)
 IF  .NOT. luMbar(1)
      = adD_err('0603')
 ENDIF
 IF  .NOT. m.baIlout
      m.goTit = .F.
      = laRge_prom('PRESS & HOLD LUMBAR *OUT* SWITCH...',0)
      = swCrttimer(1,(swSecond*m.skOuttime))
      DO WHILE swGtimer(1)>0
           IF baIlout()
                = adD_err('0000')
                EXIT
           ENDIF
           IF reAd_atod1()>=m.skRunmax .AND.  .NOT. m.goTit
                m.stArttime = SECONDS()
                m.goTit = .T.
           ENDIF
           IF reAd_atod1()>m.skStallcur
                IF  .NOT. m.goTit
                     m.stArttime = SECONDS()
                ENDIF
                m.stOptime = SECONDS()
                IF (m.stOptime-m.stArttime)>m.skOuttime
                     = adD_err('0610')
                     luMbar[ 5] = .F.
                ELSE
                     luMbar[ 5] = .T.
                ENDIF
                luMbar[ 3] = .T.
                m.goTit = .F.
                = laRge_prom('RELEASE LUMBAR SWITCH...',1)
                = swCrttimer(2,swSecond*m.skRelease)
                DO WHILE swGtimer(2)>0
                     IF baIlout()
                          = adD_err('0000')
                          EXIT
                     ENDIF
                     IF reAd_atod1()<=m.skRunmax
                          m.goTit = .T.
                          luMbar[ 4] = .T.
                          EXIT
                     ENDIF
                ENDDO
                = swDsytimer(2)
                IF  .NOT. luMbar(4)
                     = adD_err('0610')
                     EXIT
                ELSE
                     EXIT
                ENDIF
           ENDIF
      ENDDO
      = swDsytimer(1)
      IF  .NOT. luMbar(3)
           = adD_err('0604')
      ENDIF
 ENDIF
 FOR m.l = 1 TO 5
      IF  .NOT. luMbar(m.l)
           = clEarpromp()
           RETURN .F.
      ENDIF
 ENDFOR
 = clEarpromp()
 RETURN .T.
*
FUNCTION teStheat
 PRIVATE heAtresult, heAtvalue
 m.heAtvalue = 0
 m.heAtresult = .T.
 WAIT WINDOW NOWAIT 'Testing Seatback Heat On...'
 = seNd_scp('RELAY09ON')
 = swCrttimer(5,0090)
 DO WHILE (swGtimer(5)>0)
      IF baIlout()
           = adD_err('0000')
           m.heAtresult = .F.
           EXIT
      ENDIF
 ENDDO
 = swDsytimer(5)
 m.heAtvalue = reAd_atod1()
 IF m.heAtvalue<m.heAt1 .OR. m.heAtvalue>m.heAt2
      = adD_err('0701')
      m.heAtresult = .F.
      IF m.viEwit
           ACTIVATE WINDOW viEwwin
           ? 'Failed Seatback on'
      ENDIF
 ENDIF
 IF  .NOT. m.baIlout
      WAIT WINDOW NOWAIT 'Testing Cushion Heat On...'
      = seNd_scp('RELAY10ON')
      = swCrttimer(5,0090)
      DO WHILE (swGtimer(5)>0)
           IF baIlout()
                m.heAtresult = .F.
                = adD_err('0000')
                EXIT
           ENDIF
      ENDDO
      = swDsytimer(5)
      m.heAtvalue = reAd_atod1()
      IF (m.heAtvalue)<m.heAt2 .OR. (m.heAtvalue)>m.heAt3
           = adD_err('0702')
           m.heAtresult = .F.
           IF m.viEwit
                ACTIVATE WINDOW viEwwin
                ? 'Failed Cushion on'
           ENDIF
      ENDIF
 ENDIF
 IF  .NOT. m.baIlout
      WAIT WINDOW NOWAIT 'Testing Cushion Heat Off...'
      = seNd_scp('RELAY10OFF')
      = swCrttimer(5,0090)
      DO WHILE (swGtimer(5)>0)
           IF baIlout()
                m.heAtresult = .F.
                = adD_err('0000')
                EXIT
           ENDIF
      ENDDO
      = swDsytimer(5)
      m.heAtvalue = reAd_atod1()
      IF (m.heAtvalue)<m.heAt1 .OR. (m.heAtvalue)>m.heAt2
           = adD_err('0703')
           m.heAtresult = .F.
           IF m.viEwit
                ACTIVATE WINDOW viEwwin
                ? 'Failed Cushion off'
           ENDIF
      ENDIF
 ENDIF
 IF  .NOT. m.baIlout
      WAIT WINDOW NOWAIT 'Testing Seatback Heat Off...'
      = seNd_scp('RELAY09OFF')
      = swCrttimer(5,0090)
      DO WHILE (swGtimer(5)>0)
           IF baIlout()
                m.heAtresult = .F.
                = adD_err('0000')
                EXIT
           ENDIF
      ENDDO
      = swDsytimer(5)
      m.heAtvalue = reAd_atod1()
      IF (m.heAtvalue)>m.heAtoff
           = adD_err('0704')
           m.heAtresult = .F.
           IF m.viEwit
                ACTIVATE WINDOW viEwwin
                ? 'Failed Seatback off'
           ENDIF
      ENDIF
      WAIT CLEAR
 ENDIF
 RETURN m.heAtresult
*
FUNCTION un93testhe
 PRIVATE heAtresult, heAtvalue, usEranswer
 m.heAtresult = .T.
 m.heAtvalue = 0
 m.usEranswer = .F.
 = swCrttimer(1,(swSecond*m.un93swtime))
 = laRge_prom('Cycle heat switch on...',0)
 DO WHILE swGtimer(1)>0
      IF baIlout()
           = adD_err('0000')
           EXIT
      ENDIF
      IF reAd_atod1()>0
           EXIT
      ENDIF
 ENDDO
 = swDsytimer(1)
 = swCrttimer(1,(swSecond*m.un93swtime))
 DO WHILE swGtimer(1)>0
      IF baIlout()
           = adD_err('0000')
           EXIT
      ENDIF
      IF  .NOT. in_prompt('Is the switch light indicator on?')
           = adD_err('0706')
           m.heAtresult = .F.
           EXIT
      ELSE
           WAIT WINDOW NOWAIT 'Cycling Heat On...'
           = un93hton()
           WAIT WINDOW NOWAIT 'Cushion Heat ON'
           = swCrttimer(5,(swSecond*m.un93httime))
           DO WHILE (swGtimer(5)>0)
                IF baIlout()
                     = adD_err('0000')
                     m.heAtresult = .F.
                     EXIT
                ENDIF
                m.heAtvalue = reAd_atod1()
                IF m.heAtvalue<m.un93htlow .OR. m.heAtvalue>m.un93hthigh
                     = adD_err('0707')
                     m.heAtresult = .F.
                     IF m.viEwit
                          ACTIVATE WINDOW viEwwin
                          ? 'Failed Heat on'
                          = un93htoff()
                          EXIT
                     ENDIF
                ELSE
                     m.heAtresult = .T.
                ENDIF
           ENDDO
           = swDsytimer(5)
           IF  .NOT. m.heAtresult
                EXIT
           ENDIF
           = swDsytimer(1)
           = swDsytimer(5)
           = swCrttimer(1,(swSecond*m.un93swtime))
           = laRge_prom('Cycle heat switch off...',0)
           DO WHILE swGtimer(1)>0
                IF baIlout()
                     = adD_err('0000')
                     EXIT
                ENDIF
                IF reAd_atod1()=0
                     EXIT
                ENDIF
           ENDDO
           = swDsytimer(1)
           = swCrttimer(1,(swSecond*m.un93swtime))
           DO WHILE swGtimer(1)>0
                IF baIlout()
                     = adD_err('0000')
                     EXIT
                ENDIF
                IF  .NOT. in_prompt('Is the switch light indicator off?')
                     = adD_err('0706')
                     m.heAtresult = .F.
                     EXIT
                ELSE
                     WAIT WINDOW NOWAIT 'Cycling Heat Off...'
                     = un93htoff()
                     WAIT WINDOW NOWAIT 'Testing Cushion Heat Off...'
                     = swCrttimer(5,(swSecond*m.un93httime))
                     DO WHILE (swGtimer(5)>0)
                          IF baIlout()
                               = adD_err('0000')
                               m.heAtresult = .F.
                               EXIT
                          ENDIF
                          m.heAtvalue = reAd_atod1()
                          IF m.heAtvalue<>0
                               = adD_err('0703')
                               m.heAtresult = .F.
                               IF m.viEwit
                                    ACTIVATE WINDOW viEwwin
                                    ? 'Failed Heat off'
                                    = un93htoff()
                                    EXIT
                               ENDIF
                          ELSE
                               m.heAtresult = .T.
                          ENDIF
                     ENDDO
                     = swDsytimer(5)
                     IF  .NOT. m.heAtresult
                          EXIT
                     ENDIF
                ENDIF
           ENDDO
           IF  .NOT. m.heAtresult
                EXIT
           ENDIF
      ENDIF
 ENDDO
 = swDsytimer(1)
 = swDsytimer(5)
 WAIT CLEAR
 RETURN m.heAtresult
*
FUNCTION heAtdetect
 PRIVATE heAtresult, heAtvalue
 m.heAtvalue = 0
 m.heAtresult = .F.
 WAIT WINDOW NOWAIT 'Checking for presence of heat module...'
 = seNd_scp('RELAY09ON')
 = seNd_scp('RELAY10ON')
 = swCrttimer(5,0090)
 DO WHILE (swGtimer(5)>0)
      IF baIlout()
           = adD_err('0000')
           m.heAtresult = .F.
           EXIT
      ENDIF
 ENDDO
 = swDsytimer(5)
 m.heAtvalue = reAd_atod1()
 IF (m.heAtvalue)>m.heAtoff
      = adD_err('0705')
      m.heAtresult = .T.
      IF m.viEwit
           ACTIVATE WINDOW viEwwin
           ? 'ERROR: Heat module detected'
      ENDIF
 ENDIF
 WAIT WINDOW NOWAIT 'Exiting heat test...'
 = seNd_scp('RELAY10OFF')
 = seNd_scp('RELAY09OFF')
 = swCrttimer(5,0090)
 DO WHILE (swGtimer(5)>0)
      IF baIlout()
           m.heAtresult = .F.
           = adD_err('0000')
           EXIT
      ENDIF
 ENDDO
 = swDsytimer(5)
 WAIT CLEAR
 RETURN m.heAtresult
*
FUNCTION teStroft
 PRIVATE teSt_resul
 m.teSt_resul = .T.
 WAIT WINDOW NOWAIT 'Testing Rate-of-Travel...'
 DO boX_cycle
 = adD_err('1001')
 m.teSt_resul = .F.
 RETURN m.teSt_resul
*
FUNCTION teStbelt
 DO WHILE (geTscp()=-129)
 ENDDO
 IF seNd_scp('PORT00IN')
      IF geTscp()=0
           IF swBitand(m.r_Byte3,21)=0
                = laRge_prom('REMOVE SEAT BELT BUCKLE...',1)
                = swCrttimer(1,(swSecond*m.op_sbout))
                DO WHILE swGtimer(1)>0
                     IF baIlout()
                          = adD_err('0000')
                          EXIT
                     ENDIF
                     IF geTscp()=0
                          IF swBitand(m.r_Byte3,21)=1 .OR.  ;
                             swBitand(m.r_Byte3,21)=4 .OR.  ;
                             swBitand(m.r_Byte3,21)=16
                               EXIT
                          ENDIF
                     ENDIF
                ENDDO
                = swDsytimer(1)
           ENDIF
      ENDIF
 ENDIF
 IF swBitand(m.r_Byte3,21)=0
      = adD_err('1101')
      = clEarpromp()
      RETURN .F.
 ENDIF
 IF  .NOT. m.baIlout
      = laRge_prom('INSERT SEAT BELT BUCKLE...',0)
      = swCrttimer(1,(swSecond*m.op_sbin))
      DO WHILE swGtimer(1)>0
           IF baIlout()
                = adD_err('0000')
                EXIT
           ENDIF
           IF geTscp()=0
                IF swBitand(m.r_Byte3,21)=0
                     = laRge_prom('REMOVE SEAT BELT BUCKLE...',1)
                     = swCrttimer(2,(swSecond*m.op_sbout))
                     DO WHILE swGtimer(2)>0
                          IF baIlout()
                               = adD_err('0000')
                               EXIT
                          ENDIF
                          IF geTscp()=0
                               IF swBitand(m.r_Byte3,21)=1 .OR.  ;
                                  swBitand(m.r_Byte3,21)=4 .OR.  ;
                                  swBitand(m.r_Byte3,21)=16
                                    = swDsytimer(1)
                                    = swDsytimer(2)
                                    = clEarpromp()
                                    RETURN .T.
                               ENDIF
                          ENDIF
                     ENDDO
                     = swDsytimer(1)
                     = swDsytimer(2)
                     = adD_err('1101')
                     = clEarpromp()
                     RETURN .F.
                ENDIF
           ENDIF
      ENDDO
      = swDsytimer(1)
      = swDsytimer(2)
      = adD_err('1102')
      WAIT CLEAR
      = clEarpromp()
 ENDIF
 RETURN .F.
*
FUNCTION teStoccup
 = laRge_prom('PRESS CUSHION...',0)
 = swCrttimer(1,(swSecond*m.op_cushpr))
 DO WHILE swGtimer(1)>0
      IF baIlout()
           = adD_err('0000')
           EXIT
      ENDIF
      IF geTscp()=0
           IF swBitand(m.r_Byte3,42)=2 .OR. swBitand(m.r_Byte3,42)=8 .OR.  ;
              swBitand(m.r_Byte3,42)=32
                = laRge_prom('STOP PRESSING CUSHION...',1)
                = swCrttimer(2,(swSecond*m.op_cushrel))
                DO WHILE swGtimer(2)>0
                     IF baIlout()
                          = adD_err('0000')
                          EXIT
                     ENDIF
                     IF geTscp()=0
                          IF swBitand(m.r_Byte3,42)=0
                               = swDsytimer(2)
                               = swDsytimer(1)
                               = clEarpromp()
                               RETURN .T.
                          ENDIF
                     ENDIF
                ENDDO
                = swDsytimer(1)
                = swDsytimer(2)
                = adD_err('1201')
                WAIT CLEAR
                = clEarpromp()
                RETURN .F.
           ENDIF
      ENDIF
 ENDDO
 = swDsytimer(1)
 = swDsytimer(2)
 = adD_err('1202')
 WAIT CLEAR
 = clEarpromp()
 RETURN .F.
*
FUNCTION teStphone
 PRIVATE teSt_resul
 m.teSt_resul = in_prompt('Did the Telephone Work?')
 IF  .NOT. m.teSt_resul
      = adD_err('1301')
 ENDIF
 RETURN m.teSt_resul
*
FUNCTION teStpowerp
 PRIVATE teSt_resul
 m.teSt_resul = in_prompt('Did the Power Point Work?')
 IF  .NOT. m.teSt_resul
      = adD_err('1301')
 ENDIF
 RETURN m.teSt_resul
*
FUNCTION seNd_iso
 PARAMETER meSs
 PRIVATE i, j, k
 DIMENSION heAdarray[ 3]
 DIMENSION thEadarray[ 3]
 DIMENSION daTaarray[ 7]
 DIMENSION tdAtaarray[ 7]
 DIMENSION meSsarray[ 11]
 STORE '' TO thEadarray, tdAtaarray
 STORE 0 TO heAdarray, daTaarray
 STORE '' TO meSsarray
 m.i = 0
 m.j = 0
 m.k = 0
 SELECT 0
 USE NOUPDATE (m.ciSo_mess) ALIAS isO_mess ORDER MESSAGENO
 IF SEEK(UPPER(ALLTRIM(m.meSs)), 'ISO_MESS')
      SELECT isO_mess
      SCATTER TO thEadarray FIELDS prIor_type, taRget
      SCATTER TO tdAtaarray FIELDS byTe1, byTe2, byTe3, byTe4, byTe5,  ;
              byTe6, byTe7
      heAdarray[ 1] = coNvert(thEadarray(1))
      heAdarray[ 2] = coNvert(thEadarray(2))
      daTaarray[ 1] = coNvert(tdAtaarray(1))
      daTaarray[ 2] = coNvert(tdAtaarray(2))
      daTaarray[ 3] = coNvert(tdAtaarray(3))
      daTaarray[ 4] = coNvert(tdAtaarray(4))
      daTaarray[ 5] = coNvert(tdAtaarray(5))
      daTaarray[ 6] = coNvert(tdAtaarray(6))
      daTaarray[ 7] = coNvert(tdAtaarray(7))
      meSsarray = meSsarray+CHR(heAdarray(1))
      meSsarray = meSsarray+CHR(heAdarray(2))
      meSsarray = meSsarray+CHR(coNvert(m.soUrce))
      FOR m.i = 1 TO isO_mess.nuMofbytes
           meSsarray = meSsarray+CHR(daTaarray(m.i))
      ENDFOR
      meSsarray = meSsarray+CHR(chKsum(meSsarray,3+m.i))
      DIMENSION meSsarray[ 3+m.i]
 ELSE
      = swRingbell()
      WAIT WINDOW NOWAIT 'ISO-9141 Message Not Found in ISO-9141 Database!'
      USE IN isO_mess
      RETURN .F.
 ENDIF
 = swFlushrx(coM1)
 = swTxbuffer(coM1,meSsarray)
 USE IN isO_mess
 RETURN .T.
*
FUNCTION chKsum
 PARAMETER teMparray, meSsbytes
 PRIVATE i, chEcksum
 m.i = 0
 m.chEcksum = 0
 FOR m.i = 1 TO m.meSsbytes
      m.chEcksum = m.chEcksum+ASC(SUBSTR(teMparray, m.i, 1))
 ENDFOR
 RETURN swBitand(m.chEcksum,255)
*
FUNCTION coNvert
 PARAMETER heX
 PRIVATE vaLue, l, r
 m.vaLue = 0
 m.l = 0
 m.r = 0
 IF  .NOT. EMPTY(m.heX)
      DO CASE
           CASE UPPER(LEFT(heX, 1))='A'
                m.l = 00160
           CASE UPPER(LEFT(heX, 1))='B'
                m.l = 00176
           CASE UPPER(LEFT(heX, 1))='C'
                m.l = 00192
           CASE UPPER(LEFT(heX, 1))='D'
                m.l = 00208
           CASE UPPER(LEFT(heX, 1))='E'
                m.l = 00224
           CASE UPPER(LEFT(heX, 1))='F'
                m.l = 00240
           OTHERWISE
                m.l = VAL(LEFT(heX, 1))*16
      ENDCASE
      DO CASE
           CASE UPPER(RIGHT(heX, 1))='A'
                m.r = 10
           CASE UPPER(RIGHT(heX, 1))='B'
                m.r = 11
           CASE UPPER(RIGHT(heX, 1))='C'
                m.r = 12
           CASE UPPER(RIGHT(heX, 1))='D'
                m.r = 13
           CASE UPPER(RIGHT(heX, 1))='E'
                m.r = 14
           CASE UPPER(RIGHT(heX, 1))='F'
                m.r = 15
           OTHERWISE
                m.r = VAL(RIGHT(heX, 1))
      ENDCASE
      m.vaLue = m.r+m.l
 ELSE
      m.vaLue = 0
 ENDIF
 RETURN m.vaLue
*
FUNCTION geTisoresp
 PARAMETER poRt
 PRIVATE chArcount
 PUSH KEY CLEAR
 m.chArcount = 0
 STORE 0 TO rxMessage
 = swCrttimer(1,15)
 DO WHILE swGtimer(1)>0
      IF  .NOT. swRxempty(m.poRt)
           m.chArcount = m.chArcount+1
           rxMessage[ m.chArcount] = swRxchar(m.poRt)
           = swRestrttm(1,2)
      ENDIF
 ENDDO
 IF m.chArcount=0
      WAIT CLEAR
      = swRingbell()
      WAIT WINDOW TIMEOUT 3 'No Response from Module !'+CHR(13)+ ;
           'Check Cable Connections.'
      = swDsytimer(1)
      POP KEY
      RETURN .F.
 ENDIF
 = swDsytimer(1)
 POP KEY
 RETURN .T.
*
FUNCTION seNd_scp
 PARAMETER msG
 IF scP_mess.meSsageno=m.msG
      SELECT scP_mess
      SCATTER MEMVAR
      = seNdscp(m.prIor_type,m.taRget,m.nuMofbytes,m.byTe1+m.byTe2+ ;
        m.byTe3+m.byTe4+m.byTe5+m.byTe6+m.byTe7)
 ELSE
      IF SEEK(UPPER(ALLTRIM(msG)), 'SCP_MESS')
           SELECT scP_mess
           SCATTER MEMVAR
           = seNdscp(m.prIor_type,m.taRget,m.nuMofbytes,m.byTe1+m.byTe2+ ;
             m.byTe3+m.byTe4+m.byTe5+m.byTe6+m.byTe7)
      ELSE
           = swRingbell()
           WAIT WINDOW NOWAIT 'SCP Message '+msG+ ;
                ' Not Found in Message Database !'
           USE IN scP_mess
           RETURN .F.
      ENDIF
 ENDIF
 RETURN .T.
*
PROCEDURE boX_cycle
 PRIVATE keY
 PUSH KEY CLEAR
 m.poInt1 = .F.
 m.poInt2 = .F.
 m.poInt3 = .F.
 m.poInt4 = .F.
 m.tiMe_hf = 0.0
 m.tiMe_hr = 0.0
 m.tiMe_fu = 0.0
 m.tiMe_fd = 0.0
 m.tiMe_bu = 0.0
 m.tiMe_bd = 0.0
 m.tiMe_rf = 0.0
 m.tiMe_rr = 0.0
 m.roT_hf = 0.0
 m.roT_hr = 0.0
 m.roT_fu = 0.0
 m.roT_fd = 0.0
 m.roT_bu = 0.0
 m.roT_bd = 0.0
 m.roT_rf = 0.0
 m.roT_rr = 0.0
 SHOW GETS
 DO WHILE (geTscp()<>-130)
 ENDDO
 IF  .NOT. m.baIlout
      WAIT WINDOW NOWAIT 'Horizontal Forward...'
      = moVeloop(7)
 ENDIF
 IF  .NOT. m.baIlout
      WAIT WINDOW NOWAIT 'Recline Forward...'
      = swWait(4)
      = moVeloop(5)
 ENDIF
 IF  .NOT. m.baIlout
      WAIT WINDOW NOWAIT 'Front Up...'
      = swWait(4)
      = moVeloop(1)
 ENDIF
 IF  .NOT. m.baIlout
      WAIT WINDOW NOWAIT 'Back Up...'
      = swWait(4)
      = moVeloop(3)
      m.poInt1 = .T.
      SHOW GETS
 ENDIF
 IF  .NOT. m.baIlout
      WAIT WINDOW NOWAIT 'Horizontal Rearward...'
      = swWait(4)
      m.tiMe_hr = moVeloop(8)
      m.roT_hr = m.h_Travel/m.tiMe_hr
      SHOW GETS
 ENDIF
 IF  .NOT. m.baIlout
      WAIT WINDOW NOWAIT 'Recline Rearward...'
      = swWait(4)
      m.tiMe_rr = moVeloop(6)
      m.roT_rr = m.r_Travel/m.tiMe_rr
      m.poInt2 = .T.
      SHOW GETS
 ENDIF
 IF  .NOT. m.baIlout
      WAIT WINDOW NOWAIT 'Front Down...'
      = swWait(4)
      m.tiMe_fd = moVeloop(2)
      m.roT_fd = m.f_Travel/m.tiMe_fd
      SHOW GETS
 ENDIF
 IF  .NOT. m.baIlout
      WAIT WINDOW NOWAIT 'Back Down...'
      = swWait(4)
      m.tiMe_bd = moVeloop(4)
      m.roT_bd = m.b_Travel/m.tiMe_bd
      m.poInt3 = .T.
      SHOW GETS
 ENDIF
 IF  .NOT. m.baIlout
      WAIT WINDOW NOWAIT 'Horizontal Forward...'
      = swWait(4)
      m.tiMe_hf = moVeloop(7)
      m.roT_hf = m.h_Travel/m.tiMe_hf
      SHOW GETS
 ENDIF
 IF  .NOT. m.baIlout
      WAIT WINDOW NOWAIT 'Recline Forward...'
      = swWait(4)
      m.tiMe_rf = moVeloop(5)
      m.roT_rf = m.r_Travel/m.tiMe_rf
      m.poInt4 = .T.
      SHOW GETS
 ENDIF
 IF  .NOT. m.baIlout
      WAIT WINDOW NOWAIT 'Front Up...'
      = swWait(4)
      m.tiMe_fu = moVeloop(1)
      m.roT_fu = m.f_Travel/m.tiMe_fu
      SHOW GETS
 ENDIF
 IF  .NOT. m.baIlout
      WAIT WINDOW NOWAIT 'Back Up...'
      = swWait(4)
      m.tiMe_bu = moVeloop(3)
      m.roT_bu = m.b_Travel/m.tiMe_bu
      SHOW GETS
 ENDIF
 WAIT CLEAR
 POP KEY
 RETURN
*
PROCEDURE shIpmstng
 PRIVATE stArttime, stOptime
 m.stArttime = SECONDS()
 m.txT0 = 'MOVE SEAT TO SHIPPING POSITION...'
 m.txT1 = '                          '
 m.txT2 = 'LINE REAR OF TRACK UP WITH 2nd WINDOW'
 m.txT3 = ' '
 m.txT4 = ' '
 = tiMeprompt(txT0,txT1,txT2,txT3,txT4,60)
 RETURN
*
PROCEDURE shIpit
 PRIVATE stArttime, stOptime
 m.stArttime = SECONDS()
 IF UPPER(ALLTRIM(m.moDuletype))='NONE2'
      IF  .NOT. teSt_lvl(19)
           m.txT0 = 'MOVE SEAT TO SHIPPING POSITION...'
           m.txT1 = 'FRONT TILT: DOWN 5 SECONDS'
           m.txT2 = 'REAR TILT: FULL UPWARD'
           m.txT3 = 'HORIZ:LINE REAR OF SHIELD UP WITH TAB'
           m.txT4 = ' '
           = tiMeprompt(txT0,txT1,txT2,txT3,txT4,60)
      ENDIF
 ELSE
      WAIT WINDOW NOWAIT 'Moving Seat to Shipping Position...'
      = baIlout()
      IF teSt_lvl(5) .AND.  .NOT. m.baIlout
           IF m.viEwit
                ACTIVATE WINDOW viEwwin
                ? 'Moving Recline...'
           ENDIF
           IF ((UPPER(ALLTRIM(m.moDuletype))='NONE' .OR.  ;
              UPPER(ALLTRIM(m.moDuletype))='NONE2') .AND. (teSt_lvl(14)  ;
              .OR. teSt_lvl(15)))
                = laRge_prom('MOVE RECLINE TO SHIPPING POSITION...',0)
                = swWait(swSecond*m.op_reclshp)
                = clEarpromp()
           ELSE
                IF m.cfGrshippo=1
                     = moVeloop(5)
                     = baIlout()
                     IF  .NOT. m.baIlout
                          IF m.cfGdvrside=1 .AND.  ;
                             UPPER(ALLTRIM(m.moDuletype))<>'FN-74' .AND.  ;
                             UPPER(ALLTRIM(m.moDuletype))<>'FN-145'
                               = moVestep(6,m.r_Time)
                          ELSE
                               = moVetime(6,m.r_Time)
                          ENDIF
                     ENDIF
                ELSE
                     = moVeloop(6)
                     = baIlout()
                     IF  .NOT. m.baIlout
                          IF m.cfGdvrside=1 .AND.  ;
                             UPPER(ALLTRIM(m.moDuletype))<>'FN-74' .AND.  ;
                             UPPER(ALLTRIM(m.moDuletype))<>'FN-145'
                               = moVestep(5,m.r_Time)
                          ELSE
                               = moVetime(5,m.r_Time)
                          ENDIF
                     ENDIF
                ENDIF
                = swWait(1)
           ENDIF
      ENDIF
      = baIlout()
      IF teSt_lvl(4) .AND.  .NOT. m.baIlout
           IF m.viEwit
                ACTIVATE WINDOW viEwwin
                ? 'Moving Horizontal...'
           ENDIF
           IF m.cfGhshippo=1
                = moVeloop(7)
                = baIlout()
                IF  .NOT. m.baIlout
                     IF m.cfGdvrside=1 .AND. UPPER(ALLTRIM(m.moDuletype))<> ;
                        'FN-74' .AND. (UPPER(ALLTRIM(m.moDuletype))<> ;
                        'NONE' .OR. UPPER(ALLTRIM(m.moDuletype))='NONE2')  ;
                        .AND. UPPER(ALLTRIM(m.moDuletype))<>'FN-145'
                          = moVestep(8,m.h_Time)
                     ELSE
                          = moVetime(8,m.h_Time)
                     ENDIF
                ENDIF
           ELSE
                = moVeloop(8)
                = baIlout()
                IF  .NOT. m.baIlout
                     IF m.cfGdvrside=1 .AND. UPPER(ALLTRIM(m.moDuletype))<> ;
                        'FN-74' .AND. (UPPER(ALLTRIM(m.moDuletype))<> ;
                        'NONE' .OR. UPPER(ALLTRIM(m.moDuletype))='NONE2')  ;
                        .AND. UPPER(ALLTRIM(m.moDuletype))<>'FN-145'
                          = moVestep(7,m.h_Time)
                     ELSE
                          = moVetime(7,m.h_Time)
                     ENDIF
                ENDIF
           ENDIF
           = swWait(1)
      ENDIF
      = baIlout()
      IF teSt_lvl(2) .AND.  .NOT. m.baIlout
           IF m.viEwit
                ACTIVATE WINDOW viEwwin
                ? 'Moving Front...'
           ENDIF
           IF m.cfGfshippo=1
                = moVeloop(1)
                = baIlout()
                IF  .NOT. m.baIlout
                     IF m.cfGdvrside=1 .AND. UPPER(ALLTRIM(m.moDuletype))<> ;
                        'FN-74' .AND. (UPPER(ALLTRIM(m.moDuletype))<> ;
                        'NONE' .OR. UPPER(ALLTRIM(m.moDuletype))='NONE2')  ;
                        .AND. UPPER(ALLTRIM(m.moDuletype))<>'FN-145'
                          = moVestep(2,m.f_Time)
                     ELSE
                          = moVetime(2,m.f_Time)
                     ENDIF
                ENDIF
           ELSE
                = moVeloop(2)
                = baIlout()
                IF  .NOT. m.baIlout
                     IF m.cfGdvrside=1 .AND. UPPER(ALLTRIM(m.moDuletype))<> ;
                        'FN-74' .AND. (UPPER(ALLTRIM(m.moDuletype))<> ;
                        'NONE' .OR. UPPER(ALLTRIM(m.moDuletype))='NONE2')  ;
                        .AND. UPPER(ALLTRIM(m.moDuletype))<>'FN-145'
                          = moVestep(1,m.f_Time)
                     ELSE
                          = moVetime(1,m.f_Time)
                     ENDIF
                ENDIF
           ENDIF
           = swWait(1)
      ENDIF
      = baIlout()
      IF teSt_lvl(3) .AND.  .NOT. baIlout()
           IF m.viEwit
                ACTIVATE WINDOW viEwwin
                ? 'Moving Rear...'
           ENDIF
           IF m.cfGbshippo=1
                = moVeloop(3)
                = baIlout()
                IF  .NOT. m.baIlout
                     IF m.cfGdvrside=1 .AND. UPPER(ALLTRIM(m.moDuletype))<> ;
                        'FN-74' .AND. (UPPER(ALLTRIM(m.moDuletype))<> ;
                        'NONE' .OR. UPPER(ALLTRIM(m.moDuletype))='NONE2')  ;
                        .AND. UPPER(ALLTRIM(m.moDuletype))<>'FN-145'
                          = moVestep(4,m.b_Time)
                     ELSE
                          = moVetime(4,m.b_Time)
                     ENDIF
                ENDIF
           ELSE
                = moVeloop(4)
                = baIlout()
                IF  .NOT. m.baIlout
                     IF m.cfGdvrside=1 .AND. UPPER(ALLTRIM(m.moDuletype))<> ;
                        'FN-74' .AND. (UPPER(ALLTRIM(m.moDuletype))<> ;
                        'NONE' .OR. UPPER(ALLTRIM(m.moDuletype))='NONE2')  ;
                        .AND. UPPER(ALLTRIM(m.moDuletype))<>'FN-145'
                          = moVestep(3,m.b_Time)
                     ELSE
                          = moVetime(3,m.b_Time)
                     ENDIF
                ENDIF
           ENDIF
           = swWait(1)
      ENDIF
 ENDIF
 m.stOptime = SECONDS()
 IF m.stOptime>=m.stArttime
      m.shIp_time = stOptime-m.stArttime
 ELSE
      m.shIp_time = 86400-stArttime+m.stOptime
 ENDIF
 RETURN
*
FUNCTION moVeloop
 PARAMETER chOice
 PRIVATE nkEy, stArttime, stOptime, loOptime, i
 m.baIlout = .F.
 m.stArttime = 0
 m.stOptime = 0
 m.stArttime = SECONDS()
 DO CASE
      CASE UPPER(ALLTRIM(m.moDuletype))='NONE' .OR.  ;
           UPPER(ALLTRIM(m.moDuletype))='NONE2' .OR. m.cfGdvrside=2
           DO CASE
                CASE m.chOice=1
                     = seNd_scp('RELAY01OFF')
                     = seNd_scp('RELAY02ON')
                     = swWait(2)
                     = swCrttimer(1,(swSecond*m.frOnstall))
                     DO WHILE swGtimer(1)>0
                          IF baIlout()
                               EXIT
                          ENDIF
                          IF stAll(m.frUpstall)
                               EXIT
                          ENDIF
                     ENDDO
                     = swDsytimer(1)
                     = seNd_scp('RELAY01OFF')
                     = seNd_scp('RELAY02OFF')
                CASE m.chOice=2
                     = seNd_scp('RELAY01ON')
                     = seNd_scp('RELAY02OFF')
                     = swWait(2)
                     = swCrttimer(1,(swSecond*m.frOnstall))
                     DO WHILE swGtimer(1)>0
                          IF baIlout()
                               EXIT
                          ENDIF
                          IF stAll(m.frDnstall)
                               EXIT
                          ENDIF
                     ENDDO
                     = swDsytimer(1)
                     = seNd_scp('RELAY01OFF')
                     = seNd_scp('RELAY02OFF')
                CASE m.chOice=3
                     = seNd_scp('RELAY05ON')
                     = seNd_scp('RELAY06OFF')
                     = swWait(2)
                     = swCrttimer(1,(swSecond*m.baCkstall))
                     DO WHILE swGtimer(1)>0
                          IF baIlout()
                               EXIT
                          ENDIF
                          IF stAll(m.bkUpstall)
                               EXIT
                          ENDIF
                     ENDDO
                     = swDsytimer(1)
                     = seNd_scp('RELAY05OFF')
                     = seNd_scp('RELAY06OFF')
                CASE m.chOice=4
                     = seNd_scp('RELAY06ON')
                     = seNd_scp('RELAY05OFF')
                     = swWait(2)
                     = swCrttimer(1,(swSecond*m.baCkstall))
                     DO WHILE swGtimer(1)>0
                          IF baIlout()
                               EXIT
                          ENDIF
                          IF stAll(m.bkDnstall)
                               EXIT
                          ENDIF
                     ENDDO
                     = swDsytimer(1)
                     = seNd_scp('RELAY06OFF')
                     = seNd_scp('RELAY05OFF')
                CASE m.chOice=5
                     = seNd_scp('RELAY07ON')
                     = seNd_scp('RELAY08OFF')
                     = swWait(2)
                     = swCrttimer(1,(swSecond*m.reClstall))
                     DO WHILE swGtimer(1)>0
                          IF baIlout()
                               EXIT
                          ENDIF
                          IF stAll(m.reFwstall)
                               EXIT
                          ENDIF
                     ENDDO
                     = swDsytimer(1)
                     = seNd_scp('RELAY07OFF')
                     = seNd_scp('RELAY08OFF')
                CASE m.chOice=6
                     = seNd_scp('RELAY08ON')
                     = seNd_scp('RELAY07OFF')
                     = swWait(2)
                     = swCrttimer(1,(swSecond*m.reClstall))
                     DO WHILE swGtimer(1)>0
                          IF baIlout()
                               EXIT
                          ENDIF
                          IF stAll(m.reBkstall)
                               EXIT
                          ENDIF
                     ENDDO
                     = swDsytimer(1)
                     = seNd_scp('RELAY08OFF')
                     = seNd_scp('RELAY07OFF')
                CASE m.chOice=7
                     = seNd_scp('RELAY03ON')
                     = seNd_scp('RELAY04OFF')
                     = swWait(2)
                     = swCrttimer(1,(swSecond*m.hoRistall))
                     DO WHILE swGtimer(1)>0
                          IF baIlout()
                               EXIT
                          ENDIF
                          IF stAll(m.hoFwstall)
                               EXIT
                          ENDIF
                     ENDDO
                     = swDsytimer(1)
                     = seNd_scp('RELAY03OFF')
                     = seNd_scp('RELAY04OFF')
                CASE m.chOice=8
                     = seNd_scp('RELAY04ON')
                     = seNd_scp('RELAY03OFF')
                     = swWait(2)
                     = swCrttimer(1,(swSecond*m.hoRistall))
                     DO WHILE swGtimer(1)>0
                          IF baIlout()
                               EXIT
                          ENDIF
                          IF stAll(m.hoBkstall)
                               EXIT
                          ENDIF
                     ENDDO
                     = swDsytimer(1)
                     = seNd_scp('RELAY04OFF')
                     = seNd_scp('RELAY03OFF')
           ENDCASE
      CASE UPPER(ALLTRIM(m.moDuletype))='FN-116'
           = seNd_iso('D0')
           = swWait(3)
           m.stArttime = SECONDS()
           DO CASE
                CASE m.chOice=1
                     = swCrttimer(1,(swSecond*m.frOnstall))
                     DO WHILE swGtimer(1)>0
                          = frOntmove(1)
                          IF stAll(m.frUpstall)
                               EXIT
                          ENDIF
                          IF baIlout()
                               EXIT
                          ENDIF
                     ENDDO
                     = swDsytimer(1)
                CASE m.chOice=2
                     = swCrttimer(1,(swSecond*m.frOnstall))
                     DO WHILE swGtimer(1)>0
                          = frOntmove(2)
                          IF stAll(m.frDnstall)
                               EXIT
                          ENDIF
                          IF baIlout()
                               EXIT
                          ENDIF
                     ENDDO
                     = swDsytimer(1)
                CASE m.chOice=3
                     = swCrttimer(1,(swSecond*m.baCkstall))
                     DO WHILE swGtimer(1)>0
                          = baCkmove(1)
                          IF stAll(m.bkUpstall)
                               EXIT
                          ENDIF
                          IF baIlout()
                               EXIT
                          ENDIF
                     ENDDO
                     = swDsytimer(1)
                CASE m.chOice=4
                     = swCrttimer(1,(swSecond*m.baCkstall))
                     DO WHILE swGtimer(1)>0
                          = baCkmove(2)
                          IF stAll(m.bkDnstall)
                               EXIT
                          ENDIF
                          IF baIlout()
                               EXIT
                          ENDIF
                     ENDDO
                     = swDsytimer(1)
                CASE m.chOice=5
                     = swCrttimer(1,(swSecond*m.reClstall))
                     DO WHILE swGtimer(1)>0
                          = reClmove(1)
                          IF stAll(m.reFwstall)
                               EXIT
                          ENDIF
                          IF baIlout()
                               EXIT
                          ENDIF
                     ENDDO
                     = swDsytimer(1)
                CASE m.chOice=6
                     = swCrttimer(1,(swSecond*m.reClstall))
                     DO WHILE swGtimer(1)>0
                          = reClmove(2)
                          IF stAll(m.reBkstall)
                               EXIT
                          ENDIF
                          IF baIlout()
                               EXIT
                          ENDIF
                     ENDDO
                     = swDsytimer(1)
                CASE m.chOice=7
                     = swCrttimer(1,(swSecond*m.hoRistall))
                     DO WHILE swGtimer(1)>0
                          = hoRizmove(1)
                          IF stAll(m.hoFwstall)
                               EXIT
                          ENDIF
                          IF baIlout()
                               EXIT
                          ENDIF
                     ENDDO
                     = swDsytimer(1)
                CASE m.chOice=8
                     = swCrttimer(1,(swSecond*m.hoRistall))
                     DO WHILE swGtimer(1)>0
                          = hoRizmove(2)
                          IF stAll(m.hoBkstall)
                               EXIT
                          ENDIF
                          IF baIlout()
                               EXIT
                          ENDIF
                     ENDDO
                     = swDsytimer(1)
           ENDCASE
      CASE UPPER(ALLTRIM(m.moDuletype))='FN-74'
           m.stArttime = SECONDS()
           DO CASE
                CASE m.chOice=1
                     = swCrttimer(1,(swSecond*m.frOnstall))
                     = swCrttimer(2,24)
                     DO WHILE swGtimer(2)>0
                          IF baIlout()
                               EXIT
                          ENDIF
                          = frOntmove(1)
                     ENDDO
                     = swDsytimer(2)
                     IF  .NOT. m.baIlout
                          DO WHILE swGtimer(1)>0
                               = frOntmove(1)
                               IF stAll1()
                                    EXIT
                               ENDIF
                          ENDDO
                     ENDIF
                     = swDsytimer(1)
                CASE m.chOice=2
                     = swCrttimer(1,(swSecond*m.frOnstall))
                     = swCrttimer(2,24)
                     DO WHILE swGtimer(2)>0
                          IF baIlout()
                               EXIT
                          ENDIF
                          = frOntmove(2)
                     ENDDO
                     = swDsytimer(2)
                     IF  .NOT. m.baIlout
                          DO WHILE swGtimer(1)>0
                               = frOntmove(2)
                               IF stAll1()
                                    EXIT
                               ENDIF
                          ENDDO
                     ENDIF
                     = swDsytimer(1)
                CASE m.chOice=3
                     = swCrttimer(1,(swSecond*m.baCkstall))
                     = swCrttimer(2,24)
                     DO WHILE swGtimer(2)>0
                          IF baIlout()
                               EXIT
                          ENDIF
                          = baCkmove(1)
                     ENDDO
                     = swDsytimer(2)
                     IF  .NOT. m.baIlout
                          DO WHILE swGtimer(1)>0
                               = baCkmove(1)
                               IF stAll1()
                                    EXIT
                               ENDIF
                          ENDDO
                     ENDIF
                     = swDsytimer(1)
                CASE m.chOice=4
                     = swCrttimer(1,(swSecond*m.baCkstall))
                     = swCrttimer(2,24)
                     DO WHILE swGtimer(2)>0
                          IF baIlout()
                               EXIT
                          ENDIF
                          = baCkmove(2)
                     ENDDO
                     = swDsytimer(2)
                     IF  .NOT. m.baIlout
                          DO WHILE swGtimer(1)>0
                               = baCkmove(2)
                               IF stAll1()
                                    EXIT
                               ENDIF
                          ENDDO
                     ENDIF
                     = swDsytimer(1)
                CASE m.chOice=5
                     = swCrttimer(1,(swSecond*m.reClstall))
                     = swCrttimer(2,72)
                     DO WHILE swGtimer(2)>0
                          IF baIlout()
                               EXIT
                          ENDIF
                          = reClmove(1)
                     ENDDO
                     = swDsytimer(2)
                     IF  .NOT. m.baIlout
                          DO WHILE swGtimer(1)>0
                               = reClmove(1)
                               IF stAll1()
                                    EXIT
                               ENDIF
                          ENDDO
                     ENDIF
                     = swDsytimer(1)
                CASE m.chOice=6
                     = swCrttimer(1,(swSecond*m.reClstall))
                     = swCrttimer(2,72)
                     DO WHILE swGtimer(2)>0
                          IF baIlout()
                               EXIT
                          ENDIF
                          = reClmove(2)
                     ENDDO
                     = swDsytimer(2)
                     IF  .NOT. m.baIlout
                          DO WHILE swGtimer(1)>0
                               = reClmove(2)
                               IF stAll1()
                                    EXIT
                               ENDIF
                          ENDDO
                     ENDIF
                     = swDsytimer(1)
                CASE m.chOice=7
                     = swCrttimer(1,(swSecond*m.hoRistall))
                     = swCrttimer(2,72)
                     DO WHILE swGtimer(2)>0
                          IF baIlout()
                               EXIT
                          ENDIF
                          = hoRizmove(1)
                     ENDDO
                     = swDsytimer(2)
                     IF  .NOT. m.baIlout
                          DO WHILE swGtimer(1)>0
                               = hoRizmove(1)
                               IF stAll1()
                                    EXIT
                               ENDIF
                          ENDDO
                     ENDIF
                     = swDsytimer(1)
                CASE m.chOice=8
                     = swCrttimer(1,(swSecond*m.hoRistall))
                     = swCrttimer(2,72)
                     DO WHILE swGtimer(2)>0
                          IF baIlout()
                               EXIT
                          ENDIF
                          = hoRizmove(2)
                     ENDDO
                     = swDsytimer(2)
                     IF  .NOT. m.baIlout
                          DO WHILE swGtimer(1)>0
                               = hoRizmove(2)
                               IF stAll1()
                                    EXIT
                               ENDIF
                          ENDDO
                     ENDIF
                     = swDsytimer(1)
           ENDCASE
      CASE UPPER(ALLTRIM(m.moDuletype))='FN-145'
           m.stArttime = SECONDS()
           DO CASE
                CASE m.chOice=1
                     = swCrttimer(1,(swSecond*m.frOnstall))
                     = swCrttimer(2,24)
                     DO WHILE swGtimer(2)>0
                          IF baIlout()
                               EXIT
                          ENDIF
                          = frOntmove(1)
                     ENDDO
                     = swDsytimer(2)
                     IF  .NOT. m.baIlout
                          DO WHILE swGtimer(1)>0
                               = frOntmove(1)
                               IF stAll1()
                                    EXIT
                               ENDIF
                          ENDDO
                     ENDIF
                     = swDsytimer(1)
                CASE m.chOice=2
                     = swCrttimer(1,(swSecond*m.frOnstall))
                     = swCrttimer(2,24)
                     DO WHILE swGtimer(2)>0
                          IF baIlout()
                               EXIT
                          ENDIF
                          = frOntmove(2)
                     ENDDO
                     = swDsytimer(2)
                     IF  .NOT. m.baIlout
                          DO WHILE swGtimer(1)>0
                               = frOntmove(2)
                               IF stAll1()
                                    EXIT
                               ENDIF
                          ENDDO
                     ENDIF
                     = swDsytimer(1)
                CASE m.chOice=3
                     = swCrttimer(1,(swSecond*m.baCkstall))
                     = swCrttimer(2,24)
                     DO WHILE swGtimer(2)>0
                          IF baIlout()
                               EXIT
                          ENDIF
                          = baCkmove(1)
                     ENDDO
                     = swDsytimer(2)
                     IF  .NOT. m.baIlout
                          DO WHILE swGtimer(1)>0
                               = baCkmove(1)
                               IF stAll1()
                                    EXIT
                               ENDIF
                          ENDDO
                     ENDIF
                     = swDsytimer(1)
                CASE m.chOice=4
                     = swCrttimer(1,(swSecond*m.baCkstall))
                     = swCrttimer(2,24)
                     DO WHILE swGtimer(2)>0
                          IF baIlout()
                               EXIT
                          ENDIF
                          = baCkmove(2)
                     ENDDO
                     = swDsytimer(2)
                     IF  .NOT. m.baIlout
                          DO WHILE swGtimer(1)>0
                               = baCkmove(2)
                               IF stAll1()
                                    EXIT
                               ENDIF
                          ENDDO
                     ENDIF
                     = swDsytimer(1)
                CASE m.chOice=5
                     = swCrttimer(1,(swSecond*m.reClstall))
                     = swCrttimer(2,72)
                     DO WHILE swGtimer(2)>0
                          IF baIlout()
                               EXIT
                          ENDIF
                          = reClmove(1)
                     ENDDO
                     = swDsytimer(2)
                     IF  .NOT. m.baIlout
                          DO WHILE swGtimer(1)>0
                               = reClmove(1)
                               IF stAll1()
                                    EXIT
                               ENDIF
                          ENDDO
                     ENDIF
                     = swDsytimer(1)
                CASE m.chOice=6
                     = swCrttimer(1,(swSecond*m.reClstall))
                     = swCrttimer(2,72)
                     DO WHILE swGtimer(2)>0
                          IF baIlout()
                               EXIT
                          ENDIF
                          = reClmove(2)
                     ENDDO
                     = swDsytimer(2)
                     IF  .NOT. m.baIlout
                          DO WHILE swGtimer(1)>0
                               = reClmove(2)
                               IF stAll1()
                                    EXIT
                               ENDIF
                          ENDDO
                     ENDIF
                     = swDsytimer(1)
                CASE m.chOice=7
                     = swCrttimer(1,(swSecond*m.hoRistall))
                     = swCrttimer(2,72)
                     DO WHILE swGtimer(2)>0
                          IF baIlout()
                               EXIT
                          ENDIF
                          = hoRizmove(1)
                     ENDDO
                     = swDsytimer(2)
                     IF  .NOT. m.baIlout
                          DO WHILE swGtimer(1)>0
                               = hoRizmove(1)
                               IF stAll1()
                                    EXIT
                               ENDIF
                          ENDDO
                     ENDIF
                     = swDsytimer(1)
                CASE m.chOice=8
                     = swCrttimer(1,(swSecond*m.hoRistall))
                     = swCrttimer(2,72)
                     DO WHILE swGtimer(2)>0
                          IF baIlout()
                               EXIT
                          ENDIF
                          = hoRizmove(2)
                     ENDDO
                     = swDsytimer(2)
                     IF  .NOT. m.baIlout
                          DO WHILE swGtimer(1)>0
                               = hoRizmove(2)
                               IF stAll1()
                                    EXIT
                               ENDIF
                          ENDDO
                     ENDIF
                     = swDsytimer(1)
           ENDCASE
 ENDCASE
 m.stOptime = SECONDS()
 IF m.stOptime>=m.stArttime
      RETURN (stOptime-m.stArttime)
 ELSE
      RETURN (86400-stArttime+m.stOptime)
 ENDIF
 RETURN 0
*
FUNCTION stAll
 PARAMETER liMit
 PRIVATE reAding1, reAding2, reAding3, reAding4, vaLue
 m.reAding1 = 0
 m.reAding2 = 0
 m.reAding3 = 0
 m.reAding4 = 0
 m.vaLue = 0
 = geT_scp(0)
 IF seNd_scp('AD01IN')
      IF geTscp()=0
           IF m.r_Byte1=161
                m.reAding1 = m.r_Byte3-128
                m.reAding2 = m.r_Byte4-128
                m.reAding3 = m.r_Byte5-128
                m.reAding4 = m.r_Byte6-128
           ELSE
                IF m.viEwit
                     ACTIVATE WINDOW viEwwin
                     ? 'Message not an A/D response.'
                ENDIF
                RETURN .F.
           ENDIF
      ELSE
           IF m.viEwit
                ACTIVATE WINDOW viEwwin
                ? 'A single message is not pending.'
           ENDIF
           RETURN .F.
      ENDIF
 ELSE
      IF m.viEwit
           ACTIVATE WINDOW viEwwin
           ? 'Error sending message.'
      ENDIF
      RETURN .F.
 ENDIF
 m.vaLue = ((m.reAding1+m.reAding2+m.reAding3+reAding4)/4)*atOdfactor
 IF m.viEwit
      ACTIVATE WINDOW viEwwin
      ? PADL(STR(m.reAding1*atOdfactor, 4, 2), 4), PADL(STR(m.reAding2* ;
        atOdfactor, 4, 2), 4), PADL(STR(m.reAding3*atOdfactor, 4, 2), 4),  ;
        PADL(STR(m.reAding4*atOdfactor, 4, 2), 4), 'ÄÄ',  ;
        ALLTRIM(STR(m.vaLue, 4, 2))
 ENDIF
 IF (m.vaLue>=m.liMit)
      RETURN .T.
 ENDIF
 RETURN .F.
*
FUNCTION stAll1
 = seNdscp('64','a2',3,'22A50000000000')
 IF baIlout()
      RETURN .T.
 ENDIF
 DO WHILE geTscp()<>-130
      IF m.viEwit
           ACTIVATE WINDOW viEwwin
           ? STR(m.r_Byte1, 3, 0)+'.'+STR(m.r_Byte2, 3, 0)+'.'+ ;
             STR(m.r_Byte3, 3, 0)+'.'+STR(m.r_Byte4, 3, 0)
      ENDIF
      IF (m.r_Byte2=165) .AND. (m.r_Byte3=0)
           IF (m.r_Byte4>0)
                RETURN .F.
           ELSE
                DO WHILE geTscp()=-129
                ENDDO
                RETURN .T.
           ENDIF
      ELSE
           RETURN .F.
      ENDIF
 ENDDO
 RETURN .F.
*
PROCEDURE moVestep
 PARAMETER chOice, tiMes
 PRIVATE l
 = seNd_iso('D0')
 = swWait(3)
 FOR m.l = 1 TO m.tiMes
      = swCrttimer(1,(swSecond*m.stEptime))
      DO CASE
           CASE m.chOice=1
                = frOntmove(1)
                DO WHILE swGtimer(1)>0
                     IF reAd_atod1()<=0
                          EXIT
                     ENDIF
                     = swWait(1)
                ENDDO
           CASE m.chOice=2
                = frOntmove(2)
                DO WHILE swGtimer(1)>0
                     IF reAd_atod1()<=0
                          EXIT
                     ENDIF
                     = swWait(1)
                ENDDO
           CASE m.chOice=3
                = baCkmove(1)
                DO WHILE swGtimer(1)>0
                     IF reAd_atod1()<=0
                          EXIT
                     ENDIF
                     = swWait(1)
                ENDDO
           CASE m.chOice=4
                = baCkmove(2)
                DO WHILE swGtimer(1)>0
                     IF reAd_atod1()<=0
                          EXIT
                     ENDIF
                     = swWait(1)
                ENDDO
           CASE m.chOice=5
                = reClmove(1)
                DO WHILE swGtimer(1)>0
                     IF reAd_atod1()<=0
                          EXIT
                     ENDIF
                     = swWait(1)
                ENDDO
           CASE m.chOice=6
                = reClmove(2)
                DO WHILE swGtimer(1)>0
                     IF reAd_atod1()<=0
                          EXIT
                     ENDIF
                     = swWait(1)
                ENDDO
           CASE m.chOice=7
                = hoRizmove(1)
                DO WHILE swGtimer(1)>0
                     IF reAd_atod1()<=0
                          EXIT
                     ENDIF
                     = swWait(1)
                ENDDO
           CASE m.chOice=8
                = hoRizmove(2)
                DO WHILE swGtimer(1)>0
                     IF reAd_atod1()<=0
                          EXIT
                     ENDIF
                     = swWait(1)
                ENDDO
      ENDCASE
      = swDsytimer(1)
      IF baIlout()
           EXIT
      ENDIF
 ENDFOR
 RETURN
*
PROCEDURE moVetime
 PARAMETER chOice, tiMespan
 PRIVATE ouT, l
 IF m.tiMespan<=0.0
      RETURN
 ENDIF
 = swWait(72)
 = swCrttimer(1,(swSecond*m.tiMespan))
 DO CASE
      CASE (UPPER(ALLTRIM(m.moDuletype))='FN-74' .OR.  ;
           UPPER(ALLTRIM(m.moDuletype))='FN-145') .AND. m.cfGdvrside=1
           DO CASE
                CASE m.chOice=1
                     DO WHILE swGtimer(1)>0
                          = frOntmove(1)
                     ENDDO
                CASE m.chOice=2
                     DO WHILE swGtimer(1)>0
                          = frOntmove(2)
                     ENDDO
                CASE m.chOice=3
                     DO WHILE swGtimer(1)>0
                          = baCkmove(1)
                     ENDDO
                CASE m.chOice=4
                     DO WHILE swGtimer(1)>0
                          = baCkmove(2)
                     ENDDO
                CASE m.chOice=5
                     DO WHILE swGtimer(1)>0
                          = reClmove(1)
                     ENDDO
                CASE m.chOice=6
                     DO WHILE swGtimer(1)>0
                          = reClmove(2)
                     ENDDO
                CASE m.chOice=7
                     DO WHILE swGtimer(1)>0
                          = hoRizmove(1)
                     ENDDO
                CASE m.chOice=8
                     DO WHILE swGtimer(1)>0
                          = hoRizmove(2)
                     ENDDO
           ENDCASE
      OTHERWISE
           DO CASE
                CASE m.chOice=1
                     = seNd_scp('RELAY01OFF')
                     = seNd_scp('RELAY02ON')
                     = swWait(2)
                     DO WHILE swGtimer(1)>0
                          IF stAll(m.frUpstall)
                               EXIT
                          ENDIF
                     ENDDO
                     = seNd_scp('RELAY01OFF')
                     = seNd_scp('RELAY02OFF')
                CASE m.chOice=2
                     = seNd_scp('RELAY01ON')
                     = seNd_scp('RELAY02OFF')
                     = swWait(2)
                     DO WHILE swGtimer(1)>0
                          IF stAll(m.frDnstall)
                               EXIT
                          ENDIF
                     ENDDO
                     = seNd_scp('RELAY01OFF')
                     = seNd_scp('RELAY02OFF')
                CASE m.chOice=3
                     = seNd_scp('RELAY05ON')
                     = seNd_scp('RELAY06OFF')
                     = swWait(2)
                     DO WHILE swGtimer(1)>0
                          IF stAll(m.bkUpstall)
                               EXIT
                          ENDIF
                     ENDDO
                     = seNd_scp('RELAY05OFF')
                     = seNd_scp('RELAY06OFF')
                CASE m.chOice=4
                     = seNd_scp('RELAY06ON')
                     = seNd_scp('RELAY05OFF')
                     = swWait(2)
                     DO WHILE swGtimer(1)>0
                          IF stAll(m.bkDnstall)
                               EXIT
                          ENDIF
                     ENDDO
                     = seNd_scp('RELAY06OFF')
                     = seNd_scp('RELAY05OFF')
                CASE m.chOice=5
                     = seNd_scp('RELAY07ON')
                     = seNd_scp('RELAY08OFF')
                     = swWait(2)
                     DO WHILE swGtimer(1)>0
                          IF stAll(m.reFwstall)
                               EXIT
                          ENDIF
                     ENDDO
                     = seNd_scp('RELAY07OFF')
                     = seNd_scp('RELAY08OFF')
                CASE m.chOice=6
                     = seNd_scp('RELAY08ON')
                     = seNd_scp('RELAY07OFF')
                     = swWait(2)
                     DO WHILE swGtimer(1)>0
                          IF stAll(m.reBkstall)
                               EXIT
                          ENDIF
                     ENDDO
                     = seNd_scp('RELAY08OFF')
                     = seNd_scp('RELAY07OFF')
                CASE m.chOice=7
                     = seNd_scp('RELAY03ON')
                     = seNd_scp('RELAY04OFF')
                     = swWait(2)
                     DO WHILE swGtimer(1)>0
                          IF stAll(m.hoFwstall)
                               EXIT
                          ENDIF
                     ENDDO
                     = seNd_scp('RELAY03OFF')
                     = seNd_scp('RELAY04OFF')
                CASE m.chOice=8
                     = seNd_scp('RELAY04ON')
                     = seNd_scp('RELAY03OFF')
                     = swWait(2)
                     DO WHILE swGtimer(1)>0
                          IF stAll(m.hoBkstall)
                               EXIT
                          ENDIF
                     ENDDO
                     = seNd_scp('RELAY04OFF')
                     = seNd_scp('RELAY03OFF')
           ENDCASE
 ENDCASE
 = swDsytimer(1)
 RETURN
*
PROCEDURE adD_err
 PARAMETER erRorcode
 IF SEEK(m.erRorcode, 'DTC_FILE') .AND.  .NOT. SEEK(m.erRorcode, 'errorlist')
      reSp_lvl( dtC_file.teSt_level, 1) = .F.
      INSERT INTO errorlist (erRcode, erRdesc) VALUE (erRorcode,  ;
             dtC_file.dtC_desc)
 ELSE
      IF  .NOT. SEEK(m.erRorcode, 'errorlist')
           reSp_lvl( 8, 1) = .F.
           INSERT INTO errorlist (erRcode) VALUE (erRorcode)
      ENDIF
 ENDIF
 RETURN
*
PROCEDURE laBelit
 PARAMETER chOice
 PRIVATE stArt, mcOunt, erRstring
 m.xsTart = '810'
 = swTxbuffer(coM2,CHR(2)+'R'+CHR(3))
 = swTxbuffer(coM2,CHR(2)+CHR(27)+'C'+CHR(3))
 = swTxbuffer(coM2,CHR(2)+CHR(27)+'P'+CHR(3))
 DO CASE
      CASE m.cfGlabelsi=1
           = swTxbuffer(coM2,CHR(2)+'E3;F3;'+CHR(3))
           = swTxbuffer(coM2,CHR(2)+'H0;o12,'+m.xsTart+ ;
             ';f1;c20;d0,20;h2;w2;'+CHR(3))
           = swTxbuffer(coM2,CHR(2)+'H1;o57,'+m.xsTart+ ;
             ';f1;c20;d0,14;h2;w2;'+CHR(3))
           = swTxbuffer(coM2,CHR(2)+'L2;o112,'+m.xsTart+';f1;l770;h1;w2;'+ ;
             CHR(3))
           = swTxbuffer(coM2,CHR(2)+'H3;o107,'+m.xsTart+ ;
             ';f1;c20;d0,18;h2;w1;'+CHR(3))
           = swTxbuffer(coM2,CHR(2)+'H4;o152,'+m.xsTart+ ;
             ';f1;c20;d0,40;h2;w1;'+CHR(3))
           = swTxbuffer(coM2,CHR(2)+'L5;o207,'+m.xsTart+';f1;l770;h1;w2;'+ ;
             CHR(3))
           IF m.chOice=1
                = swTxbuffer(coM2,CHR(2)+'H6;o207,'+m.xsTart+ ;
                  ';f1;c20;d3, PASSED ;h2;w2;'+CHR(3))
           ELSE
                = swTxbuffer(coM2,CHR(2)+'H6;o207,'+m.xsTart+ ;
                  ';f1;c20;b2;d3, FAILED ;h2;w2;'+CHR(3))
           ENDIF
           = swTxbuffer(coM2,CHR(2)+'L7;o267,'+m.xsTart+';f1;l770;h1;w2;'+ ;
             CHR(3))
           = swTxbuffer(coM2,CHR(2)+'H8;o267,'+m.xsTart+ ;
             ';f1;c20;d0,60;h1;w1;'+CHR(3))
           = swTxbuffer(coM2,CHR(2)+'H9;o287,'+m.xsTart+ ;
             ';f1;c20;d0,60;h1;w1;'+CHR(3))
      CASE m.cfGlabelsi=2
           = swTxbuffer(coM2,CHR(2)+'E3;F3;'+CHR(3))
           = swTxbuffer(coM2,CHR(2)+'H0;o1,'+m.xsTart+ ;
             ';f1;c20;d0,20;h2;w2;'+CHR(3))
           = swTxbuffer(coM2,CHR(2)+'H1;o46,'+m.xsTart+ ;
             ';f1;c20;d0,14;h2;w2;'+CHR(3))
           = swTxbuffer(coM2,CHR(2)+'L2;o101,'+m.xsTart+';f1;l770;h1;w2;'+ ;
             CHR(3))
           = swTxbuffer(coM2,CHR(2)+'H3;o96,'+m.xsTart+ ;
             ';f1;c20;d0,18;h2;w1;'+CHR(3))
           = swTxbuffer(coM2,CHR(2)+'H4;o141,'+m.xsTart+ ;
             ';f1;c20;d0,40;h2;w1;'+CHR(3))
           = swTxbuffer(coM2,CHR(2)+'L5;o196,'+m.xsTart+';f1;l770;h1;w2;'+ ;
             CHR(3))
           IF m.chOice=1
                = swTxbuffer(coM2,CHR(2)+'H6;o196,'+m.xsTart+ ;
                  ';f1;c20;d3, PASSED ;h2;w2;'+CHR(3))
           ELSE
                = swTxbuffer(coM2,CHR(2)+'H6;o196,'+m.xsTart+ ;
                  ';f1;c20;b2;d3, FAILED ;h2;w2;'+CHR(3))
           ENDIF
           = swTxbuffer(coM2,CHR(2)+'L7;o256,'+m.xsTart+';f1;l770;h1;w2;'+ ;
             CHR(3))
           = swTxbuffer(coM2,CHR(2)+'H8;o196,586;f1;c20;d0,60;h1;w1;'+CHR(3))
           = swTxbuffer(coM2,CHR(2)+'H9;o216,586;f1;c20;d0,60;h1;w1;'+CHR(3))
 ENDCASE
 = swTxbuffer(coM2,CHR(2)+'R'+CHR(3))
 = swTxbuffer(coM2,CHR(2))
 = swTxbuffer(coM2,CHR(27))
 = swTxbuffer(coM2,'E3')
 = swTxbuffer(coM2,CHR(24))
 = swTxbuffer(coM2,m.paRtnum+CHR(13))
 IF m.cfGdvrside=1
      = swTxbuffer(coM2,'DRIVER SEAT'+CHR(13))
 ELSE
      = swTxbuffer(coM2,'PASSENGER SEAT'+CHR(13))
 ENDIF
 = swTxbuffer(coM2,DTOC(DATE())+'  '+TIME()+CHR(13))
 IF ((SECONDS()/3600)>6) .AND. ((SECONDS()/3600)<16)
      = swTxbuffer(coM2,'Cell:'+m.cfGcell+'  Shift:02  Tester:'+m.cfGid+ ;
        CHR(13))
 ELSE
      = swTxbuffer(coM2,'Cell:'+m.cfGcell+'  Shift:03  Tester:'+m.cfGid+ ;
        CHR(13))
 ENDIF
 SELECT erRorlist
 COUNT ALL TO m.mcOunt
 IF m.mcOunt>0
      GOTO TOP
      m.erRstring = ''
      DO CASE
           CASE m.cfGlabelsi=1
                SCAN NEXT 12
                     m.erRstring = m.erRstring+erRorlist.erRcode+','
                ENDSCAN
           CASE m.cfGlabelsi=2
                SCAN NEXT 8
                     m.erRstring = m.erRstring+erRorlist.erRcode+','
                ENDSCAN
      ENDCASE
      = swTxbuffer(coM2,m.erRstring+CHR(13))
      IF  .NOT. EOF()
           m.erRstring = ''
           DO CASE
                CASE m.cfGlabelsi=1
                     SCAN NEXT 12
                          m.erRstring = m.erRstring+erRorlist.erRcode+','
                     ENDSCAN
                CASE m.cfGlabelsi=2
                     SCAN NEXT 8
                          m.erRstring = m.erRstring+erRorlist.erRcode+','
                     ENDSCAN
           ENDCASE
           = swTxbuffer(coM2,m.erRstring+CHR(13))
      ELSE
           = swTxbuffer(coM2,''+CHR(13))
      ENDIF
 ELSE
      = swTxbuffer(coM2,''+CHR(13))
      = swTxbuffer(coM2,''+CHR(13))
 ENDIF
 = swTxbuffer(coM2,CHR(3))
 = swTxbuffer(coM2,CHR(2))
 = swTxbuffer(coM2,CHR(30))
 = swTxbuffer(coM2,'0')
 = swTxbuffer(coM2,'0')
 = swTxbuffer(coM2,'0')
 = swTxbuffer(coM2,'1')
 = swTxbuffer(coM2,CHR(31))
 = swTxbuffer(coM2,'0')
 = swTxbuffer(coM2,'1')
 = swTxbuffer(coM2,CHR(23))
 = swTxbuffer(coM2,CHR(3))
 RETURN
*
FUNCTION laBelstat
 PRIVATE stAt, stAtresult
 = swTxbuffer(coM2,CHR(5))
 m.stAt = ASC(chK_port(coM2))
 DO CASE
      CASE m.stAt=29
           WAIT WINDOW NOWAIT 'Label Printer Error !'+CHR(13)+ ;
                'Buffer already full'
           m.stAtresult = .F.
      CASE m.stAt=14
           WAIT WINDOW NOWAIT 'Label Printer Error !'+CHR(13)+ ;
                'Printhead test failed'
           m.stAtresult = .F.
      CASE m.stAt=31
           WAIT WINDOW NOWAIT 'Label Printer Error !'+CHR(13)+'Paper Path open'
           m.stAtresult = .F.
      CASE m.stAt=31
           WAIT WINDOW NOWAIT 'Label Printer Error !'+CHR(13)+'Ribbon Fault'
           m.stAtresult = .F.
      CASE m.stAt=25
           WAIT WINDOW NOWAIT 'Label Printer Error !'+CHR(13)+'No Label Stock'
           m.stAtresult = .F.
      CASE m.stAt=19
           WAIT WINDOW NOWAIT 'Label Printer Error !'+CHR(13)+'Buffer Now Full'
           m.stAtresult = .F.
      CASE m.stAt=8
           WAIT WINDOW NOWAIT 'Label Printer Error !'+CHR(13)+ ;
                'Takeup Reel Full'
           m.stAtresult = .F.
      CASE m.stAt=28
           WAIT WINDOW NOWAIT 'Label Printer Error !'+CHR(13)+ ;
                'Label at Strip Pin'
           m.stAtresult = .F.
      CASE m.stAt=17
           m.stAtresult = .T.
      OTHERWISE
           WAIT WINDOW NOWAIT 'Label Printer Error !'+CHR(13)+'Unknown'
           = swTxbuffer(coM2,CHR(16))
           m.stAtresult = .T.
 ENDCASE
 RETURN m.stAtresult
*
PROCEDURE prIntit
 PARAMETER chOice
 PRIVATE stArt, mcOunt, erRstring
 ??? m.paRtnum+CHR(10)+CHR(13)
 IF m.cfGdvrside=1
      ??? 'DRIVER SEAT'+CHR(10)+CHR(13)
 ELSE
      ??? 'PASSENGER SEAT'+CHR(10)+CHR(13)
 ENDIF
 ??? DTOC(DATE())+'  '+TIME()+CHR(10)+CHR(13)
 IF ((SECONDS()/3600)>6) .AND. ((SECONDS()/3600)<16)
      ??? 'Cell:'+m.cfGcell+'  Shift:02  Tester:'+m.cfGid+CHR(10)+CHR(13)
 ELSE
      ??? 'Cell:'+m.cfGcell+'  Shift:03  Tester:'+m.cfGid+CHR(10)+CHR(13)
 ENDIF
 ??? '___________________________________'+CHR(10)+CHR(13)
 IF m.chOice=1
      ??? 'PASSED'+CHR(10)+CHR(13)
 ELSE
      ??? 'FAILED  '
 ENDIF
 SELECT erRorlist
 COUNT ALL TO m.mcOunt
 IF m.mcOunt>0
      GOTO TOP
      m.erRstring = ''
      SCAN NEXT 12
           m.erRstring = m.erRstring+erRorlist.erRcode+','
      ENDSCAN
      ??? m.erRstring+CHR(10)+CHR(13)
      IF  .NOT. EOF()
           m.erRstring = ''
           SCAN NEXT 12
                m.erRstring = m.erRstring+erRorlist.erRcode+','
           ENDSCAN
           ??? m.erRstring+CHR(10)+CHR(13)
      ENDIF
 ENDIF
 ??? '___________________________________'+CHR(10)+CHR(13)
 liNecount = 0
 FOR liNecount = 1 TO 2
      ??? CHR(10)
 ENDFOR
 RETURN
*
FUNCTION reAd_atod1
 PRIVATE vaLue, reAding1, reAding2, reAding3, reAding4
 m.reAding1 = 0
 m.reAding2 = 0
 m.reAding3 = 0
 m.reAding4 = 0
 m.vaLue = 0
 = geT_scp(0)
 IF seNd_scp('AD01IN')
      IF geTscp()=0
           IF m.r_Byte1=161
                m.reAding1 = m.r_Byte3-128
                m.reAding2 = m.r_Byte4-128
                m.reAding3 = m.r_Byte5-128
                m.reAding4 = m.r_Byte6-128
           ELSE
                IF m.viEwit
                     ACTIVATE WINDOW viEwwin
                     ? 'Message not an A/D response.'
                ENDIF
                RETURN -1
           ENDIF
      ELSE
           IF m.viEwit
                ACTIVATE WINDOW viEwwin
                ? 'A single message is not pending.'
           ENDIF
           RETURN -1
      ENDIF
 ELSE
      IF m.viEwit
           ACTIVATE WINDOW viEwwin
           ? 'Error sending message.'
      ENDIF
      RETURN -1
 ENDIF
 m.vaLue = (m.reAding1+m.reAding2+m.reAding3+reAding4)/4
 IF m.viEwit
      ACTIVATE WINDOW viEwwin
      ? PADL(STR(m.reAding1*atOdfactor, 4, 2), 4), PADL(STR(m.reAding2* ;
        atOdfactor, 4, 2), 4), PADL(STR(m.reAding3*atOdfactor, 4, 2), 4),  ;
        PADL(STR(m.reAding4*atOdfactor, 4, 2), 4), 'ÄÄ',  ;
        ALLTRIM(STR(m.vaLue*atOdfactor, 4, 2))
 ENDIF
 RETURN m.vaLue*atOdfactor
*
PROCEDURE viEwtog
 IF m.viEwit
      WAIT WINDOW TIMEOUT 0.5 'Viewer Disabled.'
      m.viEwit = .F.
      DEACTIVATE WINDOW viEwwin
 ELSE
      WAIT WINDOW TIMEOUT 0.5 'Viewer Enabled.'
      m.viEwit = .T.
 ENDIF
 RETURN
*
PROCEDURE laRgetog
 IF m.laRge
      WAIT WINDOW TIMEOUT 0.5 'Large Prompts Disabled.'
      m.laRge = .F.
 ELSE
      WAIT WINDOW TIMEOUT 0.5 'Large Prompts Enabled.'
      m.laRge = .T.
 ENDIF
 RETURN
*
PROCEDURE viEwhistry
 PUSH KEY CLEAR
 DEFINE WINDOW brOwwin FROM 1, 0 TO 24, 79 TITLE 'Datalog Database' COLOR  ;
        SCHEME 10
 ACTIVATE WINDOW brOwwin
 SELECT 0
 USE NOUPDATE (cdAtalog) ALIAS daTalog
 BROWSE NOEDIT IN brOwwin
 USE IN daTalog
 RELEASE WINDOW brOwwin
 POP KEY
 RETURN
*
PROCEDURE viEwcodes
 PRIVATE m.cuRrarea
 PUSH KEY CLEAR
 m.cuRrarea = SELECT(0)
 DEFINE WINDOW brOwwin FROM 1, 0 TO 24, 79 TITLE 'Error Codes' COLOR SCHEME 10
 ACTIVATE WINDOW brOwwin
 SELECT dtC_file
 BROWSE FIELDS dtC :H = 'Code', dtC_desc :H = 'Description' NOEDIT IN brOwwin
 RELEASE WINDOW brOwwin
 SELECT (cuRrarea)
 POP KEY
 RETURN
*
PROCEDURE viEwerrors
 PRIVATE m.cuRrarea
 PUSH KEY CLEAR
 m.cuRrarea = SELECT(0)
 DEFINE WINDOW brOwwin FROM 1, 0 TO 24, 79 TITLE 'Test Errors' COLOR SCHEME 10
 ACTIVATE WINDOW brOwwin
 SELECT erRorlist
 BROWSE FIELDS erRcode :H = 'Code', erRdesc :H = 'Description' NOEDIT IN  ;
        brOwwin
 RELEASE WINDOW brOwwin
 SELECT (cuRrarea)
 POP KEY
 RETURN
*
PROCEDURE laRge_prom
 PARAMETER teXttoshow, bkGnd
 PRIVATE atTr, nrOw
 IF TYPE('bkgnd')='U'
      m.bkGnd = 0
 ENDIF
 SHOW WINDOW coVerwin
 IF m.laRge
      = swSetvideo(1)
      = swSetfont(2)
 ENDIF
 IF m.bkGnd=0
      m.atTr = swBldatrib(swBitor(swWhite,swIntense),swBlack)
 ELSE
      m.atTr = swBldatrib(swBitor(swBlack,swBlink),swWhite)
      FOR nrOw = 0 TO 24
           = swScurpos(nrOw,0)
           = swErsendln(m.atTr,39)
      ENDFOR
 ENDIF
 = swRingbell()
 = swPutstr(5,20-LEN(teXttoshow)/2,teXttoshow,m.atTr)
 = swScurpos(23,39)
 RETURN
*
PROCEDURE clEarpromp
 = swSetvideo(m.cuRrvidmod)
 HIDE WINDOW coVerwin
 RETURN
*
FUNCTION in_prompt
 PARAMETER teXttoshow
 PRIVATE atTr, reSp
 m.reSp = 0
 SHOW WINDOW coVerwin
 m.atTr = swBldatrib(swBitor(swWhite,swIntense),swBlack)
 IF m.laRge
      = swSetvideo(1)
      = swSetfont(2)
 ENDIF
 = swRingbell()
 = swPutstr(5,20-LEN(teXttoshow)/2,teXttoshow,m.atTr)
 = swPutstr(6,18,'(Y/N)',m.atTr)
 = swScurpos(24,40)
 DO WHILE (UPPER(CHR(m.reSp))<>'Y' .AND. UPPER(CHR(m.reSp))<>'N')
      m.reSp = INKEY(0)
 ENDDO
 = INKEY(1)
 IF m.laRge
      = swSetvideo(m.cuRrvidmod)
 ENDIF
 HIDE WINDOW coVerwin
 IF UPPER(CHR(m.reSp))='Y'
      RETURN .T.
 ENDIF
 RETURN .F.
*
FUNCTION tiMeprompt
 PARAMETER teXttoshow, txT1, txT2, txT3, txT4, waIttime
 PRIVATE atTr, reSp
 m.reSp = 0
 SHOW WINDOW coVerwin
 m.atTr = swBldatrib(swBitor(swWhite,swIntense),swBlack)
 IF m.laRge
      = swSetvideo(1)
      = swSetfont(2)
 ENDIF
 = swRingbell()
 = swPutstr(3,20-LEN(teXttoshow)/2,teXttoshow,m.atTr)
 = swPutstr(4,1,txT1,m.atTr)
 = swPutstr(5,1,txT2,m.atTr)
 = swPutstr(6,1,txT3,m.atTr)
 = swPutstr(7,1,txT4,m.atTr)
 = swPutstr(10,10,'PRESS Y WHEN DONE.',m.atTr)
 = swScurpos(24,40)
 = swCrttimer(12,swSecond*waIttime)
 DO WHILE (UPPER(CHR(m.reSp))<>'Y' .AND. swGtimer(12)>0)
      m.reSp = INKEY(1)
 ENDDO
 = INKEY(1)
 IF m.laRge
      = swSetvideo(m.cuRrvidmod)
 ENDIF
 HIDE WINDOW coVerwin
 IF UPPER(CHR(m.reSp))='Y'
      RETURN .T.
 ENDIF
 RETURN .F.
*
PROCEDURE prInt_rot
 PUSH KEY CLEAR
 IF  .NOT. PRINTSTATUS()
      WAIT WINDOW 'The printer is Off Line !'+CHR(13)+ ;
           'Place the printer back On Line.'+CHR(13)+ ;
           'Press any key to continue printing...'
 ENDIF
 IF PRINTSTATUS()
      WAIT WINDOW NOWAIT 'Printing...'
      ??? '     '+MDY(DATE())+'  '+TIME()+CHR(13)+CHR(10)
      ??? '     Part Number: '+ALLTRIM(m.paRtnum)+' - '+IIF(m.cfGdvrside= ;
          1, 'DRIVER SIDE', 'PASSENGER SIDE')+CHR(13)+CHR(10)
      ??? '     Description: '+ALLTRIM(m.paRtdesc)+CHR(13)+CHR(10)
      ??? CHR(13)+CHR(10)
      ??? '        Motor/Direction   Average Speed   Travel Length   Travel Time'+ ;
          CHR(13)+CHR(10)
      ??? '        -------------------------------------------------------------'+ ;
          CHR(13)+CHR(10)
      ??? '        Horizontal Fwd.:   '+STR(m.roT_hf, 6, 3)+' mm/sec    '+ ;
          STR(m.h_Travel, 5, 1)+' mm      '+STR(m.tiMe_hf, 6, 3)+' sec.'+ ;
          CHR(13)+CHR(10)
      ??? '        Horizontal Rev.:   '+STR(m.roT_hr, 6, 3)+' mm/sec    '+ ;
          STR(m.h_Travel, 5, 1)+' mm      '+STR(m.tiMe_hr, 6, 3)+' sec.'+ ;
          CHR(13)+CHR(10)
      ??? '        Front Tilt Up  :   '+STR(m.roT_fu, 6, 3)+' mm/sec    '+ ;
          STR(m.f_Travel, 5, 1)+' mm      '+STR(m.tiMe_fu, 6, 3)+' sec.'+ ;
          CHR(13)+CHR(10)
      ??? '        Front Tilt Down:   '+STR(m.roT_fd, 6, 3)+' mm/sec    '+ ;
          STR(m.f_Travel, 5, 1)+' mm      '+STR(m.tiMe_fd, 6, 3)+' sec.'+ ;
          CHR(13)+CHR(10)
      ??? '        Rear Tilt Up   :   '+STR(m.roT_bu, 6, 3)+' mm/sec    '+ ;
          STR(m.b_Travel, 5, 1)+' mm      '+STR(m.tiMe_bu, 6, 3)+' sec.'+ ;
          CHR(13)+CHR(10)
      ??? '        Rear Tilt Down :   '+STR(m.roT_bd, 6, 3)+' mm/sec    '+ ;
          STR(m.b_Travel, 5, 1)+' mm      '+STR(m.tiMe_bd, 6, 3)+' sec.'+ ;
          CHR(13)+CHR(10)
      ??? '        Recliner Fwd.  :   '+STR(m.roT_rf, 6, 3)+' deg/sec   '+ ;
          STR(m.r_Travel, 5, 0)+' deg     '+STR(m.tiMe_rf, 6, 3)+' sec.'+ ;
          CHR(13)+CHR(10)
      ??? '        Recliner Rev.  :   '+STR(m.roT_rr, 6, 3)+' deg/sec   '+ ;
          STR(m.r_Travel, 5, 0)+' deg     '+STR(m.tiMe_rr, 6, 3)+' sec.'+ ;
          CHR(13)+CHR(10)
      ??? CHR(12)
      WAIT CLEAR
 ENDIF
 POP KEY
 RETURN
*
PROCEDURE baCkupdata
 PRIVATE m.baCkname
 PUSH KEY CLEAR
 WAIT WINDOW NOWAIT 'Backing up Datalog database...'
 SET DATE TO ANSI
 m.baCkname = STRTRAN(DTOC(DATE()), '.', '')
 SELECT 0
 USE EXCLUSIVE (cdAtalog) ALIAS daTalog
 IF FILE(m.baCkname+'.dbf')
      SELECT 0
      USE (baCkname)
      APPEND FROM (cdAtalog)
      USE
 ELSE
      COPY TO (baCkname) STRUCTURE
      SELECT 0
      USE (baCkname)
      APPEND FROM (cdAtalog)
      USE
 ENDIF
 SELECT daTalog
 ZAP
 USE
 SET DATE TO AMERICAN
 WAIT CLEAR
 POP KEY
 RETURN
*
FUNCTION geT_scp
 PARAMETER nuMbytes, b1, b2, b3, b4, b5, b6, b7
 PRIVATE reSult, nrEtb
 m.reSult = .T.
 = swCrttimer(8,36)
 m.nrEtb = geTscp()
 DO WHILE ((swGtimer(8)>0) .AND. (m.nrEtb<>-130))
      DO CASE
           CASE m.nuMbytes=7
                IF (m.r_Byte1=m.b1) .AND. (m.r_Byte2=m.b2) .AND.  ;
                   (m.r_Byte3=m.b3) .AND. (m.r_Byte4=m.b4) .AND.  ;
                   (m.r_Byte5=m.b5) .AND. (m.r_Byte6=m.b6) .AND.  ;
                   (m.r_Byte7=m.b7)
                     EXIT
                ELSE
                     IF m.r_Byte1=128 .AND. m.r_Byte2=182 .AND.  ;
                        (m.r_Byte3=3 .OR. m.r_Byte3=1) .AND. m.r_Byte4=0  ;
                        .AND. m.r_Byte5=2 .AND. m.r_Byte6=0
                          WAIT WINDOW NOWAIT 'Driver Seat Occupied Detected !'
                     ELSE
                          WAIT WINDOW NOWAIT 'Something ELSE Detected !'
                          m.reSult = .F.
                     ENDIF
                ENDIF
           CASE m.nuMbytes=6
                IF (m.r_Byte1=m.b1) .AND. (m.r_Byte2=m.b2) .AND.  ;
                   (m.r_Byte3=m.b3) .AND. (m.r_Byte4=m.b4) .AND.  ;
                   (m.r_Byte5=m.b5) .AND. (m.r_Byte6=m.b6)
                     EXIT
                ELSE
                     IF m.r_Byte1=128 .AND. m.r_Byte2=182 .AND.  ;
                        (m.r_Byte3=3 .OR. m.r_Byte3=1) .AND. m.r_Byte4=0  ;
                        .AND. m.r_Byte5=2 .AND. m.r_Byte6=0
                          WAIT WINDOW NOWAIT 'Driver Seat Occupied Detected !'
                     ELSE
                          WAIT WINDOW NOWAIT 'Something ELSE Detected !'
                          m.reSult = .F.
                     ENDIF
                ENDIF
           CASE m.nuMbytes=5
                IF (m.r_Byte1=m.b1) .AND. (m.r_Byte2=m.b2) .AND.  ;
                   (m.r_Byte3=m.b3) .AND. (m.r_Byte4=m.b4) .AND.  ;
                   (m.r_Byte5=m.b5)
                     EXIT
                ELSE
                     IF m.r_Byte1=128 .AND. m.r_Byte2=182 .AND.  ;
                        (m.r_Byte3=3 .OR. m.r_Byte3=1) .AND. m.r_Byte4=0  ;
                        .AND. m.r_Byte5=2 .AND. m.r_Byte6=0
                          WAIT WINDOW NOWAIT 'Driver Seat Occupied Detected !'
                     ELSE
                          WAIT WINDOW NOWAIT 'Something ELSE Detected !'
                          m.reSult = .F.
                     ENDIF
                ENDIF
           CASE m.nuMbytes=4
                IF (m.r_Byte1=m.b1) .AND. (m.r_Byte2=m.b2) .AND.  ;
                   (m.r_Byte3=m.b3) .AND. (m.r_Byte4=m.b4)
                     EXIT
                ELSE
                     IF m.r_Byte1=128 .AND. m.r_Byte2=182 .AND.  ;
                        (m.r_Byte3=3 .OR. m.r_Byte3=1) .AND. m.r_Byte4=0  ;
                        .AND. m.r_Byte5=2 .AND. m.r_Byte6=0
                          WAIT WINDOW NOWAIT 'Driver Seat Occupied Detected !'
                     ELSE
                          WAIT WINDOW NOWAIT 'Something ELSE Detected !'
                          m.reSult = .F.
                     ENDIF
                ENDIF
           CASE m.nuMbytes=3
                IF (m.r_Byte1=m.b1) .AND. (m.r_Byte2=m.b2) .AND.  ;
                   (m.r_Byte3=m.b3)
                     EXIT
                ELSE
                     IF m.r_Byte1=128 .AND. m.r_Byte2=182 .AND.  ;
                        (m.r_Byte3=3 .OR. m.r_Byte3=1) .AND. m.r_Byte4=0  ;
                        .AND. m.r_Byte5=2 .AND. m.r_Byte6=0
                          WAIT WINDOW NOWAIT 'Driver Seat Occupied Detected !'
                     ELSE
                          WAIT WINDOW NOWAIT 'Something ELSE Detected !'
                          m.reSult = .F.
                     ENDIF
                ENDIF
           CASE m.nuMbytes=2
                IF (m.r_Byte1=m.b1) .AND. (m.r_Byte2=m.b2)
                     EXIT
                ELSE
                     IF m.r_Byte1=128 .AND. m.r_Byte2=182 .AND.  ;
                        (m.r_Byte3=3 .OR. m.r_Byte3=1) .AND. m.r_Byte4=0  ;
                        .AND. m.r_Byte5=2 .AND. m.r_Byte6=0
                          WAIT WINDOW NOWAIT 'Driver Seat Occupied Detected !'
                     ELSE
                          WAIT WINDOW NOWAIT 'Something ELSE Detected !'
                          m.reSult = .F.
                     ENDIF
                ENDIF
           CASE m.nuMbytes=1
                IF (m.r_Byte1=m.b1)
                     EXIT
                ELSE
                     IF m.r_Byte1=128 .AND. m.r_Byte2=182 .AND.  ;
                        (m.r_Byte3=3 .OR. m.r_Byte3=1) .AND. m.r_Byte4=0  ;
                        .AND. m.r_Byte5=2 .AND. m.r_Byte6=0
                          WAIT WINDOW NOWAIT 'Driver Seat Occupied Detected !'
                     ELSE
                          WAIT WINDOW NOWAIT 'Something ELSE Detected !'
                          m.reSult = .F.
                     ENDIF
                ENDIF
      ENDCASE
      m.nrEtb = geTscp()
 ENDDO
 IF swGtimer(8)=0
      m.reSult = .F.
 ENDIF
 = swDsytimer(8)
 RETURN m.reSult
*
*** 
*** ReFox - all is not lost 
***
***
*** CONFIG.SPX
***
*
 PRIVATE m.cuRrarea, m.taLkstat, m.coMpstat
 IF SET('TALK')='ON'
      SET TALK OFF
      m.taLkstat = 'ON'
 ELSE
      m.taLkstat = 'OFF'
 ENDIF
 m.coMpstat = SET('COMPATIBLE')
 SET COMPATIBLE FOXPLUS
 IF  .NOT. WEXIST('config') .OR. UPPER(WTITLE('CONFIG'))=='CONFIG.PJX'  ;
     .OR. UPPER(WTITLE('CONFIG'))=='CONFIG.SCX' .OR.  ;
     UPPER(WTITLE('CONFIG'))=='CONFIG.MNX' .OR. UPPER(WTITLE('CONFIG'))== ;
     'CONFIG.PRG' .OR. UPPER(WTITLE('CONFIG'))=='CONFIG.FRX' .OR.  ;
     UPPER(WTITLE('CONFIG'))=='CONFIG.QPR'
      DEFINE WINDOW coNfig FROM INT((SROWS()-24)/2), INT((SCOLS()-79)/2)  ;
             TO INT((SROWS()-24)/2)+23, INT((SCOLS()-79)/2)+78 NOFLOAT  ;
             NOCLOSE SHADOW TITLE  ;
             ' FN-74/FN-116/FN-145/PN-102 Seat Tester Configuration '  ;
             NOMINIMIZE COLOR SCHEME 1
 ENDIF
 PUSH KEY CLEAR
 WAIT CLEAR
 SET TOPIC TO
 PRIVATE chOice, teMp1, teMp2, teMp3
 m.chOice = 1
 m.teMp1 = m.cfGbarcode
 m.teMp2 = m.cfGdvrside
 m.caBletype = m.un93cable
 m.teMp3 = m.cfGshort
 m.coNfigdone = .T.
 IF WVISIBLE('config')
      ACTIVATE WINDOW SAME coNfig
 ELSE
      ACTIVATE WINDOW NOSHOW coNfig
 ENDIF
 @ 8, 44 TO 16, 75
 @ 17, 44 TO 20, 61
 @ 17, 62 TO 21, 75
 @ 11, 2 TO 18, 32
 @ 15, 7 SAY 'for lumbar bag filled' SIZE 1, 21, 0 COLOR GR+/B 
 @ 11, 3 SAY 'Processing Options' SIZE 1, 18, 0
 @ 5, 2 TO 10, 32
 @ 5, 3 SAY 'Shipping Position References' SIZE 1, 28, 0 COLOR W+/B 
 @ 6, 3 SAY 'Horizontal' SIZE 1, 10, 0 COLOR BG+/B 
 @ 7, 3 SAY 'Front' SIZE 1, 5, 0 COLOR BG+/B 
 @ 8, 3 SAY 'Rear' SIZE 1, 4, 0 COLOR BG+/B 
 @ 9, 3 SAY 'Recline' SIZE 1, 7, 0 COLOR BG+/B 
 @ 1, 2 TO 4, 25
 @ 1, 3 SAY 'Seats Being Tested' SIZE 1, 18, 0
 @ 9, 45 SAY 'Alt+P ' SIZE 1, 6, 0 COLOR BG+/B 
 @ 10, 45 SAY 'Alt+B ' SIZE 1, 6, 0 COLOR BG+/B 
 @ 11, 45 SAY 'Alt+T ' SIZE 1, 6, 0 COLOR BG+/B 
 @ 12, 45 SAY 'Alt+F ' SIZE 1, 6, 0 COLOR BG+/B 
 @ 13, 45 SAY 'Alt+U ' SIZE 1, 6, 0 COLOR BG+/B 
 @ 9, 51 SAY 'Modify parts database   ' SIZE 1, 24, 0
 @ 10, 51 SAY 'Backup Datalog database ' SIZE 1, 24, 0
 @ 11, 51 SAY 'Modify Operator timing  ' SIZE 1, 24, 0
 @ 12, 51 SAY 'Change Horiz. parameters' SIZE 1, 24, 0
 @ 13, 51 SAY 'Change UN93 parameters  ' SIZE 1, 24, 0
 @ 8, 45 SAY 'Utility Functions' SIZE 1, 17, 0
 @ 1, 44 TO 7, 75
 @ 1, 45 SAY 'Label & Printer Options' SIZE 1, 23, 0
 @ 0, 50 SAY 'Test cycles:' SIZE 1, 12, 0 COLOR W/B 
 @ 0, 33 SAY 'Cell:' SIZE 1, 5, 0 COLOR W/B 
 @ 0, 3 SAY 'Tester ID:' SIZE 1, 10, 0 COLOR W/B 
 @ 21, 22 GET m.chOice DEFAULT 1 SIZE 1, 10, 5 PICTURE  ;
   '@*HT \!\<Save;\<Cancel' VALID _s9t1chkm3()
 @ 0, 15 GET m.cfGid DEFAULT ' ' SIZE 1, 10 PICTURE '@!K'
 @ 0, 39 GET m.cfGcell DEFAULT ' ' SIZE 1, 2 PICTURE '@!K 99'
 @ 0, 63 SAY m.inStance SIZE 1, 10 PICTURE '@B'
 @ 2, 3 GET m.cfGdvrside DEFAULT 1 SIZE 1, 18, 0 PICTURE  ;
   '@*RVN \<Driver Seat;P\<assenger Seat'
 @ 2, 45 GET m.cfGptr DEFAULT 0 SIZE 1, 18 PICTURE '@*C \<Enable Printer'
 @ 3, 45 GET m.cfGtypeptr DEFAULT 1 SIZE 1, 17, 0 PICTURE  ;
   '@*RVN \<Label Printer;Li\<ne Printer'
 @ 5, 45 GET m.cfGlabelsi DEFAULT 1 SIZE 1, 26, 0 PICTURE  ;
   '@*RVN 4" x \<2" Label Size;4" x \<1-3/8" Label Size'
 @ 6, 14 GET m.cfGhshippo DEFAULT 1 SIZE 1, 8, 0 PICTURE '@*RHN FWD ;BACK'
 @ 7, 14 GET m.cfGfshippo DEFAULT 1 SIZE 1, 8, 0 PICTURE '@*RHN UP  ;DN'
 @ 8, 14 GET m.cfGbshippo DEFAULT 1 SIZE 1, 8, 0 PICTURE '@*RHN UP  ;DN'
 @ 9, 14 GET m.cfGrshippo DEFAULT 1 SIZE 1, 8, 0 PICTURE '@*RHN FWD ;BACK'
 @ 12, 3 GET m.cfGbarcode DEFAULT 0 SIZE 1, 23 PICTURE  ;
   '@*C Ba\<r Code Entry Only'
 @ 13, 3 GET m.cfGautoonl DEFAULT 0 SIZE 1, 18 PICTURE '@*C A\<uto Test Only'
 @ 14, 3 GET m.cfGbagpmpt DEFAULT 0 SIZE 1, 26 PICTURE  ;
   '@*C Enable \<Operator Prompt'
 @ 16, 3 GET m.cfGqc DEFAULT 0 SIZE 1, 15 PICTURE '@*C \<Q.C. Tester'
 @ 17, 3 GET m.cfG2wylumb DEFAULT 0 SIZE 1, 24 PICTURE  ;
   '@*C 2-\<Way Schukra Lumbar'
 @ 18, 45 GET m.caBletype DEFAULT 1 SIZE 1, 14, 0 PICTURE  ;
   '@*RVN \<Ford cable;TT\<I cable'
 @ 17, 45 SAY 'Cable Selection' SIZE 1, 15, 0
 @ 18, 65 GET cfGshtest DEFAULT 1 SIZE 1, 9, 0 PICTURE  ;
   '@*RVN S\<hort;Lon\<g' VALID _s9t1chko9()
 @ 17, 63 SAY 'Test Type' SIZE 1, 9, 0
 @ 14, 45 SAY 'Alt+S' SIZE 1, 5, 0 COLOR BG+/B 
 @ 14, 51 SAY "Change '99 Schukra parms" SIZE 1, 24, 0
 @ 20, 63 SAY 'Alt+H' SIZE 1, 5, 0 COLOR BG+/B 
 @ 20, 69 SAY 'Timing' SIZE 1, 6, 0
 @ 15, 45 SAY 'Alt+Z' SIZE 1, 5, 0 COLOR BG+/B 
 @ 15, 51 SAY 'Mustang current parms' SIZE 1, 21, 0
 IF  .NOT. WVISIBLE('config')
      ACTIVATE WINDOW coNfig
 ENDIF
 READ CYCLE SHOW _s9t1chkp7() WHEN _s9t1chkp6()
 RELEASE WINDOW coNfig
 IF m.taLkstat='ON'
      SET TALK ON
 ENDIF
 IF m.coMpstat='ON'
      SET COMPATIBLE DB4
 ENDIF
 IF m.cfGtypeptr=1
      = swSetuart(1,9600,swParityev,7,1)
 ELSE
      = swSetuart(1,9600,swParityno,8,1)
 ENDIF
 IF m.cfGbarcode<>m.teMp1
      m.meNuchange = .T.
 ENDIF
 IF m.cfGdvrside<>m.teMp2
      m.siDechange = .T.
 ENDIF
 IF m.caBletype=1
      m.un93htrlay = 'RELAY11'
      m.un93igrlay = 'RELAY12'
 ELSE
      m.un93htrlay = 'RELAY11'
      m.un93igrlay = 'RELAY14'
 ENDIF
 m.ccOnfigure = m.csEtuppath+'cfgun93.mem'
 SAVE TO (ccOnfigure) ALL LIKE UN93*
 SHOW GETS
 POP KEY
 CLEAR READ
*
PROCEDURE clEarcycle
 m.inStance = 0
 SAVE TO (ciNstance) ALL LIKE Instance
 SHOW GETS
 RETURN
*
PROCEDURE enTerparts
 DO password.spr
 IF  .NOT. m.paSsresult
      WAIT WINDOW NOWAIT 'Invalid Password.'
 ELSE
      PUSH KEY CLEAR
      DEFINE WINDOW paRtwin FROM 1, 0 TO 24, 79 TITLE  ;
             ' Modifying Parts Database... ' FOOTER  ;
             ' Ctrl+A=Add Part  Ctrl+D=Delete Part  ESC=End ' COLOR SCHEME 10
      ACTIVATE WINDOW paRtwin
      SELECT paRts
      USE (m.cpArtnos) ALIAS paRts ORDER PARTNUM
      ON KEY LABEL Ctrl+A APPEND BLANK
      ON KEY LABEL Ctrl+D DO DELREC
      BROWSE IN paRtwin
      USE NOUPDATE (m.cpArtnos) ALIAS paRts ORDER PARTNUM
      RELEASE WINDOW paRtwin
      POP KEY
 ENDIF
 RETURN
*
PROCEDURE deLrec
 IF DELETED()
      RECALL
 ELSE
      DELETE
 ENDIF
 RETURN
*
PROCEDURE tiMing
 DO password.spr
 IF m.paSsresult
      DO timing.spr
 ELSE
      WAIT WINDOW NOWAIT 'Invalid Password.'
 ENDIF
 RETURN
*
PROCEDURE chGparm
 DO chgparm.spr
 RETURN
*
PROCEDURE un93parm
 DO UN93PARM.spr
 RETURN
*
PROCEDURE scHuk99prm
 DO SCHUK99P.spr
 RETURN
*
PROCEDURE shOrttime
 IF m.cfGshort=.T.
      DO SHORTIME.spr
 ELSE
      WAIT WINDOW 'Timing can only be set when Short test is selected...'
 ENDIF
 RETURN
*
PROCEDURE veRtparm
 DO vertparm.spr
 RETURN
*
PROCEDURE _s9t1chkm3
 IF m.chOice=1
      m.teSter_id = m.cfGid
      m.ccOnfigure = m.csEtuppath+'tester.mem'
      SAVE TO (ccOnfigure) ALL LIKE Cfg*
      m.un93cable = m.caBletype
      m.ccOnfigure = m.csEtuppath+'cfgun93.MEM'
      SAVE TO (ccOnfigure) ALL LIKE UN93*
 ELSE
      m.ccOnfigure = m.csEtuppath+'tester.mem'
      RESTORE FROM (ccOnfigure) ADDITIVE
      m.teSter_id = m.cfGid
      m.ccOnfigure = m.csEtuppath+'cfgun93.MEM'
      RESTORE FROM (ccOnfigure) ADDITIVE
      m.caBletype = m.un93cable
 ENDIF
*
PROCEDURE _s9t1chko9
 IF m.cfGshtest=1
      m.cfGshort = .T.
 ELSE
      m.cfGshort = .F.
 ENDIF
 m.ccOnfigure = m.csEtuppath+'TESTER.MEM'
 SAVE TO (ccOnfigure) ALL LIKE CFG*
*
PROCEDURE _s9t1chkp6
 ON KEY LABEL ALT+B DO BackupData
 ON KEY LABEL ALT+P DO enterparts
 ON KEY LABEL ALT+T DO timing
 ON KEY LABEL ALT+F DO CHGPARM
 ON KEY LABEL ALT+U DO UN93PARM
 ON KEY LABEL ALT+S DO SCHUK99PRM
 ON KEY LABEL ALT+H DO SHORTTIME
 ON KEY LABEL ALT+Z DO VERTPARM
 ON KEY LABEL F1 DO DO_HELP
 ON KEY LABEL ESC Do Silly
*
PROCEDURE _s9t1chkp7
 PRIVATE cuRrwind
 STORE WOUTPUT() TO cuRrwind
 IF SYS(2016)='CONFIG' .OR. SYS(2016)='*'
      ACTIVATE WINDOW SAME coNfig
      @ 0, 63 SAY m.inStance SIZE 1, 10, 0 PICTURE '@B'
 ENDIF
 IF  .NOT. EMPTY(cuRrwind)
      ACTIVATE WINDOW SAME (cuRrwind)
 ENDIF
*
***
*** SHORTEST.FXP
***
*
*
FUNCTION shOrtfrt
 PARAMETER diRection, ruNcur, tiMetorun
 PUBLIC cuRrdraw
 PUBLIC frOnt[ 2]
 STORE .F. TO frOnt
 cuRrdraw = 0
 = swDaltimer()
 m.goTit = .F.
 IF m.viEwit
      ACTIVATE WINDOW viEwwin
      ? 'Testing Front Motor...'
 ENDIF
 = laRge_prom('PRESS & HOLD FRONT '+m.diRection+' SWITCH...',0)
 = swCrttimer(1,(swSecond*m.cfGshwait))
 DO WHILE swGtimer(1)>0
      m.cuRrdraw = reAd_atod1()
      IF m.cuRrdraw>0
           m.goTit = .T.
           EXIT
      ENDIF
 ENDDO
 = swDsytimer(1)
 IF m.goTit=.F.
      = adD_err('0000')
      RETURN .F.
 ELSE
      m.goTit = .F.
 ENDIF
 = swCrttimer(1,(swSecond*tiMetorun))
 DO WHILE swGtimer(1)>0
      IF baIlout()
           = adD_err('0000')
           RETURN .F.
      ENDIF
      m.cuRrdraw = reAd_atod1()
 ENDDO
 IF m.cuRrdraw>=m.ruNcur
      STORE .T. TO frOnt[ 1]
      = laRge_prom('RELEASE FRONT '+m.diRection+' SWITCH...',1)
      = swCrttimer(2,swSecond*m.cfGshwait)
      DO WHILE swGtimer(2)>0
           IF baIlout()
                = adD_err('0000')
                EXIT
           ENDIF
           IF reAd_atod1()<m.ruNcur
                STORE .T. TO frOnt[ 2]
                EXIT
           ENDIF
      ENDDO
      = swDsytimer(2)
      = swDsytimer(1)
 ENDIF
 IF frOnt(1) .AND. frOnt(2)
      m.goTit = .T.
 ELSE
      m.goTit = .F.
 ENDIF
 RETURN m.goTit
*
FUNCTION shOrtrr
 PARAMETER diRection, ruNcur, tiMetorun
 PUBLIC reAr[ 2]
 STORE .F. TO reAr
 PUBLIC cuRrdraw
 cuRrdraw = 0
 = swDaltimer()
 m.goTit = .F.
 IF m.viEwit
      ACTIVATE WINDOW viEwwin
      ? 'Testing Rear Motor...'
 ENDIF
 = laRge_prom('PRESS & HOLD REAR '+m.diRection+' SWITCH...',0)
 = swCrttimer(1,(swSecond*m.cfGshwait))
 DO WHILE swGtimer(1)>0
      m.cuRrdraw = reAd_atod1()
      IF m.cuRrdraw>0
           m.goTit = .T.
           EXIT
      ENDIF
 ENDDO
 = swDsytimer(1)
 IF m.goTit=.F.
      = adD_err('0000')
      RETURN .F.
 ELSE
      m.goTit = .F.
 ENDIF
 = swCrttimer(1,(swSecond*tiMetorun))
 DO WHILE swGtimer(1)>0
      IF baIlout()
           = adD_err('0000')
           RETURN .F.
      ENDIF
      m.cuRrdraw = reAd_atod1()
 ENDDO
 IF m.cuRrdraw>=m.ruNcur
      STORE .T. TO reAr[ 1]
      = laRge_prom('RELEASE REAR '+m.diRection+' SWITCH...',1)
      = swCrttimer(2,swSecond*m.cfGshwait)
      DO WHILE swGtimer(2)>0
           IF baIlout()
                = adD_err('0000')
                EXIT
           ENDIF
           IF reAd_atod1()<m.ruNcur
                STORE .T. TO reAr[ 2]
                EXIT
           ENDIF
      ENDDO
      = swDsytimer(2)
      = swDsytimer(1)
 ENDIF
 IF reAr(1) .AND. reAr(2)
      m.goTit = .T.
 ELSE
      m.goTit = .F.
 ENDIF
 RETURN m.goTit
*
FUNCTION shOrthoriz
 PARAMETER diRection, ruNcur, tiMetorun
 PUBLIC hoRiz[ 2]
 PUBLIC cuRrdraw
 STORE .F. TO hoRiz
 cuRrdraw = 0
 = swDaltimer()
 m.goTit = .F.
 IF m.viEwit
      ACTIVATE WINDOW viEwwin
      ? 'Testing track Motor...'
 ENDIF
 = laRge_prom('HOLD HORIZONTAL '+m.diRection+' SWITCH...',0)
 = swCrttimer(1,(swSecond*m.cfGshwait))
 DO WHILE swGtimer(1)>0
      m.cuRrdraw = reAd_atod1()
      IF m.cuRrdraw>0
           m.goTit = .T.
           EXIT
      ENDIF
 ENDDO
 = swDsytimer(1)
 IF m.goTit=.F.
      = adD_err('0000')
      RETURN .F.
 ELSE
      m.goTit = .F.
 ENDIF
 = swCrttimer(1,(swSecond*tiMetorun))
 DO WHILE swGtimer(1)>0
      IF baIlout()
           = adD_err('0000')
           RETURN .F.
      ENDIF
      m.cuRrdraw = reAd_atod1()
 ENDDO
 IF m.cuRrdraw>=m.ruNcur
      STORE .T. TO hoRiz[ 1]
      = laRge_prom('RELEASE HORIZONTAL '+m.diRection+' SWITCH...',1)
      = swCrttimer(2,swSecond*m.cfGshwait)
      DO WHILE swGtimer(2)>0
           IF baIlout()
                = adD_err('0000')
                EXIT
           ENDIF
           IF reAd_atod1()<m.ruNcur
                STORE .T. TO hoRiz[ 2]
                EXIT
           ENDIF
      ENDDO
      = swDsytimer(2)
      = swDsytimer(1)
 ENDIF
 IF hoRiz(1) .AND. hoRiz(2)
      m.goTit = .T.
 ELSE
      m.goTit = .F.
 ENDIF
 RETURN m.goTit
*
***
*** LONGTEST.FXP
***
*
*
FUNCTION loNgfrt
 PARAMETER diRection, ruNcur, stAllcur, tiMetorun, swReltime
 = swDaltimer()
 m.goTit = .F.
 IF m.viEwit
      ACTIVATE WINDOW viEwwin
      ? 'Testing Front Motor...'
 ENDIF
 = laRge_prom('PRESS & HOLD FRONT '+m.diRection+' SWITCH...',0)
 = swCrttimer(1,(swSecond*m.tiMetorun))
 DO WHILE swGtimer(1)>0
      IF baIlout()
           = adD_err('0000')
           EXIT
      ENDIF
      IF reAd_atod1()>=m.stAllcur
           m.goTit = .F.
           = laRge_prom('RELEASE FRONT '+m.diRection+' SWITCH...',1)
           = swCrttimer(2,swSecond*m.swReltime)
           DO WHILE swGtimer(2)>0
                IF baIlout()
                     = adD_err('0000')
                     EXIT
                ENDIF
                IF reAd_atod1()<=m.ruNcur
                     m.goTit = .T.
                     EXIT
                ENDIF
           ENDDO
           = swDsytimer(2)
           EXIT
      ENDIF
 ENDDO
 RETURN m.goTit
*
FUNCTION loNgrr
 PARAMETER diRection, ruNcur, stAllcur, tiMetorun, swReltime
 = swDaltimer()
 m.goTit = .F.
 IF m.viEwit
      ACTIVATE WINDOW viEwwin
      ? 'Testing Rear Motor...'
 ENDIF
 = laRge_prom('PRESS & HOLD REAR '+m.diRection+' SWITCH...',0)
 = swCrttimer(1,(swSecond*m.tiMetorun))
 DO WHILE swGtimer(1)>0
      IF baIlout()
           = adD_err('0000')
           EXIT
      ENDIF
      IF reAd_atod1()>=m.stAllcur
           m.goTit = .F.
           = laRge_prom('RELEASE REAR '+m.diRection+' SWITCH...',1)
           = swCrttimer(2,swSecond*m.swReltime)
           DO WHILE swGtimer(2)>0
                IF baIlout()
                     = adD_err('0000')
                     EXIT
                ENDIF
                IF reAd_atod1()<=m.ruNcur
                     m.goTit = .T.
                     EXIT
                ENDIF
           ENDDO
           = swDsytimer(2)
           EXIT
      ENDIF
 ENDDO
 RETURN m.goTit
*
FUNCTION loNghoriz
 PARAMETER diRection, ruNcur, stAllcur, tiMetorun, swReltime
 = swDaltimer()
 m.goTit = .F.
 IF m.viEwit
      ACTIVATE WINDOW viEwwin
      ? 'Testing Track Motor...'
 ENDIF
 = laRge_prom('PRESS & HOLD HORIZONTAL '+m.diRection+' SWITCH...',0)
 = swCrttimer(1,(swSecond*m.tiMetorun))
 DO WHILE swGtimer(1)>0
      IF baIlout()
           = adD_err('0000')
           EXIT
      ENDIF
      IF reAd_atod1()>=m.stAllcur
           m.goTit = .F.
           = laRge_prom('RELEASE HORIZONTAL '+m.diRection+' SWITCH...',1)
           = swCrttimer(2,swSecond*m.swReltime)
           DO WHILE swGtimer(2)>0
                IF baIlout()
                     = adD_err('0000')
                     EXIT
                ENDIF
                IF reAd_atod1()<=m.ruNcur
                     m.goTit = .T.
                     EXIT
                ENDIF
           ENDDO
           = swDsytimer(2)
           EXIT
      ENDIF
 ENDDO
 RETURN m.goTit
*
***
*** VERTPARM.SPX
***
*
 PRIVATE m.cuRrarea, m.taLkstat, m.coMpstat
 IF SET('TALK')='ON'
      SET TALK OFF
      m.taLkstat = 'ON'
 ELSE
      m.taLkstat = 'OFF'
 ENDIF
 m.coMpstat = SET('COMPATIBLE')
 SET COMPATIBLE FOXPLUS
 IF  .NOT. WEXIST('vertparm') .OR. UPPER(WTITLE('VERTPARM'))== ;
     'VERTPARM.PJX' .OR. UPPER(WTITLE('VERTPARM'))=='VERTPARM.SCX' .OR.  ;
     UPPER(WTITLE('VERTPARM'))=='VERTPARM.MNX' .OR.  ;
     UPPER(WTITLE('VERTPARM'))=='VERTPARM.PRG' .OR.  ;
     UPPER(WTITLE('VERTPARM'))=='VERTPARM.FRX' .OR.  ;
     UPPER(WTITLE('VERTPARM'))=='VERTPARM.QPR'
      DEFINE WINDOW veRtparm FROM INT((SROWS()-16)/2), INT((SCOLS()-45)/ ;
             2) TO INT((SROWS()-16)/2)+15, INT((SCOLS()-45)/2)+44 NOFLOAT  ;
             NOCLOSE SHADOW TITLE 'Modify FRT/RR Motor Settings'  ;
             NOMINIMIZE COLOR SCHEME 1
 ENDIF
 IF WVISIBLE('vertparm')
      ACTIVATE WINDOW SAME veRtparm
 ELSE
      ACTIVATE WINDOW NOSHOW veRtparm
 ENDIF
 @ 2, 4 SAY 'Running current draw (amperes)' SIZE 1, 30, 0
 @ 3, 4 SAY 'Stall current draw' SIZE 1, 18, 0
 @ 4, 4 SAY 'Minimum run time' SIZE 1, 16, 0
 @ 5, 4 SAY 'Maximum run time' SIZE 1, 16, 0
 @ 1, 2 TO 6, 40
 @ 8, 4 SAY 'Running current draw (amperes)' SIZE 1, 30, 0
 @ 9, 4 SAY 'Stall current draw' SIZE 1, 18, 0
 @ 10, 4 SAY 'Minimum run time' SIZE 1, 16, 0
 @ 11, 4 SAY 'Maximum run time' SIZE 1, 16, 0
 @ 7, 2 TO 12, 40
 @ 1, 10 SAY 'Front vertical motor' SIZE 1, 20, 0
 @ 7, 10 SAY 'Rear vertical motor' SIZE 1, 19, 0
 @ 0, 15 SAY 'M U S T A N G' SIZE 1, 13, 0
 @ 2, 35 GET m.vfRuncur DEFAULT 0 SIZE 1, 4 PICTURE '@K'
 @ 3, 35 GET m.vfStallcur DEFAULT 0 SIZE 1, 4 PICTURE '@K'
 @ 4, 35 GET m.vfMintime DEFAULT 0 SIZE 1, 4 PICTURE '@K'
 @ 5, 35 GET m.vfMaxtime DEFAULT 0 SIZE 1, 4 PICTURE '@K'
 @ 8, 35 GET m.vrRuncur DEFAULT 0 SIZE 1, 4 PICTURE '@K'
 @ 9, 35 GET m.vrStallcur DEFAULT 0 SIZE 1, 4 PICTURE '@K'
 @ 10, 35 GET m.vrMintime DEFAULT 0 SIZE 1, 4 PICTURE '@K'
 @ 11, 35 GET m.vrMaxtime DEFAULT 0 SIZE 1, 4 RANGE 5.0,99.9 PICTURE '@K'
 @ 13, 11 GET btNokcance DEFAULT 1 SIZE 1, 8, 5 PICTURE  ;
   '@*HT \!\<Ok;\<Cancel' VALID _s9t1chjm8()
 IF  .NOT. WVISIBLE('vertparm')
      ACTIVATE WINDOW veRtparm
 ENDIF
 READ CYCLE
 RELEASE WINDOW veRtparm
 IF m.taLkstat='ON'
      SET TALK ON
 ENDIF
 IF m.coMpstat='ON'
      SET COMPATIBLE DB4
 ENDIF
*
PROCEDURE _s9t1chjm8
 IF btNokcance=1
      SET SAFETY OFF
      SAVE TO c:\seattest\vert.mem ALL LIKE V*
 ELSE
      RESTORE FROM c:\seattest\vert.mem ADDITIVE
 ENDIF
 SHOW GETS
*
